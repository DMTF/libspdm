/**
 *  Copyright Notice:
 *  Copyright 2021-2022 DMTF. All rights reserved.
 *  License: BSD 3-Clause License. For full text see link: https://github.com/DMTF/libspdm/blob/main/LICENSE.md
 **/

/** @file
 * SPDM common library.
 * It follows the SPDM Specification.
 **/
#include <base.h>
#if defined(_MSC_VER) || (defined(__clang__) && (defined (LIBSPDM_CPU_AARCH64) || \
    defined(LIBSPDM_CPU_ARM)))
#else
    #include <fcntl.h>
    #include <unistd.h>
    #include <sys/stat.h>
#endif
#include <stdarg.h>
#include <stddef.h>
#include <setjmp.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>
#include <string.h>

#include "library/memlib.h"
#include "spdm_device_secret_lib_internal.h"

bool g_in_trusted_environment = false;

/* "LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY = 1" means use the RAW private key only
 * "LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY = 0" means controled by g_private_key_mode
 **/
#define LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY 0
/* "g_private_key_mode = 1" means use the PEM mode
 * "g_private_key_mode = 0" means use the RAW mode
 **/
#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
bool g_private_key_mode = 1;
#endif

#if LIBSPDM_ECDSA_SUPPORT
/*ecp256 key for responder: https://lapo.it/asn1js/#MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgA-LbmJWXV0yozX6-mbTl9gXB8CC340M4Dzyh9fm-ymahRANCAATbwrK3gzzIheQ94fO64vKQjjAlFOH3qYIp2512L4ARMu6r4mjRIue9tHEnyHn73HyeM6ZnwhBHNjLFoaprK6rJ */
uint8_t m_libspdm_ec256_responder_public_key[] = {
    0xDB, 0xC2, 0xB2, 0xB7, 0x83, 0x3C, 0xC8, 0x85, 0xE4, 0x3D, 0xE1, 0xF3, 0xBA, 0xE2, 0xF2, 0x90,
    0x8E, 0x30, 0x25, 0x14, 0xE1, 0xF7, 0xA9, 0x82, 0x29, 0xDB, 0x9D, 0x76, 0x2F, 0x80, 0x11, 0x32,
    0xEE, 0xAB, 0xE2, 0x68, 0xD1, 0x22, 0xE7, 0xBD, 0xB4, 0x71, 0x27, 0xC8, 0x79, 0xFB, 0xDC, 0x7C,
    0x9E, 0x33, 0xA6, 0x67, 0xC2, 0x10, 0x47, 0x36, 0x32, 0xC5, 0xA1, 0xAA, 0x6B, 0x2B, 0xAA, 0xC9,
};
uint8_t m_libspdm_ec256_responder_private_key[] = {
    0x03, 0xE2, 0xDB, 0x98, 0x95, 0x97, 0x57, 0x4C, 0xA8, 0xCD, 0x7E, 0xBE, 0x99, 0xB4, 0xE5, 0xF6,
    0x05, 0xC1, 0xF0, 0x20, 0xB7, 0xE3, 0x43, 0x38, 0x0F, 0x3C, 0xA1, 0xF5, 0xF9, 0xBE, 0xCA, 0x66,
};

/*ecp256 key for requester: https://lapo.it/asn1js/#MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgdfD68vDHVyb6RtOjRiRHA8PeicgpEZdCXmUkLe_AZ4KhRANCAASP2s4pe0vw9lS_RSKN5vCi6Br78l73g6UO9YJQMWnMgsti2ZbkxliSurAmI1Q9Qu27F0hsSkttXCYjBrOjZH2w */
uint8_t m_libspdm_ec256_requester_public_key[] = {
    0x8F, 0xDA, 0xCE, 0x29, 0x7B, 0x4B, 0xF0, 0xF6, 0x54, 0xBF, 0x45, 0x22, 0x8D, 0xE6, 0xF0, 0xA2,
    0xE8, 0x1A, 0xFB, 0xF2, 0x5E, 0xF7, 0x83, 0xA5, 0x0E, 0xF5, 0x82, 0x50, 0x31, 0x69, 0xCC, 0x82,
    0xCB, 0x62, 0xD9, 0x96, 0xE4, 0xC6, 0x58, 0x92, 0xBA, 0xB0, 0x26, 0x23, 0x54, 0x3D, 0x42, 0xED,
    0xBB, 0x17, 0x48, 0x6C, 0x4A, 0x4B, 0x6D, 0x5C, 0x26, 0x23, 0x06, 0xB3, 0xA3, 0x64, 0x7D, 0xB0,
};
uint8_t m_libspdm_ec256_requester_private_key[] = {
    0x75, 0xF0, 0xFA, 0xF2, 0xF0, 0xC7, 0x57, 0x26, 0xFA, 0x46, 0xD3, 0xA3, 0x46, 0x24, 0x47, 0x03,
    0xC3, 0xDE, 0x89, 0xC8, 0x29, 0x11, 0x97, 0x42, 0x5E, 0x65, 0x24, 0x2D, 0xEF, 0xC0, 0x67, 0x82,
};

/*ecp384 key for responder: https://lapo.it/asn1js/#MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDA0-Tw5nC64l4QCjOWcy-HO6RXQ1KwbLt4cgtNmLhrK3K7dez84YVgB4Q3tfzUDpKKhZANiAASM-ISdEQdJyhzQtRG84084PPDFjXNap2N-X2JgfxBDNMhPLLxwj02i_U4DiRZJykBqkRgJfyfv5KYmGv3U0VfbWxt1BfkVnTM0vpC3XtcFuXOFHkrTAFt9EGi_T8rmOEw */
uint8_t m_libspdm_ec384_responder_public_key[] = {
    0x8C, 0xF8, 0x84, 0x9D, 0x11, 0x07, 0x49, 0xCA, 0x1C, 0xD0, 0xB5, 0x11, 0xBC, 0xE3, 0x4F, 0x38,
    0x3C, 0xF0, 0xC5, 0x8D, 0x73, 0x5A, 0xA7, 0x63, 0x7E, 0x5F, 0x62, 0x60, 0x7F, 0x10, 0x43, 0x34,
    0xC8, 0x4F, 0x2C, 0xBC, 0x70, 0x8F, 0x4D, 0xA2, 0xFD, 0x4E, 0x03, 0x89, 0x16, 0x49, 0xCA, 0x40,
    0x6A, 0x91, 0x18, 0x09, 0x7F, 0x27, 0xEF, 0xE4, 0xA6, 0x26, 0x1A, 0xFD, 0xD4, 0xD1, 0x57, 0xDB,
    0x5B, 0x1B, 0x75, 0x05, 0xF9, 0x15, 0x9D, 0x33, 0x34, 0xBE, 0x90, 0xB7, 0x5E, 0xD7, 0x05, 0xB9,
    0x73, 0x85, 0x1E, 0x4A, 0xD3, 0x00, 0x5B, 0x7D, 0x10, 0x68, 0xBF, 0x4F, 0xCA, 0xE6, 0x38, 0x4C,
};
uint8_t m_libspdm_ec384_responder_private_key[] = {
    0x34, 0xF9, 0x3C, 0x39, 0x9C, 0x2E, 0xB8, 0x97, 0x84, 0x02, 0x8C, 0xE5, 0x9C, 0xCB, 0xE1, 0xCE,
    0xE9, 0x15, 0xD0, 0xD4, 0xAC, 0x1B, 0x2E, 0xDE, 0x1C, 0x82, 0xD3, 0x66, 0x2E, 0x1A, 0xCA, 0xDC,
    0xAE, 0xDD, 0x7B, 0x3F, 0x38, 0x61, 0x58, 0x01, 0xE1, 0x0D, 0xED, 0x7F, 0x35, 0x03, 0xA4, 0xA2,
};

/*ecp384 key for requester: https://lapo.it/asn1js/#MIG2AgEAMBAGByqGSM49AgEGBSuBBAAiBIGeMIGbAgEBBDA7QU-F6Q0XfyS7Ai8AWHQ_7vBzlNMXyEWFd_jj725rW2Wgma2klLQ_GxFXZRa9YuShZANiAAR_0kFWDa34dseElhXQHHx5LKLQeSjqIyc9lqyL8QQtA3xNT2-alMpkS5anltaG4hVqjplC8Yzwo34MFWllc5bkOaRj8Wn6L4nK8xC4U6PRSLv6LzFCtvEbF7wdv_87woE */
uint8_t m_libspdm_ec384_requester_public_key[] = {
    0x7F, 0xD2, 0x41, 0x56, 0x0D, 0xAD, 0xF8, 0x76, 0xC7, 0x84, 0x96, 0x15, 0xD0, 0x1C, 0x7C, 0x79,
    0x2C, 0xA2, 0xD0, 0x79, 0x28, 0xEA, 0x23, 0x27, 0x3D, 0x96, 0xAC, 0x8B, 0xF1, 0x04, 0x2D, 0x03,
    0x7C, 0x4D, 0x4F, 0x6F, 0x9A, 0x94, 0xCA, 0x64, 0x4B, 0x96, 0xA7, 0x96, 0xD6, 0x86, 0xE2, 0x15,
    0x6A, 0x8E, 0x99, 0x42, 0xF1, 0x8C, 0xF0, 0xA3, 0x7E, 0x0C, 0x15, 0x69, 0x65, 0x73, 0x96, 0xE4,
    0x39, 0xA4, 0x63, 0xF1, 0x69, 0xFA, 0x2F, 0x89, 0xCA, 0xF3, 0x10, 0xB8, 0x53, 0xA3, 0xD1, 0x48,
    0xBB, 0xFA, 0x2F, 0x31, 0x42, 0xB6, 0xF1, 0x1B, 0x17, 0xBC, 0x1D, 0xBF, 0xFF, 0x3B, 0xC2, 0x81,
};
uint8_t m_libspdm_ec384_requester_private_key[] = {
    0x3B, 0x41, 0x4F, 0x85, 0xE9, 0x0D, 0x17, 0x7F, 0x24, 0xBB, 0x02, 0x2F, 0x00, 0x58, 0x74, 0x3F,
    0xEE, 0xF0, 0x73, 0x94, 0xD3, 0x17, 0xC8, 0x45, 0x85, 0x77, 0xF8, 0xE3, 0xEF, 0x6E, 0x6B, 0x5B,
    0x65, 0xA0, 0x99, 0xAD, 0xA4, 0x94, 0xB4, 0x3F, 0x1B, 0x11, 0x57, 0x65, 0x16, 0xBD, 0x62, 0xE4,
};

/*ecp521 key for responder:https://lapo.it/asn1js/#MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIBpE81rQW44M0W7N1gFcsp2a4GVmylosU0yfS2P86LkHrp7Tmr_uT6jDTBtB7BfFgKMpCDGBuY1TROTy4PGgD-ssGhgYkDgYYABAD6KJmjhuNRjPIGfvFbuYBCJ9NqDBaWeOQzEwP9tHsT9cKC3qUypr3zR5rwXi1D9l_aMhQ77CPW7Ofy6Euj2NTX5gG3kCpc9Xr2smQ4o_5xi6RpNZLt43HsfP7ITJVyh6LunJwwKOwnEJsi4bpgYVwDBpqi7Hc5gNoVkfAvGoswjI-uuw */
uint8_t m_libspdm_ec521_responder_public_key[] = {
    0x00, 0xFA, 0x28, 0x99, 0xA3, 0x86, 0xE3, 0x51, 0x8C, 0xF2, 0x06, 0x7E, 0xF1, 0x5B, 0xB9, 0x80,
    0x42, 0x27, 0xD3, 0x6A, 0x0C, 0x16, 0x96, 0x78, 0xE4, 0x33, 0x13, 0x03, 0xFD, 0xB4, 0x7B, 0x13,
    0xF5, 0xC2, 0x82, 0xDE, 0xA5, 0x32, 0xA6, 0xBD, 0xF3, 0x47, 0x9A, 0xF0, 0x5E, 0x2D, 0x43, 0xF6,
    0x5F, 0xDA, 0x32, 0x14, 0x3B, 0xEC, 0x23, 0xD6, 0xEC, 0xE7, 0xF2, 0xE8, 0x4B, 0xA3, 0xD8, 0xD4,
    0xD7, 0xE6, 0x01, 0xB7, 0x90, 0x2A, 0x5C, 0xF5, 0x7A, 0xF6, 0xB2, 0x64, 0x38, 0xA3, 0xFE, 0x71,
    0x8B, 0xA4, 0x69, 0x35, 0x92, 0xED, 0xE3, 0x71, 0xEC, 0x7C, 0xFE, 0xC8, 0x4C, 0x95, 0x72, 0x87,
    0xA2, 0xEE, 0x9C, 0x9C, 0x30, 0x28, 0xEC, 0x27, 0x10, 0x9B, 0x22, 0xE1, 0xBA, 0x60, 0x61, 0x5C,
    0x03, 0x06, 0x9A, 0xA2, 0xEC, 0x77, 0x39, 0x80, 0xDA, 0x15, 0x91, 0xF0, 0x2F, 0x1A, 0x8B, 0x30,
    0x8C, 0x8F, 0xAE, 0xBB,
};
uint8_t m_libspdm_ec521_responder_private_key[] = {
    0x01, 0xA4, 0x4F, 0x35, 0xAD, 0x05, 0xB8, 0xE0, 0xCD, 0x16, 0xEC, 0xDD, 0x60, 0x15, 0xCB, 0x29,
    0xD9, 0xAE, 0x06, 0x56, 0x6C, 0xA5, 0xA2, 0xC5, 0x34, 0xC9, 0xF4, 0xB6, 0x3F, 0xCE, 0x8B, 0x90,
    0x7A, 0xE9, 0xED, 0x39, 0xAB, 0xFE, 0xE4, 0xFA, 0x8C, 0x34, 0xC1, 0xB4, 0x1E, 0xC1, 0x7C, 0x58,
    0x0A, 0x32, 0x90, 0x83, 0x18, 0x1B, 0x98, 0xD5, 0x34, 0x4E, 0x4F, 0x2E, 0x0F, 0x1A, 0x00, 0xFE,
    0xB2, 0xC1,
};

/*ecp521 key for requester: https://lapo.it/asn1js/#MIHuAgEAMBAGByqGSM49AgEGBSuBBAAjBIHWMIHTAgEBBEIAmZwOAdF8XQEgWGQvIjjrscHCchXSkGeo_e4zThOfAhoPNPBKFgS67lnYvme4_ifgFu8ZB9mEDq8fZTXr79kgWJqhgYkDgYYABAFdeB9FFJE8SE5g8ep6pP2pyShfUCGh6xnp5PVfeM0snOe7aMXPj5ZD_NXjv-g7mVL7_puw9Xphfbk3htSNaIxJFwHOFfvDxeCrwgtCU9SP7KtB7LedWr3aIsZDXkRwSdIi6h_767Skyh6VTCJM0-_SQUGYAs9Ys3lI4luYdPLzHs78XQ */
uint8_t m_libspdm_ec521_requester_public_key[] = {
    0x01, 0x5D, 0x78, 0x1F, 0x45, 0x14, 0x91, 0x3C, 0x48, 0x4E, 0x60, 0xF1, 0xEA, 0x7A, 0xA4, 0xFD,
    0xA9, 0xC9, 0x28, 0x5F, 0x50, 0x21, 0xA1, 0xEB, 0x19, 0xE9, 0xE4, 0xF5, 0x5F, 0x78, 0xCD, 0x2C,
    0x9C, 0xE7, 0xBB, 0x68, 0xC5, 0xCF, 0x8F, 0x96, 0x43, 0xFC, 0xD5, 0xE3, 0xBF, 0xE8, 0x3B, 0x99,
    0x52, 0xFB, 0xFE, 0x9B, 0xB0, 0xF5, 0x7A, 0x61, 0x7D, 0xB9, 0x37, 0x86, 0xD4, 0x8D, 0x68, 0x8C,
    0x49, 0x17, 0x01, 0xCE, 0x15, 0xFB, 0xC3, 0xC5, 0xE0, 0xAB, 0xC2, 0x0B, 0x42, 0x53, 0xD4, 0x8F,
    0xEC, 0xAB, 0x41, 0xEC, 0xB7, 0x9D, 0x5A, 0xBD, 0xDA, 0x22, 0xC6, 0x43, 0x5E, 0x44, 0x70, 0x49,
    0xD2, 0x22, 0xEA, 0x1F, 0xFB, 0xEB, 0xB4, 0xA4, 0xCA, 0x1E, 0x95, 0x4C, 0x22, 0x4C, 0xD3, 0xEF,
    0xD2, 0x41, 0x41, 0x98, 0x02, 0xCF, 0x58, 0xB3, 0x79, 0x48, 0xE2, 0x5B, 0x98, 0x74, 0xF2, 0xF3,
    0x1E, 0xCE, 0xFC, 0x5D,
};
uint8_t m_libspdm_ec521_requester_private_key[] = {
    0x00, 0x99, 0x9C, 0x0E, 0x01, 0xD1, 0x7C, 0x5D, 0x01, 0x20, 0x58, 0x64, 0x2F, 0x22, 0x38, 0xEB,
    0xB1, 0xC1, 0xC2, 0x72, 0x15, 0xD2, 0x90, 0x67, 0xA8, 0xFD, 0xEE, 0x33, 0x4E, 0x13, 0x9F, 0x02,
    0x1A, 0x0F, 0x34, 0xF0, 0x4A, 0x16, 0x04, 0xBA, 0xEE, 0x59, 0xD8, 0xBE, 0x67, 0xB8, 0xFE, 0x27,
    0xE0, 0x16, 0xEF, 0x19, 0x07, 0xD9, 0x84, 0x0E, 0xAF, 0x1F, 0x65, 0x35, 0xEB, 0xEF, 0xD9, 0x20,
    0x58, 0x9A,
};
#endif /*LIBSPDM_ECDSA_SUPPORT*/

#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
/* Public modulus of RSA2048 responder key. */
uint8_t m_libspdm_rsa2048_res_n[] = {
    0x00, 0xa5, 0xd8, 0xd2, 0x5b, 0x47, 0x6c, 0x57, 0x1e, 0xc2, 0x15, 0x9a, 0x2b, 0xae, 0xed,
    0x15, 0xb6, 0x18, 0x33, 0x61, 0xcf, 0xe9, 0xe3, 0x95, 0x20, 0x67, 0xd0, 0x29, 0xda, 0x4c,
    0x9b, 0x1e, 0x12, 0x80, 0x2c, 0x35, 0x41, 0x25, 0xb2, 0xfe, 0x71, 0x3f, 0xb9, 0xae, 0x60,
    0xc8, 0x5f, 0x78, 0x96, 0xd4, 0xc4, 0xfb, 0x6c, 0xed, 0xa7, 0x5d, 0xff, 0x90, 0x01, 0xa4,
    0x52, 0x86, 0x48, 0x5f, 0x2d, 0xb0, 0x34, 0x4f, 0x58, 0x3f, 0x70, 0x84, 0x38, 0x87, 0x1f,
    0x8b, 0x50, 0x84, 0x4e, 0xbd, 0x3b, 0x3a, 0xe4, 0x00, 0x8b, 0x11, 0x4f, 0xcb, 0xa2, 0xa1,
    0x0b, 0x9f, 0x10, 0x2e, 0x7d, 0xce, 0x71, 0x24, 0x7e, 0x8d, 0x6d, 0xb4, 0xfa, 0xed, 0x48,
    0x93, 0x0b, 0xc8, 0xf6, 0x5b, 0xef, 0xd7, 0xdc, 0xbc, 0xf1, 0x32, 0x3f, 0x8e, 0xc0, 0x60,
    0x31, 0x1e, 0xbb, 0xbf, 0x45, 0x39, 0xc2, 0x48, 0xa1, 0x6e, 0xac, 0x02, 0x71, 0xda, 0xb8,
    0x9b, 0x4e, 0x03, 0x19, 0xab, 0xe6, 0x41, 0x1e, 0xbc, 0xcb, 0xdc, 0x77, 0x90, 0xb5, 0x9a,
    0x6e, 0x9d, 0x66, 0xf4, 0xcf, 0x1a, 0xd3, 0xa2, 0x9c, 0x9b, 0xc3, 0x15, 0x9f, 0x43, 0xe0,
    0xff, 0x84, 0xee, 0x7d, 0x73, 0xeb, 0x3b, 0xec, 0xb5, 0x03, 0x40, 0x54, 0xd6, 0x18, 0x72,
    0x54, 0x52, 0x8a, 0x4d, 0x35, 0x6a, 0x33, 0xba, 0x76, 0x54, 0x6c, 0x99, 0xad, 0x1c, 0x7f,
    0xa0, 0x53, 0x09, 0x79, 0xf7, 0x7c, 0xab, 0xa0, 0x36, 0x8e, 0xd2, 0x7e, 0x71, 0x34, 0x81,
    0x8c, 0x59, 0xc6, 0xa8, 0x82, 0xb6, 0x38, 0x9f, 0x5b, 0x8d, 0x29, 0x11, 0x4d, 0x6e, 0xe0,
    0x5b, 0x5f, 0x40, 0xfb, 0xa0, 0x7f, 0xf7, 0x8c, 0xfb, 0x54, 0x5d, 0xcc, 0x51, 0xdc, 0x5d,
    0xa3, 0xc2, 0xb0, 0x68, 0x86, 0x92, 0x64, 0x63, 0xa8, 0xfd, 0x28, 0x41, 0x33, 0xc9, 0x8a,
    0x1f, 0x57,
};

/* Public exponent of RSA2048 responder key. */
uint8_t m_libspdm_rsa2048_res_e[] = { 0x01, 0x00, 0x01 };

/* Private exponent of RSA2048 responder key. */
uint8_t m_libspdm_rsa2048_res_d[] = {
    0x5e, 0xdb, 0xe6, 0x6d, 0xb9, 0x2b, 0x79, 0xa5, 0x29, 0x23, 0xcb, 0xfb, 0xc2, 0x60, 0xee,
    0xf3, 0x29, 0x62, 0x72, 0x46, 0xc6, 0xa3, 0x9a, 0x4f, 0x5f, 0xb1, 0x8b, 0xce, 0xc5, 0xd4,
    0x4f, 0x5e, 0x0b, 0x9b, 0xbd, 0x96, 0x16, 0xa7, 0x0b, 0xab, 0xe0, 0xe4, 0x26, 0x9e, 0x4a,
    0xdd, 0x78, 0x8e, 0xe5, 0x02, 0x0a, 0x41, 0x22, 0xa9, 0x81, 0x35, 0x44, 0xbb, 0xfb, 0xae,
    0x0c, 0x0a, 0x67, 0x0e, 0x2d, 0xe3, 0xad, 0xa2, 0x6f, 0x1e, 0xbf, 0x31, 0xc9, 0xef, 0xbb,
    0xf2, 0x80, 0xca, 0xbc, 0xa7, 0x9d, 0x26, 0x7e, 0x3d, 0x0c, 0xd8, 0xd4, 0x43, 0x9f, 0xd3,
    0x92, 0xd6, 0x61, 0x91, 0x29, 0xbc, 0x43, 0x40, 0x73, 0x4a, 0x55, 0xa2, 0xd4, 0x87, 0x97,
    0x3b, 0xbd, 0x65, 0x53, 0xee, 0x9a, 0x4c, 0x32, 0x71, 0xce, 0xe8, 0xd5, 0x90, 0xa9, 0x34,
    0x4f, 0x3c, 0xd9, 0xc9, 0x11, 0xa1, 0x53, 0x82, 0xbe, 0xa0, 0xa3, 0x14, 0x14, 0xcc, 0x2e,
    0x86, 0xb3, 0xcc, 0x97, 0x84, 0x6b, 0x14, 0x77, 0x0c, 0x31, 0x32, 0xc6, 0xfe, 0x79, 0xe3,
    0x38, 0xa8, 0x93, 0xe6, 0x1c, 0x03, 0xf9, 0xad, 0x8c, 0x37, 0xae, 0x4e, 0x57, 0xd7, 0xb9,
    0x23, 0xb9, 0x91, 0x36, 0x63, 0xce, 0x0e, 0x7c, 0xdd, 0xac, 0x3f, 0x5d, 0x5c, 0xee, 0x9b,
    0xaa, 0x08, 0xc4, 0x24, 0x89, 0x9b, 0x73, 0xa0, 0x97, 0xb9, 0xdf, 0x77, 0x17, 0x42, 0xb7,
    0xb0, 0xbe, 0x05, 0xc6, 0x98, 0x95, 0x60, 0xe5, 0x3b, 0xbe, 0x48, 0x2a, 0x3c, 0xc8, 0xa5,
    0x79, 0x12, 0xbe, 0x4a, 0xf2, 0x77, 0xbc, 0x42, 0xe8, 0x0b, 0x04, 0xaf, 0xb5, 0x1e, 0x55,
    0xac, 0x87, 0x7c, 0xf2, 0x16, 0x6f, 0x02, 0x44, 0xcb, 0x14, 0xa8, 0xe0, 0xa9, 0x1f, 0x35,
    0x34, 0x18, 0xad, 0x75, 0xdb, 0x1e, 0xa1, 0x32, 0x7d, 0xcf, 0x1b, 0xe8, 0x49, 0x66, 0xf3,
    0x01,
};

/* Public modulus of RSA2048 requester key. */
uint8_t m_libspdm_rsa2048_req_n[] = {
    0x00, 0x93, 0x47, 0xf3, 0x71, 0x6b, 0x24, 0x1e, 0xc0, 0xeb, 0x6b, 0x22, 0x23, 0xe7, 0xc8,
    0x10, 0x9d, 0xb2, 0xef, 0x1e, 0x65, 0xe9, 0xff, 0xd6, 0x37, 0xee, 0xc5, 0x3f, 0x29, 0x25,
    0x94, 0xb4, 0x30, 0x97, 0x51, 0xe3, 0x51, 0xa4, 0x39, 0xd1, 0x27, 0x32, 0x9e, 0x6b, 0x80,
    0xc2, 0x29, 0xf2, 0x28, 0xd1, 0x49, 0xdc, 0x62, 0x27, 0x5b, 0x3f, 0xce, 0x83, 0xd7, 0x7b,
    0x09, 0x37, 0x48, 0x16, 0x7f, 0x2e, 0x6e, 0xfa, 0x67, 0xaa, 0x92, 0x17, 0xcb, 0xff, 0x4b,
    0xe3, 0x1b, 0xd1, 0xa6, 0xe3, 0x6c, 0x4d, 0x9f, 0x9e, 0xc7, 0x01, 0xed, 0x9f, 0x14, 0xb0,
    0x34, 0x44, 0xa2, 0x88, 0x28, 0xf2, 0x3f, 0xad, 0xf2, 0xf7, 0x51, 0x8c, 0xfe, 0x43, 0x73,
    0xfa, 0x8d, 0x2f, 0x63, 0x8c, 0x0e, 0xe5, 0x27, 0xdc, 0x12, 0x81, 0x26, 0xea, 0x92, 0x67,
    0x7d, 0xc9, 0xfc, 0xec, 0x4c, 0xcc, 0x79, 0x4d, 0x2d, 0xfe, 0xf6, 0x63, 0xb7, 0x63, 0xca,
    0x70, 0x24, 0xe0, 0x23, 0x53, 0x92, 0xe8, 0x56, 0xb7, 0x85, 0x6d, 0x25, 0x9e, 0xe0, 0x24,
    0xa8, 0x5c, 0xe0, 0x0f, 0xc1, 0xb6, 0x20, 0x2f, 0x85, 0x2a, 0x67, 0xf6, 0x1b, 0x58, 0x60,
    0x5a, 0x14, 0xda, 0xc2, 0x03, 0x10, 0x79, 0x33, 0x3c, 0x41, 0xc6, 0xbe, 0xd2, 0xee, 0x2f,
    0x65, 0xd5, 0xad, 0x9c, 0xc6, 0x09, 0xae, 0x26, 0xf2, 0xac, 0xc2, 0x65, 0x12, 0x74, 0x09,
    0xe8, 0x89, 0x66, 0xf6, 0x95, 0xb8, 0x6a, 0x5f, 0x96, 0xc2, 0x3c, 0x9f, 0x01, 0x52, 0xa8,
    0xc8, 0x4e, 0xd8, 0xba, 0x95, 0x38, 0x5b, 0xf8, 0xc6, 0x43, 0x54, 0xac, 0x63, 0x90, 0xd4,
    0xde, 0x11, 0x40, 0x27, 0xe5, 0x12, 0x1d, 0x72, 0xa2, 0xec, 0xad, 0x0a, 0x8b, 0x68, 0x21,
    0x9d, 0xea, 0x16, 0x70, 0x5f, 0x32, 0x3a, 0xed, 0x4f, 0x0b, 0xb2, 0x44, 0x1f, 0x44, 0x9b,
    0x4c, 0x03,
};

/* Public exponent of RSA2048 requester key. */
uint8_t m_libspdm_rsa2048_req_e[] = { 0x01, 0x00, 0x01 };

/* Private exponent of RSA2048 requester key. */
uint8_t m_libspdm_rsa2048_req_d[] = {
    0x0e, 0x06, 0x7f, 0x0f, 0x60, 0xf5, 0x9a, 0x9c, 0x22, 0x8f, 0x1c, 0x3c, 0x31, 0x19, 0x63,
    0x43, 0xb1, 0x43, 0x86, 0x30, 0x8c, 0x5d, 0x19, 0xa8, 0x4f, 0xeb, 0xa6, 0xbd, 0x23, 0x60,
    0x0a, 0xdc, 0xc9, 0xbc, 0x39, 0x9a, 0x8f, 0xba, 0x15, 0xc9, 0xd6, 0xcf, 0x31, 0x4b, 0x9c,
    0xb1, 0xe3, 0xe6, 0xb1, 0x2f, 0x88, 0x76, 0x2c, 0x6b, 0x4b, 0x23, 0x3e, 0x78, 0xe9, 0xb5,
    0x91, 0xf7, 0x22, 0x75, 0x50, 0x15, 0xaf, 0x70, 0xe9, 0xd4, 0x69, 0xc1, 0xba, 0x79, 0x1e,
    0x92, 0x8a, 0x9f, 0x8a, 0xee, 0xc8, 0x61, 0x97, 0xfc, 0x39, 0x99, 0xc8, 0x59, 0x6f, 0x02,
    0x3b, 0x3b, 0x03, 0x1e, 0x6b, 0x1b, 0x57, 0x54, 0x58, 0xeb, 0x02, 0x33, 0x40, 0x77, 0x2d,
    0xf7, 0xfd, 0xf8, 0x4b, 0xe1, 0x2b, 0x3f, 0x65, 0x7c, 0xb9, 0xa1, 0xdc, 0x1a, 0xbf, 0x12,
    0x42, 0x86, 0xfc, 0x75, 0xbf, 0xcf, 0x19, 0x63, 0x4f, 0xf5, 0x99, 0x0f, 0xdb, 0xf4, 0xe1,
    0x02, 0x7e, 0xb1, 0x5f, 0xc9, 0x10, 0x2a, 0x6c, 0x5b, 0x0e, 0xaf, 0xa3, 0x7a, 0xa1, 0x32,
    0x1e, 0x8f, 0x19, 0x9c, 0xdf, 0x46, 0xa5, 0x93, 0x22, 0xcb, 0x5a, 0x6a, 0x8b, 0x47, 0x7e,
    0x9b, 0xe3, 0x2e, 0x9a, 0xc5, 0x5d, 0xa5, 0x8c, 0x84, 0xdb, 0xcf, 0x49, 0x59, 0x29, 0x46,
    0xf5, 0xf2, 0xcb, 0x60, 0xd9, 0x5f, 0x0a, 0x74, 0x56, 0xef, 0x28, 0x58, 0x37, 0x18, 0x90,
    0x01, 0xcf, 0x4f, 0x27, 0xbb, 0xa2, 0x56, 0x80, 0x56, 0xcf, 0x59, 0xb9, 0xdd, 0x8c, 0x1e,
    0x29, 0xe5, 0xb1, 0x74, 0xa3, 0x70, 0x79, 0x59, 0x37, 0xf0, 0xae, 0xe0, 0x51, 0xd2, 0x99,
    0x4b, 0x42, 0x97, 0x96, 0x7f, 0xea, 0x98, 0x0e, 0x6c, 0x73, 0xf7, 0x45, 0x15, 0xa7, 0x86,
    0xd4, 0x8a, 0x24, 0xe3, 0x36, 0x2b, 0x5e, 0x87, 0xef, 0xa0, 0x3a, 0xce, 0xd8, 0x61, 0xdc,
    0x99,
};

/* Public modulus of RSA3072 responder key. */
uint8_t m_libspdm_rsa3072_res_n[] = {
    0x00, 0xa5, 0xbb, 0xeb, 0xc7, 0xa2, 0xc4, 0xd1, 0x70, 0x12, 0x55, 0xa8, 0x01, 0x2a, 0x7b,
    0x8f, 0x9e, 0x4e, 0xf5, 0x66, 0xd2, 0xe0, 0xbb, 0xb5, 0xbf, 0x72, 0x59, 0x87, 0xfe, 0xea,
    0x59, 0xee, 0xf3, 0xef, 0x7f, 0x55, 0x8b, 0xd9, 0xb5, 0x02, 0xb8, 0xae, 0x17, 0xb6, 0x2f,
    0x0d, 0x38, 0x91, 0x4a, 0xd2, 0x71, 0x66, 0x3c, 0x1b, 0xaf, 0x2a, 0xed, 0x9c, 0x16, 0x49,
    0xf9, 0xf1, 0xf5, 0x7b, 0xa5, 0x57, 0xa4, 0x3e, 0x35, 0x14, 0x5c, 0x99, 0x1a, 0x05, 0x74,
    0x7f, 0x0f, 0xca, 0x63, 0xad, 0x84, 0x4f, 0x37, 0x96, 0xf9, 0x28, 0x15, 0x7b, 0x0e, 0x13,
    0x7d, 0x97, 0xf7, 0x7f, 0xb7, 0xd6, 0x7e, 0x5e, 0x27, 0xa5, 0x6c, 0x0e, 0xef, 0x4b, 0xd8,
    0xd8, 0x35, 0x9d, 0xcc, 0x86, 0xb0, 0x0e, 0x02, 0xca, 0x1c, 0x64, 0x6f, 0x82, 0xd5, 0x6f,
    0xb5, 0x8f, 0x6b, 0xd6, 0x57, 0xeb, 0x9e, 0xe6, 0xb2, 0x1d, 0x1c, 0x0d, 0xe1, 0xd6, 0xb1,
    0xfc, 0x3b, 0x84, 0x9f, 0x7b, 0xd8, 0xd6, 0x20, 0x21, 0x2f, 0x86, 0xae, 0x0e, 0xa0, 0x58,
    0x37, 0x8e, 0x5b, 0x5d, 0xee, 0xf6, 0x3c, 0xd6, 0xbd, 0xc3, 0xe2, 0x62, 0xd1, 0xe5, 0x0d,
    0xcc, 0x57, 0xfd, 0xac, 0xa4, 0x71, 0x55, 0xf4, 0x52, 0x73, 0x11, 0xc4, 0x4f, 0x90, 0x72,
    0x58, 0x12, 0xeb, 0x2b, 0x01, 0x69, 0xf2, 0x10, 0x7a, 0xc9, 0xe8, 0x73, 0x32, 0x9a, 0x9a,
    0x86, 0x79, 0x6c, 0x07, 0xea, 0x1a, 0xa9, 0x83, 0x46, 0x94, 0x4b, 0xee, 0x53, 0x04, 0xe4,
    0xa6, 0x2f, 0x51, 0xa8, 0xb3, 0x47, 0xac, 0x24, 0xb5, 0x65, 0x05, 0x37, 0xaf, 0xcd, 0x10,
    0x37, 0x6b, 0x03, 0xed, 0xf8, 0x65, 0xc8, 0x2e, 0x9f, 0x2e, 0x85, 0xf2, 0x34, 0xb5, 0xbf,
    0x3d, 0x43, 0x9e, 0xcc, 0xee, 0xf7, 0x70, 0x12, 0xe7, 0x3e, 0x8d, 0xcc, 0x3c, 0x6b, 0x37,
    0x95, 0xe0, 0x02, 0x88, 0x27, 0x85, 0x8a, 0xdd, 0x12, 0x71, 0x0e, 0x6c, 0x98, 0x58, 0xda,
    0x08, 0x6d, 0xee, 0x04, 0x02, 0x98, 0x62, 0xfd, 0xf1, 0x33, 0x78, 0x2d, 0x8f, 0x08, 0xd7,
    0x29, 0xa9, 0x8d, 0xd4, 0x11, 0xb7, 0x24, 0xb3, 0xf4, 0x78, 0xb0, 0x8b, 0x4e, 0xbd, 0x5b,
    0x04, 0x93, 0x1b, 0x76, 0x2a, 0xb6, 0xcd, 0x65, 0x1a, 0xe0, 0x54, 0x73, 0x0a, 0xae, 0x0f,
    0xfa, 0xf6, 0x91, 0x38, 0xfa, 0x25, 0xff, 0x2b, 0xd2, 0xda, 0x97, 0x36, 0x64, 0x32, 0x9f,
    0x6c, 0x25, 0x66, 0x9c, 0xe6, 0x8c, 0xc4, 0x6d, 0xf9, 0x9d, 0xbe, 0x26, 0x7c, 0xcf, 0xac,
    0x4c, 0xfd, 0x86, 0xe4, 0x78, 0x79, 0x1f, 0x17, 0x73, 0x25, 0x5f, 0x2b, 0x9e, 0x3b, 0xfc,
    0xf6, 0x16, 0x4a, 0x07, 0x32, 0x6f, 0xe2, 0x54, 0x9c, 0xbc, 0x34, 0x30, 0xd5, 0x21, 0x8b,
    0xb0, 0x06, 0x4a, 0xe5, 0xfd, 0xc5, 0xe6, 0xcc, 0xc6, 0xeb,
};

/* Public exponent of RSA3072 responder key. */
uint8_t m_libspdm_rsa3072_res_e[] = { 0x01, 0x00, 0x01 };

/* Private exponent of RSA3072 responder key. */
uint8_t m_libspdm_rsa3072_res_d[] = {
    0x2e, 0x10, 0xd5, 0xb0, 0x5f, 0xa5, 0xa5, 0x31, 0x29, 0x67, 0x75, 0x93, 0x1d, 0x63, 0xca,
    0xbf, 0x8d, 0xe2, 0xd7, 0xf9, 0xb5, 0x4d, 0x77, 0x6f, 0x07, 0x31, 0xab, 0x83, 0x47, 0x50,
    0x48, 0x02, 0xb5, 0x87, 0x07, 0x18, 0x20, 0x23, 0x17, 0xe6, 0x8d, 0x3d, 0x39, 0xfe, 0x4a,
    0x06, 0x77, 0x1b, 0xfc, 0xf2, 0x58, 0x20, 0x4c, 0xf1, 0x9b, 0x55, 0x00, 0x15, 0x91, 0xea,
    0x4f, 0x3e, 0x94, 0x67, 0x98, 0xbc, 0xa6, 0x2d, 0xca, 0xc3, 0x12, 0x2b, 0x11, 0x69, 0x18,
    0x08, 0x23, 0x91, 0x21, 0x21, 0xad, 0x83, 0x1e, 0x0b, 0x93, 0x00, 0xa5, 0x7b, 0x7c, 0x1f,
    0x64, 0xa5, 0xfe, 0x71, 0xf2, 0xc4, 0x9d, 0x17, 0x17, 0xfb, 0xb9, 0x0a, 0xfa, 0x62, 0x03,
    0x76, 0xa3, 0xad, 0xbd, 0xa2, 0x21, 0xc2, 0xd4, 0xba, 0x9f, 0x8f, 0xff, 0x25, 0xa4, 0x2f,
    0x2a, 0xf6, 0x26, 0x55, 0xb9, 0xc0, 0x29, 0x0f, 0x48, 0xd8, 0x0b, 0x63, 0xc2, 0x71, 0x26,
    0x52, 0xc4, 0xc2, 0x2f, 0x82, 0x4d, 0xc2, 0x10, 0x77, 0x4d, 0x50, 0x03, 0xf0, 0xbd, 0x94,
    0x73, 0x95, 0x21, 0xbe, 0xd1, 0xe2, 0x87, 0x2d, 0xa7, 0xcc, 0xbc, 0xfa, 0xea, 0x57, 0xb3,
    0x7c, 0xa1, 0x9d, 0xe2, 0xf7, 0x3d, 0x94, 0xf3, 0x75, 0xd8, 0x72, 0x60, 0x4b, 0x1d, 0xfd,
    0x2d, 0x05, 0x00, 0xa7, 0x1b, 0xf3, 0x94, 0x71, 0x0c, 0xbd, 0xf7, 0x86, 0x9e, 0x89, 0x77,
    0xbb, 0x26, 0xd2, 0xd5, 0xea, 0x04, 0x4e, 0x4d, 0xf9, 0x7e, 0xfd, 0x2f, 0xb4, 0xa8, 0x3d,
    0x23, 0x6f, 0xd8, 0xec, 0x6e, 0x86, 0x0c, 0xe6, 0xde, 0x46, 0x59, 0xaa, 0xa8, 0xf9, 0x7b,
    0xd8, 0x14, 0x0e, 0xb3, 0x01, 0x9d, 0xa4, 0x08, 0x29, 0xb1, 0x3f, 0xa6, 0xbc, 0x34, 0x04,
    0xd3, 0x53, 0x3e, 0xfb, 0xb0, 0xaa, 0x61, 0xf7, 0xcd, 0x85, 0x1a, 0x8f, 0x98, 0x05, 0x18,
    0x72, 0x95, 0x7c, 0x29, 0x0f, 0x8a, 0xc4, 0x81, 0x79, 0xb2, 0x3b, 0xa2, 0xc3, 0x7b, 0xcb,
    0xb7, 0x5c, 0xae, 0x50, 0xef, 0x70, 0x62, 0xd9, 0x2f, 0x6b, 0x36, 0x4a, 0xe2, 0x78, 0x96,
    0x60, 0x55, 0xd8, 0xad, 0xa6, 0x5e, 0xb7, 0x64, 0x0b, 0x5f, 0xc4, 0x83, 0xec, 0x49, 0xe0,
    0x9a, 0xdf, 0xb6, 0x2f, 0x40, 0x96, 0x8d, 0xfb, 0x34, 0xbf, 0x2d, 0xfe, 0xe7, 0xc5, 0x68,
    0xbe, 0x6c, 0x97, 0x6e, 0xeb, 0xcc, 0x2f, 0xea, 0xf6, 0x00, 0xe1, 0x28, 0xac, 0xa2, 0xf7,
    0xe8, 0xbd, 0xe6, 0xfc, 0x0f, 0x84, 0x91, 0x32, 0x06, 0x84, 0x5f, 0xe3, 0x0e, 0x0a, 0x12,
    0x3b, 0x6e, 0x70, 0xcf, 0x75, 0x74, 0xf9, 0x2d, 0xe2, 0xf1, 0xba, 0x35, 0x37, 0xc3, 0xb3,
    0x96, 0x55, 0x2c, 0xb9, 0xd0, 0x1b, 0x64, 0xa3, 0x9c, 0x81, 0xa7, 0x3d, 0xc8, 0xc4, 0xe1,
    0xa3, 0x86, 0x83, 0x2e, 0x91, 0xa4, 0xac, 0xad, 0x01,
};

/* Public modulus of RSA3072 requester key. */
uint8_t m_libspdm_rsa3072_req_n[] = {
    0x00, 0xd5, 0x5d, 0x78, 0x7c, 0xe8, 0x26, 0x7f, 0xc5, 0x17, 0x64, 0xfd, 0xe3, 0x28, 0x44,
    0x81, 0xd5, 0xfd, 0xa9, 0xad, 0x8d, 0xa3, 0x6c, 0xcf, 0xd0, 0x7c, 0xbb, 0xdc, 0x7d, 0xee,
    0x84, 0x56, 0x17, 0x6a, 0x7b, 0x6d, 0x99, 0x0f, 0xe7, 0x61, 0x6d, 0x44, 0x4b, 0x88, 0x11,
    0x10, 0xb7, 0x1b, 0xd5, 0x8a, 0x8a, 0xcf, 0xcb, 0x8a, 0xdd, 0x88, 0xb3, 0x70, 0x4c, 0x79,
    0xc8, 0x3f, 0x61, 0x6b, 0x7b, 0xef, 0xb3, 0xba, 0x76, 0xa7, 0xa7, 0xf0, 0x85, 0x25, 0xae,
    0x8d, 0x32, 0xba, 0x57, 0x13, 0xb7, 0x03, 0xaf, 0x3a, 0x72, 0x90, 0x1f, 0x10, 0x31, 0x56,
    0x18, 0xe8, 0x63, 0x07, 0x8b, 0x73, 0x1b, 0xb4, 0xaf, 0x70, 0x7a, 0xa4, 0x61, 0x73, 0x40,
    0xb5, 0x3b, 0xda, 0xf7, 0x2a, 0x2f, 0xf5, 0xca, 0x18, 0xe5, 0x3a, 0xd3, 0xca, 0x44, 0xe7,
    0x3d, 0xb4, 0x73, 0xcd, 0x71, 0xc6, 0x3a, 0x54, 0x95, 0x2a, 0x05, 0xf8, 0xcc, 0x65, 0xcd,
    0x19, 0x5c, 0xa0, 0x54, 0x7f, 0x0a, 0x8d, 0x99, 0xeb, 0x79, 0xf8, 0xfc, 0x8f, 0xe8, 0xe8,
    0xf4, 0x43, 0x9c, 0xe6, 0x37, 0x67, 0xb5, 0xdb, 0x07, 0xe3, 0x3b, 0xb7, 0xc0, 0x88, 0xe7,
    0x34, 0xf8, 0x12, 0x37, 0xda, 0x1c, 0xf2, 0x3c, 0xb3, 0x09, 0xcd, 0xc5, 0xbe, 0x3a, 0x81,
    0xff, 0x38, 0x99, 0x73, 0xde, 0xc7, 0xed, 0x17, 0xc5, 0x51, 0x63, 0xf9, 0x3f, 0xd8, 0x1f,
    0x9a, 0x3c, 0x21, 0x84, 0x6b, 0xd2, 0x4c, 0xb7, 0xa0, 0x3b, 0x84, 0x78, 0xf0, 0x57, 0x38,
    0xe9, 0x74, 0xdb, 0x03, 0x42, 0xd7, 0xf7, 0xcd, 0x4a, 0x5a, 0xea, 0x43, 0x35, 0x20, 0xa5,
    0x0a, 0xdd, 0x17, 0xc2, 0xa7, 0x9b, 0xec, 0xd1, 0x39, 0x3f, 0x9f, 0xab, 0xa1, 0x9f, 0xc2,
    0x40, 0xbb, 0x52, 0xee, 0x01, 0x77, 0x19, 0xa0, 0x9a, 0x05, 0x0e, 0x61, 0xa0, 0x83, 0xae,
    0x14, 0xb1, 0x54, 0x30, 0x75, 0x2d, 0x84, 0x6b, 0xbf, 0x54, 0xa3, 0x2e, 0x58, 0x33, 0xad,
    0x9a, 0xfd, 0x69, 0x9b, 0x8f, 0xb0, 0x67, 0xae, 0xab, 0xc3, 0x84, 0xa5, 0x6d, 0xa3, 0x7f,
    0x6f, 0x2e, 0x44, 0x24, 0x2c, 0x77, 0xfa, 0x5f, 0x94, 0x4d, 0x50, 0x70, 0x64, 0x0f, 0xc0,
    0xc3, 0x67, 0x30, 0x93, 0xb3, 0xa5, 0xb5, 0xd4, 0x40, 0x57, 0x08, 0x6d, 0xfc, 0xc3, 0xb2,
    0xb0, 0x4f, 0xe5, 0x40, 0x61, 0x6e, 0xf2, 0xb6, 0x7b, 0x39, 0x4b, 0x3f, 0x41, 0xb7, 0xb3,
    0x27, 0x25, 0xf0, 0x26, 0x8b, 0xed, 0xee, 0x23, 0xf5, 0xd7, 0xbb, 0x32, 0xb7, 0x16, 0xe3,
    0xfa, 0x46, 0x74, 0x7d, 0x47, 0x11, 0x58, 0x76, 0xb1, 0xf7, 0xb7, 0x42, 0x99, 0xf3, 0xcf,
    0xaa, 0x46, 0x68, 0xf0, 0x82, 0x5b, 0xba, 0x3c, 0xba, 0x7f, 0x6b, 0xbb, 0x2e, 0x0b, 0x2b,
    0xae, 0xfb, 0x68, 0xe3, 0xbd, 0xd3, 0x20, 0xc3, 0x53, 0x59,
};

/* Public exponent of RSA3072 requester key. */
uint8_t m_libspdm_rsa3072_req_e[] = { 0x01, 0x00, 0x01 };

/* Private exponent of RSA3072 requester key. */
uint8_t m_libspdm_rsa3072_req_d[] = {
    0x1c, 0x4a, 0xa2, 0x99, 0x5d, 0x67, 0x0d, 0x76, 0x22, 0xdd, 0xff, 0x54, 0x49, 0x98, 0x9b,
    0xe6, 0xb6, 0x15, 0xf3, 0xaf, 0x5e, 0x46, 0x25, 0x60, 0x2d, 0xc9, 0xf3, 0x38, 0xb7, 0x91,
    0xd0, 0xa0, 0x96, 0x3b, 0xfb, 0x92, 0x5a, 0x2b, 0x82, 0x1d, 0xac, 0xfa, 0x9e, 0xf6, 0x34,
    0x53, 0x33, 0x5b, 0xa3, 0x5d, 0x38, 0xa4, 0x72, 0xab, 0x61, 0x5e, 0xf9, 0xbb, 0x0a, 0x42,
    0xe5, 0x34, 0x93, 0xbe, 0x01, 0x50, 0xc1, 0x9e, 0xce, 0x28, 0x54, 0x9a, 0x33, 0x1e, 0xec,
    0x16, 0x17, 0xe3, 0x47, 0xf7, 0xf2, 0x83, 0x1f, 0xaa, 0xe5, 0x35, 0x59, 0x3e, 0x51, 0x7e,
    0x48, 0x02, 0x29, 0x93, 0xf2, 0x15, 0x70, 0x65, 0xfa, 0xf2, 0x28, 0x2d, 0xcb, 0xcc, 0x7e,
    0xbb, 0x8b, 0x13, 0x4f, 0x02, 0xc1, 0x02, 0xa5, 0x3e, 0x70, 0x08, 0x79, 0x3f, 0x9d, 0xb1,
    0xee, 0xe5, 0x94, 0x0e, 0x4c, 0x0c, 0x9b, 0xfe, 0x93, 0x6d, 0xeb, 0x49, 0x9f, 0x0e, 0x0d,
    0x18, 0xdd, 0x21, 0x97, 0x1e, 0xdd, 0x1b, 0xd5, 0xbf, 0x7c, 0xa6, 0x70, 0xa6, 0x9f, 0x8d,
    0x14, 0x12, 0x0f, 0xec, 0xb4, 0xd1, 0xc6, 0x53, 0x4b, 0x6c, 0x35, 0xb7, 0x4f, 0xef, 0xe8,
    0x74, 0x24, 0x66, 0x47, 0x83, 0xa3, 0x13, 0x2d, 0x62, 0x55, 0x68, 0xad, 0x0a, 0xb1, 0x06,
    0x18, 0x89, 0x30, 0x76, 0x0f, 0xe8, 0x7e, 0x48, 0x69, 0xbc, 0x69, 0xe6, 0x31, 0x49, 0x5e,
    0xd7, 0xa9, 0x20, 0x15, 0x0b, 0x2a, 0x00, 0x9a, 0xd6, 0xac, 0x02, 0xcf, 0x98, 0xbd, 0x4c,
    0x5b, 0x06, 0x29, 0x6b, 0x31, 0xbd, 0xe0, 0xe0, 0xff, 0xf4, 0x76, 0xa0, 0x1e, 0xf6, 0x8b,
    0xfc, 0xe8, 0x11, 0xb5, 0xfb, 0xe1, 0x34, 0x54, 0xaf, 0xb0, 0xf5, 0x4f, 0x64, 0xdf, 0xa9,
    0x53, 0xbb, 0x80, 0x72, 0xe7, 0xb0, 0x19, 0xa3, 0x10, 0x43, 0x18, 0xca, 0x80, 0xf7, 0xa2,
    0x0b, 0xe8, 0x5e, 0x19, 0x44, 0x28, 0x22, 0xe6, 0x14, 0xbb, 0x71, 0x2c, 0x65, 0x91, 0xe6,
    0x51, 0x83, 0x9c, 0xb7, 0xba, 0xd8, 0x2a, 0x33, 0x46, 0x7e, 0xf4, 0x07, 0xa6, 0xf4, 0xc6,
    0x9f, 0xe7, 0x45, 0x9f, 0x75, 0x16, 0x74, 0x45, 0x44, 0x31, 0xfa, 0xbd, 0x6b, 0xaf, 0xf5,
    0x70, 0x79, 0x0e, 0x99, 0x3f, 0x42, 0xb7, 0xe9, 0x74, 0x19, 0xca, 0x07, 0xd3, 0x34, 0xfd,
    0xcb, 0x77, 0x3a, 0x5c, 0x8a, 0xe5, 0x3a, 0xe1, 0xd9, 0x71, 0x40, 0x3e, 0x90, 0xaa, 0xf6,
    0xd1, 0xf2, 0xb6, 0xf4, 0xb6, 0x57, 0x1a, 0xb3, 0xa6, 0x4d, 0x40, 0x25, 0x28, 0xdc, 0x1f,
    0x1b, 0xb2, 0xde, 0x12, 0x18, 0xdf, 0x3b, 0xd1, 0x98, 0xf9, 0xcc, 0x56, 0xce, 0x3d, 0x2e,
    0xe0, 0xfd, 0x8c, 0xc3, 0xdd, 0xb6, 0x73, 0x72, 0x95, 0xd5, 0x72, 0x15, 0x40, 0xbc, 0x68,
    0xf7, 0x52, 0x6b, 0x4d, 0xe6, 0x5a, 0xc0, 0xa7, 0x01,
};

/* Public modulus of RSA4096 responder key. */
uint8_t m_libspdm_rsa4096_res_n[] = {
    0x00, 0xd4, 0xbd, 0x10, 0x0a, 0x22, 0x23, 0x44, 0x4e, 0x6c, 0x2d, 0xca, 0x23, 0xaf, 0x94,
    0x85, 0x93, 0xba, 0xbf, 0xce, 0x56, 0xb5, 0xcd, 0x34, 0x1f, 0xc0, 0x7c, 0xb1, 0x42, 0x4b,
    0x3b, 0x4c, 0xed, 0x30, 0x43, 0xea, 0x01, 0x10, 0xac, 0xfa, 0x5e, 0xfb, 0x0f, 0xf5, 0xa9,
    0x50, 0xde, 0xa3, 0x13, 0x2b, 0xac, 0x39, 0x74, 0xc0, 0x6c, 0x8b, 0x2e, 0x52, 0xe1, 0x9b,
    0xf7, 0xe4, 0xd5, 0xe6, 0x1d, 0x9d, 0xbf, 0xfd, 0x5f, 0xea, 0x68, 0x05, 0x62, 0xbb, 0x81,
    0x52, 0x23, 0x79, 0xf5, 0x5b, 0x43, 0xfc, 0xfa, 0x1c, 0xf0, 0x9b, 0xf0, 0x1a, 0xe4, 0x95,
    0xd7, 0xaf, 0xa3, 0xe7, 0xe6, 0x64, 0x31, 0xdd, 0xc9, 0x2c, 0xd7, 0x19, 0xaa, 0xd9, 0x75,
    0xc9, 0x69, 0xce, 0x15, 0xb4, 0x8f, 0x3b, 0xcd, 0xb1, 0xf9, 0x38, 0x5c, 0x07, 0x72, 0x0f,
    0x38, 0xb0, 0x44, 0xab, 0xa5, 0x0b, 0x12, 0xb2, 0x7a, 0x19, 0xaf, 0xbc, 0x1f, 0xaa, 0xe0,
    0xb6, 0x22, 0x2b, 0x1c, 0xcf, 0x48, 0xac, 0xf5, 0x43, 0xb8, 0xfa, 0x21, 0xf4, 0x15, 0x31,
    0x2a, 0xdb, 0x23, 0x3d, 0xfe, 0x87, 0x36, 0x43, 0xa3, 0xc1, 0x87, 0xdb, 0x3f, 0xde, 0x0e,
    0x16, 0xef, 0xc4, 0x96, 0xf2, 0xe6, 0xdc, 0x62, 0xb1, 0x7d, 0xeb, 0x8e, 0xbd, 0x25, 0x63,
    0x8e, 0xba, 0x7d, 0xc8, 0xda, 0x31, 0xe3, 0xea, 0x57, 0x52, 0x28, 0xae, 0x37, 0x38, 0x41,
    0xcb, 0x5e, 0x2d, 0x3c, 0xcc, 0x8d, 0xfc, 0xc4, 0x5e, 0xe3, 0xd0, 0x8d, 0x2e, 0xed, 0x6e,
    0xfe, 0x9e, 0xb9, 0xf3, 0x27, 0xde, 0x07, 0x78, 0xec, 0x00, 0xfd, 0xe4, 0x70, 0x09, 0xb2,
    0xa1, 0xc5, 0xea, 0x48, 0xe0, 0xba, 0x4e, 0x7f, 0x75, 0xe4, 0xdf, 0x6f, 0xa2, 0x26, 0xb3,
    0x66, 0x9c, 0x31, 0xd6, 0xb3, 0xe2, 0xf1, 0x83, 0x90, 0x37, 0x60, 0xde, 0xe5, 0x45, 0x10,
    0x94, 0xa4, 0xd2, 0x68, 0xaf, 0x7b, 0x0f, 0x54, 0x17, 0x76, 0x31, 0x11, 0x94, 0x45, 0x63,
    0x98, 0x6f, 0xf8, 0x5b, 0xb7, 0x04, 0x40, 0x0d, 0xdb, 0x51, 0xd7, 0xf0, 0x3c, 0x4a, 0x63,
    0x88, 0xdf, 0xaf, 0x58, 0xca, 0x3b, 0x4e, 0x1a, 0x5c, 0xcb, 0xcf, 0x6d, 0xa0, 0x05, 0x21,
    0xa6, 0x50, 0x40, 0xfb, 0xd5, 0xe2, 0xa6, 0x3a, 0xfc, 0xf7, 0x62, 0x42, 0x86, 0x9c, 0x31,
    0x64, 0xe1, 0x7d, 0xdf, 0x1f, 0xf4, 0xbe, 0x01, 0x3e, 0x54, 0xe0, 0x4b, 0xe2, 0x81, 0x9f,
    0xd2, 0xb8, 0x3a, 0x67, 0x5f, 0xce, 0x87, 0xd2, 0x01, 0xa5, 0x25, 0x1f, 0xcb, 0xd2, 0x8c,
    0xc6, 0xbb, 0xbd, 0xcb, 0xe2, 0x20, 0x62, 0x0f, 0xc5, 0xc1, 0xf4, 0x0a, 0x90, 0xcd, 0x27,
    0xc3, 0x50, 0x71, 0xa2, 0x7e, 0xda, 0x7d, 0x34, 0xdb, 0xff, 0x83, 0x8b, 0xca, 0x14, 0x25,
    0xc8, 0x01, 0xe1, 0x0f, 0x02, 0x9f, 0x58, 0x5b, 0xd5, 0x02, 0xc4, 0xd1, 0xeb, 0xe7, 0x08,
    0x8e, 0x5d, 0x67, 0xa1, 0xbb, 0xe8, 0x2d, 0x5a, 0xfd, 0xc3, 0xb1, 0x34, 0x96, 0x66, 0x3d,
    0x62, 0xbc, 0x51, 0xdc, 0x9e, 0x93, 0x71, 0x89, 0x4d, 0xc1, 0xeb, 0xd4, 0x72, 0xc6, 0x64,
    0x42, 0x36, 0xd8, 0xae, 0xf2, 0x77, 0xdf, 0x45, 0x11, 0x3a, 0xc7, 0x4b, 0x69, 0x24, 0xc2,
    0x0a, 0x97, 0x34, 0xcb, 0x1d, 0x70, 0x63, 0xa8, 0x58, 0xf9, 0x72, 0x50, 0xd1, 0xd4, 0x58,
    0xf5, 0x55, 0xc4, 0x76, 0x10, 0xc9, 0x63, 0xe5, 0x37, 0x29, 0xea, 0xcb, 0xef, 0xa5, 0x81,
    0xdd, 0x78, 0x95, 0x07, 0xd4, 0xab, 0xd8, 0x49, 0x1a, 0x68, 0x88, 0x73, 0x7d, 0x10, 0x62,
    0x6c, 0xee, 0x60, 0xd5, 0x45, 0x75, 0xd9, 0x51, 0xde, 0xf6, 0xd5, 0xa5, 0x4e, 0x34, 0x68,
    0x13, 0xf0, 0xdf, 0xff, 0x52, 0x41, 0x61, 0x22, 0x53, 0xba, 0xae, 0xcf, 0x3f, 0xcf, 0x93,
    0x57, 0xe8, 0x87,
};

/* Public exponent of RSA4096 responder key. */
uint8_t m_libspdm_rsa4096_res_e[] = { 0x01, 0x00, 0x01 };

/* Private exponent of RSA4096 responder key. */
uint8_t m_libspdm_rsa4096_res_d[] = {
    0x0b, 0x14, 0x31, 0x82, 0xa5, 0x96, 0x7a, 0x97, 0x2e, 0xf1, 0x0f, 0x86, 0xde, 0x3c, 0xf8,
    0xdb, 0xe1, 0xac, 0xdd, 0x7d, 0x0c, 0x88, 0xbc, 0x3f, 0x2f, 0x12, 0x0f, 0x55, 0x29, 0x7f,
    0xd4, 0x18, 0xc2, 0x1b, 0xb7, 0x53, 0x08, 0xe0, 0x49, 0x45, 0xab, 0x03, 0x80, 0xc2, 0xa9,
    0x90, 0x7e, 0xa3, 0x9f, 0xf1, 0x9f, 0x28, 0x62, 0x61, 0x04, 0xba, 0x8b, 0xdc, 0x6d, 0xf7,
    0xf1, 0xf5, 0xe5, 0xbf, 0x03, 0x19, 0x1d, 0x83, 0xe2, 0x3c, 0x3a, 0x93, 0x92, 0xba, 0x40,
    0x61, 0xd2, 0x97, 0x21, 0x82, 0x9f, 0xe9, 0x12, 0x9a, 0xc1, 0x34, 0x36, 0xe2, 0x52, 0x9f,
    0x61, 0xe9, 0x42, 0x49, 0x70, 0x4c, 0x5c, 0x85, 0x7e, 0x8d, 0x51, 0x2b, 0xe1, 0x99, 0x4d,
    0xbc, 0xf1, 0xdb, 0x95, 0x84, 0xa4, 0x13, 0xa9, 0x42, 0x16, 0x5a, 0x4c, 0x94, 0xf7, 0x0f,
    0xf7, 0xb6, 0x0b, 0xce, 0x53, 0x8e, 0x4c, 0xb7, 0x29, 0x21, 0x4a, 0xc5, 0xc7, 0x6b, 0x5e,
    0x70, 0xd7, 0x17, 0xef, 0xff, 0x93, 0xea, 0x4d, 0xf5, 0x93, 0x29, 0x33, 0x81, 0xeb, 0x06,
    0x95, 0x54, 0xf7, 0x84, 0x8a, 0xdc, 0x1b, 0x97, 0xaa, 0x9b, 0x7d, 0xa2, 0x8c, 0xd8, 0xe4,
    0xfe, 0xe5, 0x99, 0x0a, 0xdb, 0x54, 0xfc, 0xda, 0xcb, 0x78, 0xf9, 0xfd, 0x05, 0xb6, 0x72,
    0x97, 0x69, 0xb7, 0x8d, 0x0d, 0x6e, 0x16, 0x25, 0x28, 0x05, 0x30, 0x55, 0x75, 0xdb, 0x8f,
    0x50, 0xbf, 0x40, 0x5c, 0x52, 0xc4, 0xa8, 0x21, 0x5c, 0xf1, 0xde, 0x78, 0x64, 0x2b, 0x14,
    0x9d, 0x85, 0x87, 0x91, 0x3a, 0xf1, 0xde, 0xad, 0x43, 0xbb, 0xf5, 0x2a, 0x94, 0x86, 0xb6,
    0x00, 0x0d, 0x9c, 0x6f, 0xff, 0xa3, 0xd8, 0xe5, 0x75, 0xde, 0xe0, 0xfc, 0x6b, 0xd1, 0x89,
    0xf5, 0x76, 0x6e, 0xfc, 0xfd, 0x43, 0xa0, 0x9b, 0x61, 0x16, 0xed, 0x64, 0xb9, 0x3d, 0x0c,
    0xd0, 0x94, 0x31, 0x57, 0x4f, 0x06, 0x07, 0x04, 0x68, 0x3b, 0x41, 0x91, 0x22, 0x25, 0x3b,
    0x9e, 0xa7, 0x13, 0x6d, 0x79, 0x4e, 0x36, 0x96, 0xfe, 0xcf, 0x3c, 0x34, 0x0f, 0x7d, 0x47,
    0x26, 0x58, 0xfb, 0x14, 0x3b, 0x84, 0x7b, 0x92, 0xc4, 0xf6, 0x67, 0xc7, 0xd0, 0x4d, 0xa2,
    0xc3, 0x62, 0x47, 0xf1, 0xa5, 0x81, 0xd8, 0xfb, 0x38, 0x60, 0xe2, 0x5e, 0xd0, 0x09, 0x2b,
    0xba, 0x10, 0xbe, 0xdc, 0x91, 0xb8, 0xea, 0x88, 0xe0, 0xb0, 0x8e, 0x9f, 0x85, 0x16, 0xaf,
    0xa9, 0xb9, 0x18, 0x01, 0x79, 0xc2, 0xe4, 0xf5, 0xd2, 0x83, 0x79, 0x6f, 0x94, 0x47, 0x0e,
    0x2b, 0xe9, 0xdf, 0x79, 0xc6, 0x6f, 0x9c, 0xed, 0x59, 0x94, 0x82, 0x0c, 0x46, 0x0a, 0xb6,
    0x5d, 0xcf, 0x74, 0x48, 0x47, 0xec, 0x91, 0x6b, 0xca, 0xc1, 0x58, 0xab, 0xfe, 0x5a, 0x78,
    0x37, 0x8b, 0xc1, 0x2a, 0x09, 0xbb, 0xe0, 0xc6, 0xaa, 0xd6, 0x63, 0x88, 0x3e, 0xd8, 0x12,
    0x68, 0x3c, 0x2f, 0xb9, 0xf1, 0x54, 0x89, 0x6f, 0x5e, 0x5d, 0xe6, 0x04, 0xba, 0xb8, 0x23,
    0x44, 0x80, 0xbe, 0xc2, 0x4a, 0x10, 0xef, 0xbf, 0x0e, 0x62, 0xf1, 0x3a, 0xdd, 0x55, 0x84,
    0x8f, 0x4e, 0x29, 0xdf, 0x7b, 0xcc, 0x8e, 0xd6, 0x9d, 0x45, 0x71, 0x67, 0x96, 0x38, 0x6d,
    0xfe, 0xe0, 0xb6, 0x1b, 0x2c, 0xa2, 0x83, 0x70, 0x19, 0x5b, 0xe5, 0xc4, 0x09, 0x1a, 0xbc,
    0x94, 0xdd, 0xa6, 0x5f, 0x37, 0xad, 0x30, 0x31, 0xc9, 0x0a, 0x16, 0xd4, 0x2d, 0x29, 0xab,
    0x21, 0x71, 0xec, 0x42, 0x2c, 0x70, 0xb4, 0x2b, 0xd1, 0x92, 0x4a, 0xc1, 0xc3, 0xec, 0xfd,
    0xb9, 0x31, 0xd2, 0x05, 0xad, 0xe4, 0x73, 0x00, 0x03, 0x38, 0x29, 0xd4, 0xd2, 0x1d, 0x6a,
    0xef, 0xda, 0xd4, 0x70, 0xe4, 0x34, 0x98, 0xa3, 0x53, 0xfb, 0x10, 0xd0, 0x5c, 0x67, 0x50,
    0xb4, 0xb1,
};

/* Public modulus of RSA4096 requester key. */
uint8_t m_libspdm_rsa4096_req_n[] = {
    0x00, 0xe8, 0x9b, 0x35, 0xb9, 0x56, 0x37, 0x09, 0xe8, 0x97, 0x74, 0x33, 0x4e, 0xa9, 0x88,
    0x47, 0x51, 0x4f, 0x0a, 0x85, 0x2d, 0xee, 0x16, 0x87, 0x98, 0x4c, 0x16, 0x31, 0x88, 0xf3,
    0xb2, 0xb2, 0xad, 0x95, 0x95, 0x76, 0xef, 0x6c, 0x85, 0xde, 0x94, 0x9c, 0x4f, 0x27, 0x02,
    0x5d, 0x14, 0x26, 0x36, 0x4b, 0x30, 0x79, 0x81, 0x1d, 0x2c, 0xbe, 0xa4, 0xf4, 0xd2, 0x50,
    0xdf, 0x0e, 0xe6, 0x00, 0x7b, 0x49, 0x17, 0xa2, 0x2b, 0xe3, 0x95, 0xe4, 0xa5, 0xfc, 0x99,
    0x2f, 0xb2, 0xcc, 0xf8, 0x6d, 0x6d, 0x44, 0x68, 0xfc, 0xf3, 0x99, 0xc8, 0x14, 0x94, 0x35,
    0xf6, 0xa2, 0x36, 0xad, 0x88, 0xdb, 0x9c, 0x82, 0xd1, 0x49, 0x45, 0xf5, 0x11, 0xc1, 0x18,
    0x41, 0xae, 0x11, 0x5b, 0x0e, 0xd0, 0x81, 0x4b, 0xf1, 0x7e, 0xa8, 0x32, 0x16, 0xcb, 0x74,
    0x52, 0xeb, 0x34, 0x99, 0x0e, 0xbb, 0xf4, 0x93, 0xa9, 0x65, 0x20, 0x04, 0x17, 0xbf, 0xfb,
    0x92, 0x41, 0x44, 0x35, 0xaa, 0xae, 0xbf, 0xc0, 0x66, 0x0d, 0xf5, 0x59, 0xe2, 0xcf, 0x94,
    0x3a, 0xb0, 0x8d, 0x6c, 0xe4, 0x4c, 0xeb, 0x64, 0xf8, 0xee, 0xe5, 0x90, 0xc1, 0x9b, 0x94,
    0xc7, 0x84, 0x5c, 0xf3, 0x83, 0xaf, 0xd7, 0xbf, 0x27, 0xe7, 0x26, 0x00, 0xc1, 0x9e, 0x19,
    0x2b, 0x76, 0x0e, 0xd9, 0x09, 0xa7, 0xde, 0xe8, 0x7d, 0xb6, 0x9c, 0x8a, 0x72, 0x0c, 0xb9,
    0xa2, 0x22, 0x55, 0x71, 0xc3, 0xaf, 0xd6, 0xc3, 0x7d, 0xc4, 0x67, 0x13, 0x85, 0xe3, 0x93,
    0x4d, 0xfd, 0x81, 0xaa, 0x06, 0xd1, 0x6b, 0xa6, 0x26, 0xd4, 0x56, 0x9a, 0xa7, 0xd6, 0x5b,
    0x5b, 0x47, 0x82, 0x3a, 0x10, 0xb1, 0xd2, 0x4b, 0xbd, 0xaf, 0xba, 0x7b, 0x4f, 0x86, 0x78,
    0xe4, 0x1c, 0xbe, 0xd9, 0xd5, 0x72, 0xc3, 0x97, 0x3c, 0x9c, 0x14, 0x87, 0x6e, 0x62, 0x73,
    0xcc, 0xf5, 0xe1, 0xb9, 0xa2, 0x26, 0x19, 0xcb, 0x73, 0xd9, 0xe4, 0xfd, 0x7b, 0xab, 0xeb,
    0x40, 0x84, 0xa1, 0x37, 0xf8, 0x12, 0x4d, 0x1b, 0xad, 0x03, 0xf9, 0xca, 0x6f, 0x31, 0x5a,
    0xc6, 0x13, 0x57, 0x39, 0xdd, 0xc2, 0x60, 0xad, 0x95, 0x85, 0x32, 0xc3, 0xaf, 0xfc, 0xe2,
    0x73, 0xf3, 0x1c, 0x07, 0xc8, 0xc0, 0xc1, 0xfa, 0xb3, 0x3f, 0x5f, 0x13, 0x08, 0x91, 0x4c,
    0xbb, 0x62, 0x8b, 0x0d, 0x28, 0xda, 0x66, 0x79, 0xd2, 0x3f, 0x7c, 0x16, 0x40, 0xfb, 0x77,
    0x0d, 0x4e, 0x53, 0x34, 0xed, 0xcf, 0x7b, 0xe5, 0x3b, 0x67, 0x4f, 0x33, 0x9c, 0xfd, 0x64,
    0x4b, 0x83, 0xdb, 0x4f, 0x68, 0xd6, 0x3a, 0xb2, 0x37, 0xec, 0x0a, 0x9f, 0xb5, 0x3e, 0x68,
    0xdb, 0x19, 0xb4, 0x3e, 0xca, 0xbf, 0x69, 0x09, 0x4b, 0xfa, 0x51, 0x1c, 0xf8, 0x54, 0xa6,
    0x3e, 0xdc, 0x54, 0xde, 0x63, 0x8c, 0xfc, 0x8c, 0x9d, 0x67, 0xcf, 0x66, 0xdf, 0xa3, 0xfb,
    0x01, 0x8b, 0x88, 0xda, 0x54, 0xdb, 0xc4, 0x95, 0xf9, 0x13, 0xcb, 0x7c, 0xa0, 0xef, 0x5b,
    0xf2, 0x7f, 0xdc, 0xdb, 0x43, 0xe2, 0x13, 0xae, 0xf2, 0xef, 0xfd, 0x20, 0x78, 0x4d, 0x5f,
    0xe0, 0xa2, 0x3c, 0xff, 0xfc, 0x6a, 0xd3, 0x9b, 0x7c, 0x16, 0xc9, 0x96, 0x22, 0x96, 0x0b,
    0x0b, 0x15, 0x97, 0x5c, 0x31, 0x31, 0x5d, 0xf5, 0x18, 0x99, 0x02, 0x51, 0x35, 0x37, 0xcb,
    0xbf, 0x54, 0xec, 0xe4, 0x57, 0x90, 0x78, 0xb6, 0x86, 0xeb, 0x67, 0x4a, 0x40, 0xa8, 0x68,
    0x4a, 0xb1, 0xa0, 0x45, 0x38, 0xcd, 0xad, 0xfb, 0x09, 0x50, 0x8f, 0xf1, 0xa3, 0xce, 0x8c,
    0x9b, 0xfd, 0xdf, 0x6c, 0x57, 0xb3, 0x1d, 0xf8, 0xd8, 0x0a, 0x4c, 0x38, 0x48, 0xc6, 0x3a,
    0x44, 0x70, 0x11, 0x82, 0x95, 0xfc, 0x8a, 0x06, 0x28, 0x92, 0xec, 0x8b, 0x9c, 0x72, 0xf0,
    0xe0, 0x18, 0x19,
};

/* Public exponent of RSA4096 requester key. */
uint8_t m_libspdm_rsa4096_req_e[] = { 0x01, 0x00, 0x01 };

/* Private exponent of RSA4096 requester key. */
uint8_t m_libspdm_rsa4096_req_d[] = {
    0x69, 0x57, 0x61, 0x4d, 0x3e, 0x2e, 0x4e, 0xde, 0x77, 0x38, 0xb8, 0xc3, 0xb7, 0x23, 0x70,
    0xa8, 0xf2, 0x12, 0xe1, 0x9d, 0x9b, 0x65, 0xb8, 0xa2, 0xd0, 0x52, 0x7c, 0xbc, 0x79, 0x21,
    0x44, 0xaa, 0x38, 0x44, 0x28, 0x48, 0xe5, 0xec, 0xfa, 0x90, 0x72, 0xf9, 0xa5, 0xc0, 0xfc,
    0x46, 0x53, 0xc7, 0xe2, 0xe5, 0x61, 0x21, 0x88, 0x04, 0xeb, 0x91, 0xe9, 0x0e, 0x16, 0x71,
    0xee, 0x5d, 0x5b, 0x7a, 0x79, 0xef, 0xaa, 0x12, 0x16, 0x4f, 0x9b, 0xed, 0x50, 0x28, 0x4f,
    0xe1, 0xb9, 0xd2, 0x08, 0x3c, 0xa3, 0xee, 0xa8, 0x1f, 0xea, 0x55, 0x22, 0x7c, 0xbc, 0xb3,
    0xa5, 0x62, 0xfd, 0xd4, 0x2d, 0x21, 0x04, 0x5d, 0xa3, 0xc1, 0x7a, 0xeb, 0x3f, 0x77, 0xac,
    0xc7, 0x18, 0x35, 0x14, 0xd0, 0x78, 0xbd, 0xdb, 0xf0, 0x70, 0x5b, 0xbe, 0xd7, 0x05, 0x27,
    0x48, 0x3d, 0xd9, 0xd3, 0x42, 0x6b, 0xd1, 0x33, 0xb6, 0x08, 0x79, 0xd2, 0x07, 0xaf, 0xf6,
    0xdc, 0x77, 0xf7, 0x96, 0x04, 0xed, 0xf2, 0x44, 0x45, 0xae, 0x07, 0xb7, 0x20, 0x2b, 0x11,
    0x29, 0x43, 0xe3, 0x3c, 0xc1, 0x59, 0x19, 0xb1, 0x62, 0xff, 0xb4, 0x3e, 0xfa, 0x26, 0xb6,
    0xf4, 0xca, 0xe3, 0xbd, 0x8f, 0xb5, 0x35, 0x6c, 0xec, 0xd1, 0xd9, 0x25, 0xd6, 0x63, 0xaf,
    0xbb, 0x17, 0x9e, 0x53, 0x31, 0x23, 0x52, 0x47, 0x1c, 0x9c, 0x68, 0x56, 0x9e, 0x4c, 0xb3,
    0x90, 0xb9, 0x01, 0x7c, 0x8d, 0xf5, 0xc5, 0x32, 0xff, 0xef, 0x6e, 0x78, 0x04, 0x48, 0x81,
    0xd9, 0x7d, 0x0f, 0x73, 0x67, 0x04, 0x49, 0x8a, 0xec, 0x3f, 0x0c, 0x6b, 0x56, 0x38, 0xa9,
    0x6e, 0x09, 0x1c, 0x22, 0xd3, 0x65, 0x59, 0xc7, 0xdd, 0xfd, 0xa6, 0x3a, 0xad, 0xbb, 0xb2,
    0x13, 0x12, 0x9b, 0xb4, 0x7e, 0xf4, 0xf5, 0x59, 0x0d, 0x96, 0x7e, 0x7f, 0x0f, 0x37, 0x42,
    0x6a, 0x7b, 0x73, 0x41, 0xb6, 0x08, 0xbe, 0x24, 0x54, 0x02, 0xac, 0x18, 0x15, 0xd3, 0x96,
    0x98, 0xd3, 0x1e, 0x64, 0x3c, 0xd0, 0xbc, 0x4e, 0xfd, 0xea, 0xe9, 0xb4, 0x14, 0xc3, 0x58,
    0x11, 0x6f, 0xd6, 0x35, 0xfe, 0x58, 0x06, 0x11, 0xc9, 0xfe, 0x9e, 0xd5, 0x43, 0x0e, 0x08,
    0xb9, 0x7b, 0xc7, 0x40, 0x55, 0x44, 0xfe, 0x3c, 0x05, 0x58, 0x94, 0x66, 0xe1, 0x1a, 0x7b,
    0x16, 0x67, 0x95, 0x48, 0x4b, 0x5c, 0xbc, 0xa8, 0xcc, 0xd8, 0x9f, 0xb5, 0xac, 0xd2, 0x71,
    0x70, 0x8a, 0x3b, 0x3c, 0x5f, 0x38, 0x4b, 0x4d, 0x9b, 0x83, 0x3f, 0x41, 0x95, 0x95, 0x92,
    0xf2, 0x4f, 0x03, 0xd3, 0xba, 0xc6, 0xa4, 0xe9, 0xcf, 0x52, 0xf0, 0xee, 0xfd, 0xe5, 0xf5,
    0x94, 0x93, 0x78, 0xa9, 0xe5, 0x81, 0x91, 0xe3, 0xda, 0x88, 0x1b, 0x8e, 0x73, 0xfe, 0x4a,
    0x0c, 0xd5, 0x5e, 0xef, 0xcf, 0x65, 0x72, 0xd2, 0x73, 0x51, 0x0d, 0x37, 0x1c, 0x14, 0xf0,
    0x1d, 0x6d, 0x25, 0xe9, 0x50, 0x47, 0xcc, 0xa7, 0xb2, 0x60, 0x89, 0x7c, 0xef, 0xd2, 0xb9,
    0x5e, 0x34, 0xb8, 0x36, 0x63, 0xcd, 0xaf, 0xdf, 0x55, 0x0f, 0xd4, 0xfa, 0x34, 0x66, 0x60,
    0xe8, 0x58, 0x0b, 0xa5, 0x4d, 0x00, 0xf0, 0xd4, 0x45, 0x8e, 0x49, 0xb3, 0x16, 0x56, 0x49,
    0xd3, 0x26, 0x39, 0x65, 0x26, 0x76, 0xfc, 0x1f, 0xdb, 0x77, 0x29, 0x6f, 0xfe, 0x84, 0x71,
    0x68, 0x49, 0xa1, 0x9e, 0x74, 0x69, 0x4e, 0x42, 0x24, 0x11, 0x47, 0x3c, 0x96, 0x2b, 0xc6,
    0x0b, 0xf5, 0x1c, 0x5f, 0xfe, 0xc6, 0x7e, 0xab, 0xd6, 0x19, 0x60, 0x6b, 0x99, 0x9e, 0x66,
    0x5f, 0xbc, 0xf6, 0xb5, 0xb5, 0x41, 0x01, 0x91, 0x6a, 0xc4, 0x3e, 0x03, 0x5a, 0x67, 0x6d,
    0xf6, 0x34, 0x8a, 0xff, 0x87, 0xa9, 0x9e, 0x84, 0x6e, 0x2b, 0x45, 0xb0, 0x88, 0x96, 0xb5,
    0x08, 0x01,
};
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */

bool libspdm_get_responder_private_key_from_raw_data(uint32_t base_asym_algo, void **context)
{
    bool result;

#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
    void *rsa_context;
    uint8_t *rsa_n;
    uint8_t *rsa_e;
    uint8_t *rsa_d;
    size_t rsa_n_size;
    size_t rsa_e_size;
    size_t rsa_d_size;
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */

#if LIBSPDM_ECDSA_SUPPORT
    void *ec_context;
    size_t ec_nid;
    uint8_t *ec_public;
    uint8_t *ec_private;
    size_t ec_public_size;
    size_t ec_private_size;
#endif /*LIBSPDM_ECDSA_SUPPORT*/

    switch (base_asym_algo) {
#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        rsa_n = m_libspdm_rsa2048_res_n;
        rsa_e = m_libspdm_rsa2048_res_e;
        rsa_d = m_libspdm_rsa2048_res_d;
        rsa_n_size = sizeof(m_libspdm_rsa2048_res_n);
        rsa_e_size = sizeof(m_libspdm_rsa2048_res_e);
        rsa_d_size = sizeof(m_libspdm_rsa2048_res_d);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        rsa_n = m_libspdm_rsa3072_res_n;
        rsa_e = m_libspdm_rsa3072_res_e;
        rsa_d = m_libspdm_rsa3072_res_d;
        rsa_n_size = sizeof(m_libspdm_rsa3072_res_n);
        rsa_e_size = sizeof(m_libspdm_rsa3072_res_e);
        rsa_d_size = sizeof(m_libspdm_rsa3072_res_d);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        rsa_n = m_libspdm_rsa4096_res_n;
        rsa_e = m_libspdm_rsa4096_res_e;
        rsa_d = m_libspdm_rsa4096_res_d;
        rsa_n_size = sizeof(m_libspdm_rsa4096_res_n);
        rsa_e_size = sizeof(m_libspdm_rsa4096_res_e);
        rsa_d_size = sizeof(m_libspdm_rsa4096_res_d);
        break;
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */

#if LIBSPDM_ECDSA_SUPPORT
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        ec_nid = LIBSPDM_CRYPTO_NID_ECDSA_NIST_P256;
        ec_public = m_libspdm_ec256_responder_public_key;
        ec_private = m_libspdm_ec256_responder_private_key;
        ec_public_size = sizeof(m_libspdm_ec256_responder_public_key);
        ec_private_size = sizeof(m_libspdm_ec256_responder_private_key);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        ec_nid = LIBSPDM_CRYPTO_NID_ECDSA_NIST_P384;
        ec_public = m_libspdm_ec384_responder_public_key;
        ec_private = m_libspdm_ec384_responder_private_key;
        ec_public_size = sizeof(m_libspdm_ec384_responder_public_key);
        ec_private_size = sizeof(m_libspdm_ec384_responder_private_key);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        ec_nid = LIBSPDM_CRYPTO_NID_ECDSA_NIST_P521;
        ec_public = m_libspdm_ec521_responder_public_key;
        ec_private = m_libspdm_ec521_responder_private_key;
        ec_public_size = sizeof(m_libspdm_ec521_responder_public_key);
        ec_private_size = sizeof(m_libspdm_ec521_responder_private_key);
        break;
#endif /*LIBSPDM_ECDSA_SUPPORT*/
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }

    switch (base_asym_algo) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
        rsa_context = libspdm_rsa_new();
        if (rsa_context == NULL) {
            return false;
        }
        result = libspdm_rsa_set_key(rsa_context, LIBSPDM_RSA_KEY_N, rsa_n, rsa_n_size);
        if (!result) {
            libspdm_rsa_free(rsa_context);
            return false;
        }
        result = libspdm_rsa_set_key(rsa_context, LIBSPDM_RSA_KEY_E, rsa_e, rsa_e_size);
        if (!result) {
            libspdm_rsa_free(rsa_context);
            return false;
        }
        result = libspdm_rsa_set_key(rsa_context, LIBSPDM_RSA_KEY_D, rsa_d, rsa_d_size);
        if (!result) {
            libspdm_rsa_free(rsa_context);
            return false;
        }
        *context = rsa_context;
        return true;
#else
        LIBSPDM_ASSERT(false);
        return false;
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
#if LIBSPDM_ECDSA_SUPPORT
        ec_context = libspdm_ec_new_by_nid(ec_nid);
        if (ec_context == NULL) {
            return false;
        }
        result = libspdm_ec_set_pub_key(ec_context, ec_public, ec_public_size);
        if (!result) {
            libspdm_ec_free(ec_context);
            return false;
        }
        result = libspdm_ec_set_priv_key(ec_context, ec_private, ec_private_size);
        if (!result) {
            libspdm_ec_free(ec_context);
            return false;
        }
        *context = ec_context;
        return true;
#else
        LIBSPDM_ASSERT(false);
        return false;
#endif /*#LIBSPDM_ECDSA_SUPPORT*/
    }

    return false;
}

bool libspdm_get_requester_private_key_from_raw_data(uint32_t base_asym_algo, void **context)
{
    bool result;

#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
    void *rsa_context;
    uint8_t *rsa_n;
    uint8_t *rsa_e;
    uint8_t *rsa_d;
    size_t rsa_n_size;
    size_t rsa_e_size;
    size_t rsa_d_size;
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */

#if LIBSPDM_ECDSA_SUPPORT
    void *ec_context;
    size_t ec_nid;
    uint8_t *ec_public;
    uint8_t *ec_private;
    size_t ec_public_size;
    size_t ec_private_size;
#endif /*LIBSPDM_ECDSA_SUPPORT*/

    switch (base_asym_algo) {
#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        rsa_n = m_libspdm_rsa2048_req_n;
        rsa_e = m_libspdm_rsa2048_req_e;
        rsa_d = m_libspdm_rsa2048_req_d;
        rsa_n_size = sizeof(m_libspdm_rsa2048_req_n);
        rsa_e_size = sizeof(m_libspdm_rsa2048_req_e);
        rsa_d_size = sizeof(m_libspdm_rsa2048_req_d);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        rsa_n = m_libspdm_rsa3072_req_n;
        rsa_e = m_libspdm_rsa3072_req_e;
        rsa_d = m_libspdm_rsa3072_req_d;
        rsa_n_size = sizeof(m_libspdm_rsa3072_req_n);
        rsa_e_size = sizeof(m_libspdm_rsa3072_req_e);
        rsa_d_size = sizeof(m_libspdm_rsa3072_req_d);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        rsa_n = m_libspdm_rsa4096_req_n;
        rsa_e = m_libspdm_rsa4096_req_e;
        rsa_d = m_libspdm_rsa4096_req_d;
        rsa_n_size = sizeof(m_libspdm_rsa4096_req_n);
        rsa_e_size = sizeof(m_libspdm_rsa4096_req_e);
        rsa_d_size = sizeof(m_libspdm_rsa4096_req_d);
        break;
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */

#if LIBSPDM_ECDSA_SUPPORT
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        ec_nid = LIBSPDM_CRYPTO_NID_ECDSA_NIST_P256;
        ec_public = m_libspdm_ec256_requester_public_key;
        ec_private = m_libspdm_ec256_requester_private_key;
        ec_public_size = sizeof(m_libspdm_ec256_requester_public_key);
        ec_private_size = sizeof(m_libspdm_ec256_requester_private_key);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        ec_nid = LIBSPDM_CRYPTO_NID_ECDSA_NIST_P384;
        ec_public = m_libspdm_ec384_requester_public_key;
        ec_private = m_libspdm_ec384_requester_private_key;
        ec_public_size = sizeof(m_libspdm_ec384_requester_public_key);
        ec_private_size = sizeof(m_libspdm_ec384_requester_private_key);
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        ec_nid = LIBSPDM_CRYPTO_NID_ECDSA_NIST_P521;
        ec_public = m_libspdm_ec521_requester_public_key;
        ec_private = m_libspdm_ec521_requester_private_key;
        ec_public_size = sizeof(m_libspdm_ec521_requester_public_key);
        ec_private_size = sizeof(m_libspdm_ec521_requester_private_key);
        break;
#endif /*LIBSPDM_ECDSA_SUPPORT*/
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }

    switch (base_asym_algo) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
#if (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT)
        rsa_context = libspdm_rsa_new();
        if (rsa_context == NULL) {
            return false;
        }
        result = libspdm_rsa_set_key(rsa_context, LIBSPDM_RSA_KEY_N, rsa_n, rsa_n_size);
        if (!result) {
            libspdm_rsa_free(rsa_context);
            return false;
        }
        result = libspdm_rsa_set_key(rsa_context, LIBSPDM_RSA_KEY_E, rsa_e, rsa_e_size);
        if (!result) {
            libspdm_rsa_free(rsa_context);
            return false;
        }
        result = libspdm_rsa_set_key(rsa_context, LIBSPDM_RSA_KEY_D, rsa_d, rsa_d_size);
        if (!result) {
            libspdm_rsa_free(rsa_context);
            return false;
        }
        *context = rsa_context;
        return true;
#else
        LIBSPDM_ASSERT(false);
        return false;
#endif /* (LIBSPDM_RSA_SSA_SUPPORT) || (LIBSPDM_RSA_PSS_SUPPORT) */
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
#if LIBSPDM_ECDSA_SUPPORT
        ec_context = libspdm_ec_new_by_nid(ec_nid);
        if (ec_context == NULL) {
            return false;
        }
        result = libspdm_ec_set_pub_key(ec_context, ec_public, ec_public_size);
        if (!result) {
            libspdm_ec_free(ec_context);
            return false;
        }
        result = libspdm_ec_set_priv_key(ec_context, ec_private, ec_private_size);
        if (!result) {
            libspdm_ec_free(ec_context);
            return false;
        }
        *context = ec_context;
        return true;
#else
        LIBSPDM_ASSERT(false);
        return false;
#endif /*#LIBSPDM_ECDSA_SUPPORT*/
    }

    return false;
}

#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
bool libspdm_read_responder_private_key(uint32_t base_asym_algo,
                                        void **data, size_t *size)
{
    bool res;
    char *file;

    switch (base_asym_algo) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        file = "rsa2048/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        file = "rsa3072/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        file = "rsa4096/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        file = "ecp256/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        file = "ecp384/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        file = "ecp521/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256:
        file = "sm2/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519:
        file = "ed25519/end_responder.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448:
        file = "ed448/end_responder.key";
        break;
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }
    res = libspdm_read_input_file(file, data, size);
    return res;
}
#endif

#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
bool libspdm_read_requester_private_key(uint16_t req_base_asym_alg,
                                        void **data, size_t *size)
{
    bool res;
    char *file;

    switch (req_base_asym_alg) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        file = "rsa2048/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        file = "rsa3072/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        file = "rsa4096/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        file = "ecp256/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        file = "ecp384/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        file = "ecp521/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256:
        file = "sm2/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519:
        file = "ed25519/end_requester.key";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448:
        file = "ed448/end_requester.key";
        break;
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }
    res = libspdm_read_input_file(file, data, size);
    return res;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP */

bool libspdm_read_responder_public_key(uint32_t base_asym_algo,
                                       void **data, size_t *size)
{
    bool res;
    char *file;

    switch (base_asym_algo) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        file = "rsa2048/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        file = "rsa3072/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        file = "rsa4096/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        file = "ecp256/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        file = "ecp384/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        file = "ecp521/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256:
        file = "sm2/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519:
        file = "ed25519/end_responder.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448:
        file = "ed448/end_responder.key.pub.der";
        break;
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }
    res = libspdm_read_input_file(file, data, size);
    return res;
}

bool libspdm_read_requester_public_key(uint16_t req_base_asym_alg,
                                       void **data, size_t *size)
{
    bool res;
    char *file;

    switch (req_base_asym_alg) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        file = "rsa2048/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        file = "rsa3072/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        file = "rsa4096/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        file = "ecp256/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        file = "ecp384/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        file = "ecp521/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_SM2_ECC_SM2_P256:
        file = "sm2/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED25519:
        file = "ed25519/end_requester.key.pub.der";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_EDDSA_ED448:
        file = "ed448/end_requester.key.pub.der";
        break;
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }
    res = libspdm_read_input_file(file, data, size);
    return res;
}

#if LIBSPDM_ENABLE_CAPABILITY_GET_CSR_CAP
bool libspdm_read_cached_last_csr_request(uint8_t **last_csr_request, size_t *last_csr_request_len)
{
    bool res;
    char *file;

    file = "cached_last_csr_request";
    res = libspdm_read_input_file(file, (void **)last_csr_request, last_csr_request_len);
    return res;
}

bool libspdm_cache_last_csr_request(const uint8_t *last_csr_request, size_t last_csr_request_len)
{
    bool res;
    char *file;

    file = "cached_last_csr_request";
    res = libspdm_write_output_file(file, last_csr_request, last_csr_request_len);

    return res;
}

bool libspdm_read_cached_csr(uint32_t base_asym_algo, uint8_t **csr_pointer, size_t *csr_len)
{
    bool res;
    char *file;

    if (base_asym_algo == 0) {
        return false;
    }

    switch (base_asym_algo) {
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_2048:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_2048:
        file = "test_csr/rsa2048.csr";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_3072:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_3072:
        file = "test_csr/rsa3072.csr";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSASSA_4096:
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_RSAPSS_4096:
        file = "test_csr/rsa4096.csr";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P256:
        file = "test_csr/ecp256.csr";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P384:
        file = "test_csr/ecp384.csr";
        break;
    case SPDM_ALGORITHMS_BASE_ASYM_ALGO_TPM_ALG_ECDSA_ECC_NIST_P521:
        file = "test_csr/ecp521.csr";
        break;
    default:
        LIBSPDM_ASSERT(false);
        return false;
    }

    res = libspdm_read_input_file(file, (void **)csr_pointer, csr_len);
    return res;
}

bool libspdm_gen_csr(uint32_t base_hash_algo, uint32_t base_asym_algo, bool *need_reset,
                     const void *request, size_t request_size,
                     uint8_t *requester_info, size_t requester_info_length,
                     uint8_t *opaque_data, uint16_t opaque_data_length,
                     size_t *csr_len, uint8_t *csr_pointer,
                     bool is_device_cert_model)
{
    bool result;
    size_t hash_nid;
    size_t asym_nid;
    void *context;

    uint8_t *cached_last_csr_request;
    size_t cached_last_request_len;
    uint8_t *cached_csr;
    size_t csr_buffer_size;

    csr_buffer_size = *csr_len;

    /*device gen csr need reset*/
    if (*need_reset) {
        result = libspdm_read_cached_last_csr_request(&cached_last_csr_request,
                                                      &cached_last_request_len);

        /*get the cached last csr request and csr*/
        if ((result) &&
            (cached_last_request_len == request_size) &&
            (libspdm_consttime_is_mem_equal(cached_last_csr_request, request,
                                            request_size)) &&
            (libspdm_read_cached_csr(base_asym_algo, &cached_csr, csr_len))) {

            /*get and save cached csr*/
            if (csr_buffer_size < *csr_len) {
                free(cached_csr);
                free(cached_last_csr_request);
                LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,
                               "csr buffer is too small to sotre cached csr! \n"));
                return false;
            } else {
                libspdm_copy_mem(csr_pointer, csr_buffer_size, cached_csr, *csr_len);
            }

            /*device don't need reset this time*/
            *need_reset = false;

            free(cached_csr);
            free(cached_last_csr_request);
            return true;
        } else {
            if (cached_last_csr_request != NULL) {
                free(cached_last_csr_request);
            }

            /*device need reset this time: cache the last_csr_request */
            result = libspdm_cache_last_csr_request(request, request_size);
            if (!result) {
                return result;
            }

            return true;
        }
    }
#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
    if (g_private_key_mode) {
        void *prikey;
        size_t prikey_size;

        result = libspdm_read_responder_private_key(
            base_asym_algo, &prikey, &prikey_size);
        if (!result) {
            return false;
        }

        result = libspdm_asym_get_private_key_from_pem(
            base_asym_algo, prikey, prikey_size, NULL, &context);
        if (!result) {
            libspdm_zero_mem(prikey, prikey_size);
            free(prikey);
            return false;
        }
        hash_nid = libspdm_get_hash_nid(base_hash_algo);
        asym_nid = libspdm_get_aysm_nid(base_asym_algo);

        char *subject_name = "C=NL,O=PolarSSL,CN=PolarSSL Server 1";

        result = libspdm_gen_x509_csr(hash_nid, asym_nid,
                                      requester_info, requester_info_length,
                                      !is_device_cert_model,
                                      context, subject_name,
                                      csr_len, csr_pointer);
        libspdm_asym_free(base_asym_algo, context);
        libspdm_zero_mem(prikey, prikey_size);
        free(prikey);
    } else {
#endif
    result = libspdm_get_responder_private_key_from_raw_data(base_asym_algo, &context);
    if (!result) {
        return false;
    }
    hash_nid = libspdm_get_hash_nid(base_hash_algo);
    asym_nid = libspdm_get_aysm_nid(base_asym_algo);

    char *subject_name = "C=NL,O=PolarSSL,CN=PolarSSL Server 1";

    result = libspdm_gen_x509_csr(hash_nid, asym_nid,
                                  requester_info, requester_info_length,
                                  !is_device_cert_model,
                                  context, subject_name,
                                  csr_len, csr_pointer);
    libspdm_asym_free(base_asym_algo, context);
#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
}
#endif

    if (csr_buffer_size < *csr_len) {
        LIBSPDM_DEBUG((LIBSPDM_DEBUG_INFO,"csr buffer is too small to sotre generated csr! \n"));
        result = false;
    }
    return result;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_GET_CSR_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP
/**
 * Fill image hash measurement block.
 *
 * @return measurement block size.
 **/
size_t libspdm_fill_measurement_image_hash_block (
    bool use_bit_stream,
    uint32_t measurement_hash_algo,
    uint8_t measurements_index,
    spdm_measurement_block_dmtf_t *measurement_block
    )
{
    size_t hash_size;
    uint8_t data[LIBSPDM_MEASUREMENT_RAW_DATA_SIZE];
    bool result;

    hash_size = libspdm_get_measurement_hash_size(measurement_hash_algo);

    measurement_block->measurement_block_common_header
    .index = measurements_index;
    measurement_block->measurement_block_common_header
    .measurement_specification =
        SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF;

    libspdm_set_mem(data, sizeof(data), (uint8_t)(measurements_index));

    if (!use_bit_stream) {
        measurement_block->measurement_block_dmtf_header
        .dmtf_spec_measurement_value_type =
            (measurements_index - 1);
        measurement_block->measurement_block_dmtf_header
        .dmtf_spec_measurement_value_size =
            (uint16_t)hash_size;

        measurement_block->measurement_block_common_header
        .measurement_size =
            (uint16_t)(sizeof(spdm_measurement_block_dmtf_header_t) +
                       (uint16_t)hash_size);

        result = libspdm_measurement_hash_all(
            measurement_hash_algo, data,
            sizeof(data),
            (void *)(measurement_block + 1));
        if (!result) {
            return 0;
        }

        return sizeof(spdm_measurement_block_dmtf_t) + hash_size;

    } else {
        measurement_block->measurement_block_dmtf_header
        .dmtf_spec_measurement_value_type =
            (measurements_index - 1) |
            SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM;
        measurement_block->measurement_block_dmtf_header
        .dmtf_spec_measurement_value_size =
            (uint16_t)sizeof(data);

        measurement_block->measurement_block_common_header
        .measurement_size =
            (uint16_t)(sizeof(spdm_measurement_block_dmtf_header_t) +
                       (uint16_t)sizeof(data));

        libspdm_copy_mem((void *)(measurement_block + 1), sizeof(data), data, sizeof(data));

        return sizeof(spdm_measurement_block_dmtf_t) + sizeof(data);
    }
}

/**
 * Fill svn measurement block.
 *
 * @return measurement block size.
 **/
size_t libspdm_fill_measurement_svn_block (
    spdm_measurement_block_dmtf_t *measurement_block
    )
{
    spdm_measurements_secure_version_number_t svn;

    measurement_block->measurement_block_common_header
    .index = LIBSPDM_MEASUREMENT_INDEX_SVN;
    measurement_block->measurement_block_common_header
    .measurement_specification =
        SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF;

    svn = 0x7;

    measurement_block->measurement_block_dmtf_header
    .dmtf_spec_measurement_value_type =
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_SECURE_VERSION_NUMBER |
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM;
    measurement_block->measurement_block_dmtf_header
    .dmtf_spec_measurement_value_size =
        (uint16_t)sizeof(svn);

    measurement_block->measurement_block_common_header
    .measurement_size =
        (uint16_t)(sizeof(spdm_measurement_block_dmtf_header_t) +
                   (uint16_t)sizeof(svn));

    libspdm_copy_mem((void *)(measurement_block + 1), sizeof(svn), (void *)&svn, sizeof(svn));

    return sizeof(spdm_measurement_block_dmtf_t) + sizeof(svn);
}

/**
 * Fill manifest measurement block.
 *
 * @return measurement block size.
 **/
size_t libspdm_fill_measurement_manifest_block (
    spdm_measurement_block_dmtf_t *measurement_block
    )
{
    uint8_t data[LIBSPDM_MEASUREMENT_MANIFEST_SIZE];

    measurement_block->measurement_block_common_header
    .index = SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST;
    measurement_block->measurement_block_common_header
    .measurement_specification =
        SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF;

    libspdm_set_mem(data, sizeof(data),
                    (uint8_t)SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST);

    measurement_block->measurement_block_dmtf_header
    .dmtf_spec_measurement_value_type =
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_MEASUREMENT_MANIFEST |
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM;
    measurement_block->measurement_block_dmtf_header
    .dmtf_spec_measurement_value_size =
        (uint16_t)sizeof(data);

    measurement_block->measurement_block_common_header
    .measurement_size =
        (uint16_t)(sizeof(spdm_measurement_block_dmtf_header_t) +
                   (uint16_t)sizeof(data));

    libspdm_copy_mem((void *)(measurement_block + 1), sizeof(data), data, sizeof(data));

    return sizeof(spdm_measurement_block_dmtf_t) + sizeof(data);
}

/**
 * Fill device mode measurement block.
 *
 * @return measurement block size.
 **/
size_t libspdm_fill_measurement_device_mode_block (
    spdm_measurement_block_dmtf_t *measurement_block
    )
{
    spdm_measurements_device_mode_t device_mode;

    measurement_block->measurement_block_common_header
    .index = SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_DEVICE_MODE;
    measurement_block->measurement_block_common_header
    .measurement_specification =
        SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF;

    device_mode.operational_mode_capabilities =
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_MANUFACTURING_MODE |
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_VALIDATION_MODE |
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_NORMAL_MODE |
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_RECOVERY_MODE |
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_RMA_MODE |
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_DECOMMISSIONED_MODE;
    device_mode.operational_mode_state =
        SPDM_MEASUREMENT_DEVICE_OPERATION_MODE_NORMAL_MODE;
    device_mode.device_mode_capabilities =
        SPDM_MEASUREMENT_DEVICE_MODE_NON_INVASIVE_DEBUG_MODE_IS_ACTIVE |
        SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_IS_ACTIVE |
        SPDM_MEASUREMENT_DEVICE_MODE_NON_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE |
        SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE |
        SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE_AFTER_MFG;
    device_mode.device_mode_state =
        SPDM_MEASUREMENT_DEVICE_MODE_NON_INVASIVE_DEBUG_MODE_IS_ACTIVE |
        SPDM_MEASUREMENT_DEVICE_MODE_INVASIVE_DEBUG_MODE_HAS_BEEN_ACTIVE_AFTER_MFG;

    measurement_block->measurement_block_dmtf_header
    .dmtf_spec_measurement_value_type =
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_DEVICE_MODE |
        SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_RAW_BIT_STREAM;
    measurement_block->measurement_block_dmtf_header
    .dmtf_spec_measurement_value_size =
        (uint16_t)sizeof(device_mode);

    measurement_block->measurement_block_common_header
    .measurement_size =
        (uint16_t)(sizeof(spdm_measurement_block_dmtf_header_t) +
                   (uint16_t)sizeof(device_mode));

    libspdm_copy_mem((void *)(measurement_block + 1), sizeof(device_mode),
                     (void *)&device_mode, sizeof(device_mode));

    return sizeof(spdm_measurement_block_dmtf_t) + sizeof(device_mode);
}

libspdm_return_t libspdm_measurement_collection(
    spdm_version_number_t spdm_version,
    uint8_t measurement_specification,
    uint32_t measurement_hash_algo,
    uint8_t measurements_index,
    uint8_t request_attribute,
    uint8_t *content_changed,
    uint8_t *measurements_count,
    void *measurements,
    size_t *measurements_size)
{
    spdm_measurement_block_dmtf_t *measurement_block;
    size_t hash_size;
    uint8_t index;
    size_t total_size_needed;
    bool use_bit_stream;
    size_t measurement_block_size;

    if ((measurement_specification !=
         SPDM_MEASUREMENT_BLOCK_HEADER_SPECIFICATION_DMTF) ||
        (measurement_hash_algo == 0)) {
        return LIBSPDM_STATUS_UNSUPPORTED_CAP;
    }

    hash_size = libspdm_get_measurement_hash_size(measurement_hash_algo);
    LIBSPDM_ASSERT(hash_size != 0);

    use_bit_stream = false;
    if ((measurement_hash_algo == SPDM_ALGORITHMS_MEASUREMENT_HASH_ALGO_RAW_BIT_STREAM_ONLY) ||
        ((request_attribute & SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_RAW_BIT_STREAM_REQUESTED) !=
         0)) {
        use_bit_stream = true;
    }

    if (measurements_index ==
        SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_TOTAL_NUMBER_OF_MEASUREMENTS) {
        *measurements_count = LIBSPDM_MEASUREMENT_BLOCK_NUMBER;
        goto successful_return;
    } else if (measurements_index ==
               SPDM_GET_MEASUREMENTS_REQUEST_MEASUREMENT_OPERATION_ALL_MEASUREMENTS) {

        /* Calculate total_size_needed based on hash algo selected.
         * If we have an hash algo, then the first HASH_NUMBER elements will be
         * hash values, otherwise HASH_NUMBER raw bitstream values.*/
        if (!use_bit_stream) {
            total_size_needed =
                LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER *
                (sizeof(spdm_measurement_block_dmtf_t) + hash_size);
        } else {
            total_size_needed =
                LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER *
                (sizeof(spdm_measurement_block_dmtf_t) + LIBSPDM_MEASUREMENT_RAW_DATA_SIZE);
        }
        /* Next one - SVN is always raw bitstream data.*/
        total_size_needed +=
            (sizeof(spdm_measurement_block_dmtf_t) +
             sizeof(spdm_measurements_secure_version_number_t));
        /* Next one - manifest is always raw bitstream data.*/
        total_size_needed +=
            (sizeof(spdm_measurement_block_dmtf_t) + LIBSPDM_MEASUREMENT_MANIFEST_SIZE);
        /* Next one - device_mode is always raw bitstream data.*/
        total_size_needed +=
            (sizeof(spdm_measurement_block_dmtf_t) + sizeof(spdm_measurements_device_mode_t));

        LIBSPDM_ASSERT(total_size_needed <= *measurements_size);
        if (total_size_needed > *measurements_size) {
            return LIBSPDM_STATUS_BUFFER_TOO_SMALL;
        }

        *measurements_size = total_size_needed;
        *measurements_count = LIBSPDM_MEASUREMENT_BLOCK_NUMBER;
        measurement_block = measurements;

        /* The first HASH_NUMBER blocks may be hash values or raw bitstream*/
        for (index = 1; index <= LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER; index++) {
            measurement_block_size = libspdm_fill_measurement_image_hash_block (use_bit_stream,
                                                                                measurement_hash_algo,
                                                                                index,
                                                                                measurement_block);
            if (measurement_block_size == 0) {
                return LIBSPDM_STATUS_MEAS_INTERNAL_ERROR;
            }
            measurement_block = (void *)((uint8_t *)measurement_block + measurement_block_size);
        }
        /* Next one - SVN is always raw bitstream data.*/
        {
            measurement_block_size = libspdm_fill_measurement_svn_block (measurement_block);
            measurement_block = (void *)((uint8_t *)measurement_block + measurement_block_size);
        }
        /* Next one - manifest is always raw bitstream data.*/
        {
            measurement_block_size = libspdm_fill_measurement_manifest_block (measurement_block);
            measurement_block = (void *)((uint8_t *)measurement_block + measurement_block_size);
        }
        /* Next one - device_mode is always raw bitstream data.*/
        {
            measurement_block_size = libspdm_fill_measurement_device_mode_block (measurement_block);
            measurement_block = (void *)((uint8_t *)measurement_block + measurement_block_size);
        }

        goto successful_return;
    } else {
        /* One Index */
        if (measurements_index <= LIBSPDM_MEASUREMENT_BLOCK_HASH_NUMBER) {
            if (!use_bit_stream) {
                total_size_needed =
                    sizeof(spdm_measurement_block_dmtf_t) +
                    hash_size;
            } else {
                total_size_needed =
                    sizeof(spdm_measurement_block_dmtf_t) +
                    LIBSPDM_MEASUREMENT_RAW_DATA_SIZE;
            }
            LIBSPDM_ASSERT(total_size_needed <= *measurements_size);
            if (total_size_needed > *measurements_size) {
                return LIBSPDM_STATUS_BUFFER_TOO_SMALL;
            }

            *measurements_count = 1;
            *measurements_size = total_size_needed;

            measurement_block = measurements;
            measurement_block_size = libspdm_fill_measurement_image_hash_block (use_bit_stream,
                                                                                measurement_hash_algo,
                                                                                measurements_index,
                                                                                measurement_block);
            if (measurement_block_size == 0) {
                return LIBSPDM_STATUS_MEAS_INTERNAL_ERROR;
            }
        } else if (measurements_index == LIBSPDM_MEASUREMENT_INDEX_SVN) {
            total_size_needed =
                sizeof(spdm_measurement_block_dmtf_t) +
                sizeof(spdm_measurements_secure_version_number_t);
            LIBSPDM_ASSERT(total_size_needed <= *measurements_size);
            if (total_size_needed > *measurements_size) {
                return LIBSPDM_STATUS_BUFFER_TOO_SMALL;
            }

            *measurements_count = 1;
            *measurements_size = total_size_needed;

            measurement_block = measurements;
            measurement_block_size = libspdm_fill_measurement_svn_block (measurement_block);
            if (measurement_block_size == 0) {
                return LIBSPDM_STATUS_MEAS_INTERNAL_ERROR;
            }
        } else if (measurements_index ==
                   SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_MEASUREMENT_MANIFEST) {
            total_size_needed =
                sizeof(spdm_measurement_block_dmtf_t) +
                LIBSPDM_MEASUREMENT_MANIFEST_SIZE;
            LIBSPDM_ASSERT(total_size_needed <= *measurements_size);
            if (total_size_needed > *measurements_size) {
                return LIBSPDM_STATUS_BUFFER_TOO_SMALL;
            }

            *measurements_count = 1;
            *measurements_size = total_size_needed;

            measurement_block = measurements;
            measurement_block_size = libspdm_fill_measurement_manifest_block (measurement_block);
            if (measurement_block_size == 0) {
                return LIBSPDM_STATUS_MEAS_INTERNAL_ERROR;
            }
        } else if (measurements_index == SPDM_MEASUREMENT_BLOCK_MEASUREMENT_INDEX_DEVICE_MODE) {
            total_size_needed =
                sizeof(spdm_measurement_block_dmtf_t) +
                sizeof(spdm_measurements_device_mode_t);
            LIBSPDM_ASSERT(total_size_needed <= *measurements_size);
            if (total_size_needed > *measurements_size) {
                return LIBSPDM_STATUS_BUFFER_TOO_SMALL;
            }

            *measurements_count = 1;
            *measurements_size = total_size_needed;

            measurement_block = measurements;
            measurement_block_size = libspdm_fill_measurement_device_mode_block (measurement_block);
            if (measurement_block_size == 0) {
                return LIBSPDM_STATUS_MEAS_INTERNAL_ERROR;
            }
        } else {
            *measurements_count = 0;
            return LIBSPDM_STATUS_MEAS_INVALID_INDEX;
        }
    }

successful_return:
    if ((content_changed != NULL) &&
        ((spdm_version >> SPDM_VERSION_NUMBER_SHIFT_BIT) >= SPDM_MESSAGE_VERSION_12)) {
        /* return content change*/
        if ((request_attribute & SPDM_GET_MEASUREMENTS_REQUEST_ATTRIBUTES_GENERATE_SIGNATURE) !=
            0) {
            *content_changed = SPDM_MEASUREMENTS_RESPONSE_CONTENT_NO_CHANGE_DETECTED;
        } else {
            *content_changed = SPDM_MEASUREMENTS_RESPONSE_CONTENT_CHANGE_NO_DETECTION;
        }
    }

    return LIBSPDM_STATUS_SUCCESS;
}

size_t libspdm_secret_lib_meas_opaque_data_size;

bool libspdm_measurement_opaque_data(
    spdm_version_number_t spdm_version,
    uint8_t measurement_specification,
    uint32_t measurement_hash_algo,
    uint8_t measurement_index,
    uint8_t request_attribute,
    void *opaque_data,
    size_t *opaque_data_size)
{
    size_t index;

    LIBSPDM_ASSERT(libspdm_secret_lib_meas_opaque_data_size <= *opaque_data_size);

    *opaque_data_size = libspdm_secret_lib_meas_opaque_data_size;

    for (index = 0; index < *opaque_data_size; index++)
    {
        ((uint8_t *)opaque_data)[index] = (uint8_t)index;
    }

    return true;
}

size_t libspdm_secret_lib_challenge_opaque_data_size;

bool libspdm_challenge_opaque_data(
    spdm_version_number_t spdm_version,
    uint8_t slot_id,
    uint8_t *measurement_summary_hash,
    size_t measurement_summary_hash_size,
    void *opaque_data,
    size_t *opaque_data_size)
{
    size_t index;

    LIBSPDM_ASSERT(libspdm_secret_lib_challenge_opaque_data_size <= *opaque_data_size);

    *opaque_data_size = libspdm_secret_lib_challenge_opaque_data_size;

    for (index = 0; index < *opaque_data_size; index++)
    {
        ((uint8_t *)opaque_data)[index] = (uint8_t)index;
    }

    return true;
}

bool libspdm_generate_measurement_summary_hash(
    spdm_version_number_t spdm_version, uint32_t base_hash_algo,
    uint8_t measurement_specification, uint32_t measurement_hash_algo,
    uint8_t measurement_summary_hash_type,
    uint8_t *measurement_summary_hash,
    uint32_t measurement_summary_hash_size)
{
    uint8_t measurement_data[LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE];
    size_t index;
    spdm_measurement_block_dmtf_t *cached_measurment_block;
    size_t measurment_data_size;
    size_t measurment_block_size;
    uint8_t device_measurement[LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE];
    uint8_t device_measurement_count;
    size_t device_measurement_size;
    libspdm_return_t status;
    bool result;

    switch (measurement_summary_hash_type) {
    case SPDM_CHALLENGE_REQUEST_NO_MEASUREMENT_SUMMARY_HASH:
        break;

    case SPDM_CHALLENGE_REQUEST_TCB_COMPONENT_MEASUREMENT_HASH:
    case SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH:
        if (measurement_summary_hash_size != libspdm_get_hash_size(base_hash_algo)) {
            return false;
        }

        /* get all measurement data*/
        device_measurement_size = sizeof(device_measurement);
        status = libspdm_measurement_collection(
            spdm_version, measurement_specification,
            measurement_hash_algo,
            0xFF, /* Get all measurements*/
            0,
            NULL,
            &device_measurement_count, device_measurement,
            &device_measurement_size);
        if (LIBSPDM_STATUS_IS_ERROR(status)) {
            return false;
        }

        /* double confirm that MeasurmentData internal size is correct*/
        measurment_data_size = 0;
        cached_measurment_block = (void *)device_measurement;
        for (index = 0; index < device_measurement_count; index++) {
            measurment_block_size =
                sizeof(spdm_measurement_block_common_header_t) +
                cached_measurment_block
                ->measurement_block_common_header
                .measurement_size;
            LIBSPDM_ASSERT(cached_measurment_block
                           ->measurement_block_common_header
                           .measurement_size ==
                           sizeof(spdm_measurement_block_dmtf_header_t) +
                           cached_measurment_block
                           ->measurement_block_dmtf_header
                           .dmtf_spec_measurement_value_size);
            measurment_data_size +=
                cached_measurment_block
                ->measurement_block_common_header
                .measurement_size;
            cached_measurment_block =
                (void *)((size_t)cached_measurment_block +
                         measurment_block_size);
        }

        LIBSPDM_ASSERT(measurment_data_size <=
                       LIBSPDM_MAX_MEASUREMENT_RECORD_SIZE);

        /* get required data and hash them*/
        cached_measurment_block = (void *)device_measurement;
        measurment_data_size = 0;
        for (index = 0; index < device_measurement_count; index++) {
            measurment_block_size =
                sizeof(spdm_measurement_block_common_header_t) +
                cached_measurment_block
                ->measurement_block_common_header
                .measurement_size;
            /* filter unneeded data*/
            if ((measurement_summary_hash_type ==
                 SPDM_CHALLENGE_REQUEST_ALL_MEASUREMENTS_HASH) ||
                ((cached_measurment_block
                  ->measurement_block_dmtf_header
                  .dmtf_spec_measurement_value_type &
                  SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_MASK) ==
                 SPDM_MEASUREMENT_BLOCK_MEASUREMENT_TYPE_IMMUTABLE_ROM)) {
                if (spdm_version < (SPDM_MESSAGE_VERSION_12 << SPDM_VERSION_NUMBER_SHIFT_BIT)) {
                    libspdm_copy_mem(&measurement_data[measurment_data_size],
                                     sizeof(measurement_data)
                                     - (&measurement_data[measurment_data_size] - measurement_data),
                                     &cached_measurment_block->measurement_block_dmtf_header,
                                     cached_measurment_block->measurement_block_common_header
                                     .measurement_size);

                    measurment_data_size +=
                        cached_measurment_block
                        ->measurement_block_common_header
                        .measurement_size;
                } else {
                    libspdm_copy_mem(&measurement_data[measurment_data_size],
                                     sizeof(measurement_data)
                                     - (&measurement_data[measurment_data_size] - measurement_data),
                                     cached_measurment_block,
                                     sizeof(cached_measurment_block->measurement_block_common_header) +
                                     cached_measurment_block->measurement_block_common_header
                                     .measurement_size);

                    measurment_data_size +=
                        sizeof(cached_measurment_block->measurement_block_common_header) +
                        cached_measurment_block
                        ->measurement_block_common_header
                        .measurement_size;
                }
            }
            cached_measurment_block =
                (void *)((size_t)cached_measurment_block +
                         measurment_block_size);
        }

        result = libspdm_hash_all(base_hash_algo, measurement_data,
                                  measurment_data_size, measurement_summary_hash);
        if (!result) {
            return false;
        }
        break;
    default:
        return false;
        break;
    }
    return true;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_MEAS_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP
bool libspdm_requester_data_sign(
    spdm_version_number_t spdm_version, uint8_t op_code,
    uint16_t req_base_asym_alg,
    uint32_t base_hash_algo, bool is_data_hash,
    const uint8_t *message, size_t message_size,
    uint8_t *signature, size_t *sig_size)
{
    void *context;
    bool result;

#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
    if (g_private_key_mode) {
        void *private_pem;
        size_t private_pem_size;

        result = libspdm_read_requester_private_key(
            req_base_asym_alg, &private_pem, &private_pem_size);
        if (!result) {
            return false;
        }

        result = libspdm_req_asym_get_private_key_from_pem(req_base_asym_alg,
                                                           private_pem,
                                                           private_pem_size, NULL,
                                                           &context);
        if (!result) {
            libspdm_zero_mem(private_pem, private_pem_size);
            free(private_pem);
            return false;
        }

        if (is_data_hash) {
            result = libspdm_req_asym_sign_hash(spdm_version, op_code, req_base_asym_alg,
                                                base_hash_algo, context,
                                                message, message_size, signature, sig_size);
        } else {
            result = libspdm_req_asym_sign(spdm_version, op_code, req_base_asym_alg,
                                           base_hash_algo, context,
                                           message, message_size,
                                           signature, sig_size);
        }
        libspdm_req_asym_free(req_base_asym_alg, context);
        libspdm_zero_mem(private_pem, private_pem_size);
        free(private_pem);
    } else {
#endif
    result = libspdm_get_requester_private_key_from_raw_data(req_base_asym_alg, &context);
    if (!result) {
        return false;
    }

    if (is_data_hash) {
        result = libspdm_req_asym_sign_hash(spdm_version, op_code, req_base_asym_alg,
                                            base_hash_algo, context,
                                            message, message_size, signature, sig_size);
    } else {
        result = libspdm_req_asym_sign(spdm_version, op_code, req_base_asym_alg,
                                       base_hash_algo, context,
                                       message, message_size,
                                       signature, sig_size);
    }
    libspdm_req_asym_free(req_base_asym_alg, context);
#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
}
#endif

    return result;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_MUT_AUTH_CAP */

bool libspdm_responder_data_sign(
    spdm_version_number_t spdm_version, uint8_t op_code,
    uint32_t base_asym_algo,
    uint32_t base_hash_algo, bool is_data_hash,
    const uint8_t *message, size_t message_size,
    uint8_t *signature, size_t *sig_size)
{
    void *context;
    bool result;
#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
    if (g_private_key_mode) {
        void *private_pem;
        size_t private_pem_size;

        result = libspdm_read_responder_private_key(
            base_asym_algo, &private_pem, &private_pem_size);
        if (!result) {
            return false;
        }

        result = libspdm_asym_get_private_key_from_pem(
            base_asym_algo, private_pem, private_pem_size, NULL, &context);
        if (!result) {
            libspdm_zero_mem(private_pem, private_pem_size);
            free(private_pem);
            return false;
        }

        if (is_data_hash) {
            result = libspdm_asym_sign_hash(spdm_version, op_code, base_asym_algo, base_hash_algo,
                                            context,
                                            message, message_size, signature, sig_size);
        } else {
            result = libspdm_asym_sign(spdm_version, op_code, base_asym_algo,
                                       base_hash_algo, context,
                                       message, message_size,
                                       signature, sig_size);
        }
        libspdm_asym_free(base_asym_algo, context);
        libspdm_zero_mem(private_pem, private_pem_size);
        free(private_pem);
    } else {
#endif
    result = libspdm_get_responder_private_key_from_raw_data(base_asym_algo, &context);
    if (!result) {
        return false;
    }

    if (is_data_hash) {
        result = libspdm_asym_sign_hash(spdm_version, op_code, base_asym_algo, base_hash_algo,
                                        context,
                                        message, message_size, signature, sig_size);
    } else {
        result = libspdm_asym_sign(spdm_version, op_code, base_asym_algo,
                                   base_hash_algo, context,
                                   message, message_size,
                                   signature, sig_size);
    }
    libspdm_asym_free(base_asym_algo, context);
#if !LIBSPDM_PRIVATE_KEY_MODE_RAW_KEY_ONLY
}
#endif

    return result;
}

#if LIBSPDM_ENABLE_CAPABILITY_PSK_EX_CAP

uint8_t m_libspdm_my_zero_filled_buffer[LIBSPDM_MAX_HASH_SIZE];
uint8_t m_libspdm_bin_str0[0x11] = {
    0x00, 0x00, /* length - to be filled*/
    /* SPDM_VERSION_1_1_BIN_CONCAT_LABEL */
    0x73, 0x70, 0x64, 0x6d, 0x31, 0x2e, 0x31, 0x20,
    /* SPDM_BIN_STR_0_LABEL */
    0x64, 0x65, 0x72, 0x69, 0x76, 0x65, 0x64,
};

bool libspdm_psk_handshake_secret_hkdf_expand(
    spdm_version_number_t spdm_version,
    uint32_t base_hash_algo,
    const uint8_t *psk_hint,
    size_t psk_hint_size,
    const uint8_t *info,
    size_t info_size,
    uint8_t *out, size_t out_size)
{
    void *psk;
    size_t psk_size;
    size_t hash_size;
    bool result;
    uint8_t handshake_secret[LIBSPDM_MAX_HASH_SIZE];

    if (psk_hint_size == 0) {
        psk = LIBSPDM_TEST_PSK_DATA_STRING;
        psk_size = sizeof(LIBSPDM_TEST_PSK_DATA_STRING);
    } else if ((strcmp((const char *)psk_hint, LIBSPDM_TEST_PSK_HINT_STRING) ==
                0) &&
               (psk_hint_size == sizeof(LIBSPDM_TEST_PSK_HINT_STRING))) {
        psk = LIBSPDM_TEST_PSK_DATA_STRING;
        psk_size = sizeof(LIBSPDM_TEST_PSK_DATA_STRING);
    } else {
        return false;
    }
    printf("[PSK]: ");
    libspdm_dump_hex_str(psk, psk_size);
    printf("\n");

    hash_size = libspdm_get_hash_size(base_hash_algo);

    result = libspdm_hkdf_extract(base_hash_algo, psk, psk_size, m_libspdm_my_zero_filled_buffer,
                                  hash_size, handshake_secret, hash_size);
    if (!result) {
        return result;
    }

    result = libspdm_hkdf_expand(base_hash_algo, handshake_secret, hash_size,
                                 info, info_size, out, out_size);
    libspdm_zero_mem(handshake_secret, hash_size);

    return result;
}

bool libspdm_psk_master_secret_hkdf_expand(
    spdm_version_number_t spdm_version,
    uint32_t base_hash_algo,
    const uint8_t *psk_hint,
    size_t psk_hint_size,
    const uint8_t *info,
    size_t info_size, uint8_t *out,
    size_t out_size)
{
    void *psk;
    size_t psk_size;
    size_t hash_size;
    bool result;
    uint8_t handshake_secret[LIBSPDM_MAX_HASH_SIZE];
    uint8_t salt1[LIBSPDM_MAX_HASH_SIZE];
    uint8_t master_secret[LIBSPDM_MAX_HASH_SIZE];

    if (psk_hint_size == 0) {
        psk = LIBSPDM_TEST_PSK_DATA_STRING;
        psk_size = sizeof(LIBSPDM_TEST_PSK_DATA_STRING);
    } else if ((strcmp((const char *)psk_hint, LIBSPDM_TEST_PSK_HINT_STRING) ==
                0) &&
               (psk_hint_size == sizeof(LIBSPDM_TEST_PSK_HINT_STRING))) {
        psk = LIBSPDM_TEST_PSK_DATA_STRING;
        psk_size = sizeof(LIBSPDM_TEST_PSK_DATA_STRING);
    } else {
        return false;
    }

    hash_size = libspdm_get_hash_size(base_hash_algo);

    result = libspdm_hkdf_extract(base_hash_algo, psk, psk_size, m_libspdm_my_zero_filled_buffer,
                                  hash_size, handshake_secret, hash_size);
    if (!result) {
        return result;
    }

    *(uint16_t *)m_libspdm_bin_str0 = (uint16_t)hash_size;
    /* patch the version*/
    m_libspdm_bin_str0[6] = (char)('0' + ((spdm_version >> 12) & 0xF));
    m_libspdm_bin_str0[8] = (char)('0' + ((spdm_version >> 8) & 0xF));
    result = libspdm_hkdf_expand(base_hash_algo, handshake_secret, hash_size,
                                 m_libspdm_bin_str0, sizeof(m_libspdm_bin_str0), salt1,
                                 hash_size);
    libspdm_zero_mem(handshake_secret, hash_size);
    if (!result) {
        return result;
    }

    result = libspdm_hkdf_extract(base_hash_algo, m_libspdm_my_zero_filled_buffer,
                                  hash_size, salt1, hash_size, master_secret, hash_size);
    libspdm_zero_mem(salt1, hash_size);
    if (!result) {
        return result;
    }

    result = libspdm_hkdf_expand(base_hash_algo, master_secret, hash_size,
                                 info, info_size, out, out_size);
    libspdm_zero_mem(master_secret, hash_size);

    return result;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_PSK_EX_CAP */

#if LIBSPDM_ENABLE_CAPABILITY_SET_CERT_CAP
bool libspdm_is_in_trusted_environment()
{
    return g_in_trusted_environment;
}

bool libspdm_write_certificate_to_nvm(uint8_t slot_id, const void * cert_chain,
                                      size_t cert_chain_size)
{
#if defined(_MSC_VER) || (defined(__clang__) && (defined (LIBSPDM_CPU_AARCH64) || \
    defined(LIBSPDM_CPU_ARM)))
    FILE *fp_out;
#else
    uint64_t fp_out;
#endif

    char file_name[] = {'s','l','o','t','_','i','d','_','0','\0'};

    file_name[strlen(file_name) - 1] = (char)(slot_id+'0');

#if defined(_MSC_VER) || (defined(__clang__) && (defined (LIBSPDM_CPU_AARCH64) || \
    defined(LIBSPDM_CPU_ARM)))
    if ((fp_out = fopen(file_name, "w+b")) == NULL) {
        printf("Unable to open file %s\n", file_name);
        return false;
    }

    if ((fwrite(cert_chain, 1, cert_chain_size, fp_out)) != cert_chain_size) {
        printf("Write output file error %s\n", file_name);
        fclose(fp_out);
        return false;
    }

    fclose(fp_out);
#else
    if ((fp_out = open(file_name, O_WRONLY | O_CREAT, S_IRWXU)) == -1) {
        printf("Unable to open file %s\n", file_name);
        return false;
    }

    if ((write(fp_out, cert_chain, cert_chain_size)) != cert_chain_size)
    {
        printf("Write output file error %s\n", file_name);
        close(fp_out);
        return false;
    }

    close(fp_out);
#endif

    return true;
}
#endif /* LIBSPDM_ENABLE_CAPABILITY_SET_CERT_CAP */
