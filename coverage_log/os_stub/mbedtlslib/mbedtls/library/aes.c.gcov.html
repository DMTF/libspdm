<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - coverage.info - os_stub/mbedtlslib/mbedtls/library/aes.c</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="title">LCOV - code coverage report</td></tr>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

            <tr>
              <td width="100%">
                <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="10%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">os_stub/mbedtlslib/mbedtls/library</a> - aes.c<span style="font-size: 80%;"> (source / <a href="aes.c.func-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="5%"></td>
            <td width="5%" class="headerCovTableHead">Coverage</td>
            <td width="5%" class="headerCovTableHead" title="Covered + Uncovered code">Total</td>
            <td width="5%" class="headerCovTableHead" title="Exercised code only">Hit</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">coverage.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntryLo">23.0&nbsp;%</td>
            <td class="headerCovTableEntry">269</td>
            <td class="headerCovTableEntry">62</td>
          </tr>
          <tr>
            <td class="headerItem">Test Date:</td>
            <td class="headerValue">2025-10-19 08:11:11</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntryLo">54.5&nbsp;%</td>
            <td class="headerCovTableEntry">11</td>
            <td class="headerCovTableEntry">6</td>
          </tr>
                  <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
                </table>
              </td>
            </tr>

            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
          </table>

          <table cellpadding=0 cellspacing=0 border=0>
            <tr>
              <td><br></td>
            </tr>
            <tr>
              <td>
<pre class="sourceHeading">            Line data    Source code</pre>
<pre class="source">
<span id="L1"><span class="lineNum">       1</span>              : /*</span>
<span id="L2"><span class="lineNum">       2</span>              :  *  FIPS-197 compliant AES implementation</span>
<span id="L3"><span class="lineNum">       3</span>              :  *</span>
<span id="L4"><span class="lineNum">       4</span>              :  *  Copyright The Mbed TLS Contributors</span>
<span id="L5"><span class="lineNum">       5</span>              :  *  SPDX-License-Identifier: Apache-2.0 OR GPL-2.0-or-later</span>
<span id="L6"><span class="lineNum">       6</span>              :  */</span>
<span id="L7"><span class="lineNum">       7</span>              : /*</span>
<span id="L8"><span class="lineNum">       8</span>              :  *  The AES block cipher was designed by Vincent Rijmen and Joan Daemen.</span>
<span id="L9"><span class="lineNum">       9</span>              :  *</span>
<span id="L10"><span class="lineNum">      10</span>              :  *  https://csrc.nist.gov/csrc/media/projects/cryptographic-standards-and-guidelines/documents/aes-development/rijndael-ammended.pdf</span>
<span id="L11"><span class="lineNum">      11</span>              :  *  http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf</span>
<span id="L12"><span class="lineNum">      12</span>              :  */</span>
<span id="L13"><span class="lineNum">      13</span>              : </span>
<span id="L14"><span class="lineNum">      14</span>              : #include &quot;common.h&quot;</span>
<span id="L15"><span class="lineNum">      15</span>              : </span>
<span id="L16"><span class="lineNum">      16</span>              : #if defined(MBEDTLS_AES_C)</span>
<span id="L17"><span class="lineNum">      17</span>              : </span>
<span id="L18"><span class="lineNum">      18</span>              : #include &lt;string.h&gt;</span>
<span id="L19"><span class="lineNum">      19</span>              : </span>
<span id="L20"><span class="lineNum">      20</span>              : #include &quot;mbedtls/aes.h&quot;</span>
<span id="L21"><span class="lineNum">      21</span>              : #include &quot;mbedtls/platform.h&quot;</span>
<span id="L22"><span class="lineNum">      22</span>              : #include &quot;mbedtls/platform_util.h&quot;</span>
<span id="L23"><span class="lineNum">      23</span>              : #include &quot;mbedtls/error.h&quot;</span>
<span id="L24"><span class="lineNum">      24</span>              : </span>
<span id="L25"><span class="lineNum">      25</span>              : #if defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L26"><span class="lineNum">      26</span>              : #if !((defined(MBEDTLS_ARCH_IS_ARMV8_A) &amp;&amp; defined(MBEDTLS_AESCE_C)) || \</span>
<span id="L27"><span class="lineNum">      27</span>              :     (defined(MBEDTLS_ARCH_IS_X64)       &amp;&amp; defined(MBEDTLS_AESNI_C)) || \</span>
<span id="L28"><span class="lineNum">      28</span>              :     (defined(MBEDTLS_ARCH_IS_X86)       &amp;&amp; defined(MBEDTLS_AESNI_C)))</span>
<span id="L29"><span class="lineNum">      29</span>              : #error &quot;MBEDTLS_AES_USE_HARDWARE_ONLY defined, but not all prerequisites&quot;</span>
<span id="L30"><span class="lineNum">      30</span>              : #endif</span>
<span id="L31"><span class="lineNum">      31</span>              : #endif</span>
<span id="L32"><span class="lineNum">      32</span>              : </span>
<span id="L33"><span class="lineNum">      33</span>              : #if defined(MBEDTLS_ARCH_IS_X86)</span>
<span id="L34"><span class="lineNum">      34</span>              : #if defined(MBEDTLS_PADLOCK_C)</span>
<span id="L35"><span class="lineNum">      35</span>              : #if !defined(MBEDTLS_HAVE_ASM)</span>
<span id="L36"><span class="lineNum">      36</span>              : #error &quot;MBEDTLS_PADLOCK_C defined, but not all prerequisites&quot;</span>
<span id="L37"><span class="lineNum">      37</span>              : #endif</span>
<span id="L38"><span class="lineNum">      38</span>              : #if defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L39"><span class="lineNum">      39</span>              : #error &quot;MBEDTLS_AES_USE_HARDWARE_ONLY cannot be defined when &quot; \</span>
<span id="L40"><span class="lineNum">      40</span>              :     &quot;MBEDTLS_PADLOCK_C is set&quot;</span>
<span id="L41"><span class="lineNum">      41</span>              : #endif</span>
<span id="L42"><span class="lineNum">      42</span>              : #endif</span>
<span id="L43"><span class="lineNum">      43</span>              : #endif</span>
<span id="L44"><span class="lineNum">      44</span>              : </span>
<span id="L45"><span class="lineNum">      45</span>              : #if defined(MBEDTLS_PADLOCK_C)</span>
<span id="L46"><span class="lineNum">      46</span>              : #include &quot;padlock.h&quot;</span>
<span id="L47"><span class="lineNum">      47</span>              : #endif</span>
<span id="L48"><span class="lineNum">      48</span>              : #if defined(MBEDTLS_AESNI_C)</span>
<span id="L49"><span class="lineNum">      49</span>              : #include &quot;aesni.h&quot;</span>
<span id="L50"><span class="lineNum">      50</span>              : #endif</span>
<span id="L51"><span class="lineNum">      51</span>              : #if defined(MBEDTLS_AESCE_C)</span>
<span id="L52"><span class="lineNum">      52</span>              : #include &quot;aesce.h&quot;</span>
<span id="L53"><span class="lineNum">      53</span>              : #endif</span>
<span id="L54"><span class="lineNum">      54</span>              : </span>
<span id="L55"><span class="lineNum">      55</span>              : #include &quot;mbedtls/platform.h&quot;</span>
<span id="L56"><span class="lineNum">      56</span>              : #include &quot;ctr.h&quot;</span>
<span id="L57"><span class="lineNum">      57</span>              : </span>
<span id="L58"><span class="lineNum">      58</span>              : /*</span>
<span id="L59"><span class="lineNum">      59</span>              :  * This is a convenience shorthand macro to check if we need reverse S-box and</span>
<span id="L60"><span class="lineNum">      60</span>              :  * reverse tables. It's private and only defined in this file.</span>
<span id="L61"><span class="lineNum">      61</span>              :  */</span>
<span id="L62"><span class="lineNum">      62</span>              : #if (!defined(MBEDTLS_AES_DECRYPT_ALT) || \</span>
<span id="L63"><span class="lineNum">      63</span>              :     (!defined(MBEDTLS_AES_SETKEY_DEC_ALT) &amp;&amp; !defined(MBEDTLS_AES_USE_HARDWARE_ONLY))) &amp;&amp; \</span>
<span id="L64"><span class="lineNum">      64</span>              :     !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L65"><span class="lineNum">      65</span>              : #define MBEDTLS_AES_NEED_REVERSE_TABLES</span>
<span id="L66"><span class="lineNum">      66</span>              : #endif</span>
<span id="L67"><span class="lineNum">      67</span>              : </span>
<span id="L68"><span class="lineNum">      68</span>              : #if !defined(MBEDTLS_AES_ALT)</span>
<span id="L69"><span class="lineNum">      69</span>              : </span>
<span id="L70"><span class="lineNum">      70</span>              : #if defined(MBEDTLS_VIA_PADLOCK_HAVE_CODE)</span>
<span id="L71"><span class="lineNum">      71</span>              : static int aes_padlock_ace = -1;</span>
<span id="L72"><span class="lineNum">      72</span>              : #endif</span>
<span id="L73"><span class="lineNum">      73</span>              : </span>
<span id="L74"><span class="lineNum">      74</span>              : #if defined(MBEDTLS_AES_ROM_TABLES)</span>
<span id="L75"><span class="lineNum">      75</span>              : /*</span>
<span id="L76"><span class="lineNum">      76</span>              :  * Forward S-box</span>
<span id="L77"><span class="lineNum">      77</span>              :  */</span>
<span id="L78"><span class="lineNum">      78</span>              : MBEDTLS_MAYBE_UNUSED static const unsigned char FSb[256] =</span>
<span id="L79"><span class="lineNum">      79</span>              : {</span>
<span id="L80"><span class="lineNum">      80</span>              :     0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5,</span>
<span id="L81"><span class="lineNum">      81</span>              :     0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,</span>
<span id="L82"><span class="lineNum">      82</span>              :     0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0,</span>
<span id="L83"><span class="lineNum">      83</span>              :     0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,</span>
<span id="L84"><span class="lineNum">      84</span>              :     0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC,</span>
<span id="L85"><span class="lineNum">      85</span>              :     0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,</span>
<span id="L86"><span class="lineNum">      86</span>              :     0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A,</span>
<span id="L87"><span class="lineNum">      87</span>              :     0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,</span>
<span id="L88"><span class="lineNum">      88</span>              :     0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0,</span>
<span id="L89"><span class="lineNum">      89</span>              :     0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,</span>
<span id="L90"><span class="lineNum">      90</span>              :     0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B,</span>
<span id="L91"><span class="lineNum">      91</span>              :     0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,</span>
<span id="L92"><span class="lineNum">      92</span>              :     0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85,</span>
<span id="L93"><span class="lineNum">      93</span>              :     0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,</span>
<span id="L94"><span class="lineNum">      94</span>              :     0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5,</span>
<span id="L95"><span class="lineNum">      95</span>              :     0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,</span>
<span id="L96"><span class="lineNum">      96</span>              :     0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17,</span>
<span id="L97"><span class="lineNum">      97</span>              :     0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,</span>
<span id="L98"><span class="lineNum">      98</span>              :     0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88,</span>
<span id="L99"><span class="lineNum">      99</span>              :     0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,</span>
<span id="L100"><span class="lineNum">     100</span>              :     0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C,</span>
<span id="L101"><span class="lineNum">     101</span>              :     0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,</span>
<span id="L102"><span class="lineNum">     102</span>              :     0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9,</span>
<span id="L103"><span class="lineNum">     103</span>              :     0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,</span>
<span id="L104"><span class="lineNum">     104</span>              :     0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6,</span>
<span id="L105"><span class="lineNum">     105</span>              :     0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,</span>
<span id="L106"><span class="lineNum">     106</span>              :     0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E,</span>
<span id="L107"><span class="lineNum">     107</span>              :     0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,</span>
<span id="L108"><span class="lineNum">     108</span>              :     0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94,</span>
<span id="L109"><span class="lineNum">     109</span>              :     0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,</span>
<span id="L110"><span class="lineNum">     110</span>              :     0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68,</span>
<span id="L111"><span class="lineNum">     111</span>              :     0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16</span>
<span id="L112"><span class="lineNum">     112</span>              : };</span>
<span id="L113"><span class="lineNum">     113</span>              : </span>
<span id="L114"><span class="lineNum">     114</span>              : /*</span>
<span id="L115"><span class="lineNum">     115</span>              :  * Forward tables</span>
<span id="L116"><span class="lineNum">     116</span>              :  */</span>
<span id="L117"><span class="lineNum">     117</span>              : #define FT \</span>
<span id="L118"><span class="lineNum">     118</span>              : \</span>
<span id="L119"><span class="lineNum">     119</span>              :     V(A5, 63, 63, C6), V(84, 7C, 7C, F8), V(99, 77, 77, EE), V(8D, 7B, 7B, F6), \</span>
<span id="L120"><span class="lineNum">     120</span>              :     V(0D, F2, F2, FF), V(BD, 6B, 6B, D6), V(B1, 6F, 6F, DE), V(54, C5, C5, 91), \</span>
<span id="L121"><span class="lineNum">     121</span>              :     V(50, 30, 30, 60), V(03, 01, 01, 02), V(A9, 67, 67, CE), V(7D, 2B, 2B, 56), \</span>
<span id="L122"><span class="lineNum">     122</span>              :     V(19, FE, FE, E7), V(62, D7, D7, B5), V(E6, AB, AB, 4D), V(9A, 76, 76, EC), \</span>
<span id="L123"><span class="lineNum">     123</span>              :     V(45, CA, CA, 8F), V(9D, 82, 82, 1F), V(40, C9, C9, 89), V(87, 7D, 7D, FA), \</span>
<span id="L124"><span class="lineNum">     124</span>              :     V(15, FA, FA, EF), V(EB, 59, 59, B2), V(C9, 47, 47, 8E), V(0B, F0, F0, FB), \</span>
<span id="L125"><span class="lineNum">     125</span>              :     V(EC, AD, AD, 41), V(67, D4, D4, B3), V(FD, A2, A2, 5F), V(EA, AF, AF, 45), \</span>
<span id="L126"><span class="lineNum">     126</span>              :     V(BF, 9C, 9C, 23), V(F7, A4, A4, 53), V(96, 72, 72, E4), V(5B, C0, C0, 9B), \</span>
<span id="L127"><span class="lineNum">     127</span>              :     V(C2, B7, B7, 75), V(1C, FD, FD, E1), V(AE, 93, 93, 3D), V(6A, 26, 26, 4C), \</span>
<span id="L128"><span class="lineNum">     128</span>              :     V(5A, 36, 36, 6C), V(41, 3F, 3F, 7E), V(02, F7, F7, F5), V(4F, CC, CC, 83), \</span>
<span id="L129"><span class="lineNum">     129</span>              :     V(5C, 34, 34, 68), V(F4, A5, A5, 51), V(34, E5, E5, D1), V(08, F1, F1, F9), \</span>
<span id="L130"><span class="lineNum">     130</span>              :     V(93, 71, 71, E2), V(73, D8, D8, AB), V(53, 31, 31, 62), V(3F, 15, 15, 2A), \</span>
<span id="L131"><span class="lineNum">     131</span>              :     V(0C, 04, 04, 08), V(52, C7, C7, 95), V(65, 23, 23, 46), V(5E, C3, C3, 9D), \</span>
<span id="L132"><span class="lineNum">     132</span>              :     V(28, 18, 18, 30), V(A1, 96, 96, 37), V(0F, 05, 05, 0A), V(B5, 9A, 9A, 2F), \</span>
<span id="L133"><span class="lineNum">     133</span>              :     V(09, 07, 07, 0E), V(36, 12, 12, 24), V(9B, 80, 80, 1B), V(3D, E2, E2, DF), \</span>
<span id="L134"><span class="lineNum">     134</span>              :     V(26, EB, EB, CD), V(69, 27, 27, 4E), V(CD, B2, B2, 7F), V(9F, 75, 75, EA), \</span>
<span id="L135"><span class="lineNum">     135</span>              :     V(1B, 09, 09, 12), V(9E, 83, 83, 1D), V(74, 2C, 2C, 58), V(2E, 1A, 1A, 34), \</span>
<span id="L136"><span class="lineNum">     136</span>              :     V(2D, 1B, 1B, 36), V(B2, 6E, 6E, DC), V(EE, 5A, 5A, B4), V(FB, A0, A0, 5B), \</span>
<span id="L137"><span class="lineNum">     137</span>              :     V(F6, 52, 52, A4), V(4D, 3B, 3B, 76), V(61, D6, D6, B7), V(CE, B3, B3, 7D), \</span>
<span id="L138"><span class="lineNum">     138</span>              :     V(7B, 29, 29, 52), V(3E, E3, E3, DD), V(71, 2F, 2F, 5E), V(97, 84, 84, 13), \</span>
<span id="L139"><span class="lineNum">     139</span>              :     V(F5, 53, 53, A6), V(68, D1, D1, B9), V(00, 00, 00, 00), V(2C, ED, ED, C1), \</span>
<span id="L140"><span class="lineNum">     140</span>              :     V(60, 20, 20, 40), V(1F, FC, FC, E3), V(C8, B1, B1, 79), V(ED, 5B, 5B, B6), \</span>
<span id="L141"><span class="lineNum">     141</span>              :     V(BE, 6A, 6A, D4), V(46, CB, CB, 8D), V(D9, BE, BE, 67), V(4B, 39, 39, 72), \</span>
<span id="L142"><span class="lineNum">     142</span>              :     V(DE, 4A, 4A, 94), V(D4, 4C, 4C, 98), V(E8, 58, 58, B0), V(4A, CF, CF, 85), \</span>
<span id="L143"><span class="lineNum">     143</span>              :     V(6B, D0, D0, BB), V(2A, EF, EF, C5), V(E5, AA, AA, 4F), V(16, FB, FB, ED), \</span>
<span id="L144"><span class="lineNum">     144</span>              :     V(C5, 43, 43, 86), V(D7, 4D, 4D, 9A), V(55, 33, 33, 66), V(94, 85, 85, 11), \</span>
<span id="L145"><span class="lineNum">     145</span>              :     V(CF, 45, 45, 8A), V(10, F9, F9, E9), V(06, 02, 02, 04), V(81, 7F, 7F, FE), \</span>
<span id="L146"><span class="lineNum">     146</span>              :     V(F0, 50, 50, A0), V(44, 3C, 3C, 78), V(BA, 9F, 9F, 25), V(E3, A8, A8, 4B), \</span>
<span id="L147"><span class="lineNum">     147</span>              :     V(F3, 51, 51, A2), V(FE, A3, A3, 5D), V(C0, 40, 40, 80), V(8A, 8F, 8F, 05), \</span>
<span id="L148"><span class="lineNum">     148</span>              :     V(AD, 92, 92, 3F), V(BC, 9D, 9D, 21), V(48, 38, 38, 70), V(04, F5, F5, F1), \</span>
<span id="L149"><span class="lineNum">     149</span>              :     V(DF, BC, BC, 63), V(C1, B6, B6, 77), V(75, DA, DA, AF), V(63, 21, 21, 42), \</span>
<span id="L150"><span class="lineNum">     150</span>              :     V(30, 10, 10, 20), V(1A, FF, FF, E5), V(0E, F3, F3, FD), V(6D, D2, D2, BF), \</span>
<span id="L151"><span class="lineNum">     151</span>              :     V(4C, CD, CD, 81), V(14, 0C, 0C, 18), V(35, 13, 13, 26), V(2F, EC, EC, C3), \</span>
<span id="L152"><span class="lineNum">     152</span>              :     V(E1, 5F, 5F, BE), V(A2, 97, 97, 35), V(CC, 44, 44, 88), V(39, 17, 17, 2E), \</span>
<span id="L153"><span class="lineNum">     153</span>              :     V(57, C4, C4, 93), V(F2, A7, A7, 55), V(82, 7E, 7E, FC), V(47, 3D, 3D, 7A), \</span>
<span id="L154"><span class="lineNum">     154</span>              :     V(AC, 64, 64, C8), V(E7, 5D, 5D, BA), V(2B, 19, 19, 32), V(95, 73, 73, E6), \</span>
<span id="L155"><span class="lineNum">     155</span>              :     V(A0, 60, 60, C0), V(98, 81, 81, 19), V(D1, 4F, 4F, 9E), V(7F, DC, DC, A3), \</span>
<span id="L156"><span class="lineNum">     156</span>              :     V(66, 22, 22, 44), V(7E, 2A, 2A, 54), V(AB, 90, 90, 3B), V(83, 88, 88, 0B), \</span>
<span id="L157"><span class="lineNum">     157</span>              :     V(CA, 46, 46, 8C), V(29, EE, EE, C7), V(D3, B8, B8, 6B), V(3C, 14, 14, 28), \</span>
<span id="L158"><span class="lineNum">     158</span>              :     V(79, DE, DE, A7), V(E2, 5E, 5E, BC), V(1D, 0B, 0B, 16), V(76, DB, DB, AD), \</span>
<span id="L159"><span class="lineNum">     159</span>              :     V(3B, E0, E0, DB), V(56, 32, 32, 64), V(4E, 3A, 3A, 74), V(1E, 0A, 0A, 14), \</span>
<span id="L160"><span class="lineNum">     160</span>              :     V(DB, 49, 49, 92), V(0A, 06, 06, 0C), V(6C, 24, 24, 48), V(E4, 5C, 5C, B8), \</span>
<span id="L161"><span class="lineNum">     161</span>              :     V(5D, C2, C2, 9F), V(6E, D3, D3, BD), V(EF, AC, AC, 43), V(A6, 62, 62, C4), \</span>
<span id="L162"><span class="lineNum">     162</span>              :     V(A8, 91, 91, 39), V(A4, 95, 95, 31), V(37, E4, E4, D3), V(8B, 79, 79, F2), \</span>
<span id="L163"><span class="lineNum">     163</span>              :     V(32, E7, E7, D5), V(43, C8, C8, 8B), V(59, 37, 37, 6E), V(B7, 6D, 6D, DA), \</span>
<span id="L164"><span class="lineNum">     164</span>              :     V(8C, 8D, 8D, 01), V(64, D5, D5, B1), V(D2, 4E, 4E, 9C), V(E0, A9, A9, 49), \</span>
<span id="L165"><span class="lineNum">     165</span>              :     V(B4, 6C, 6C, D8), V(FA, 56, 56, AC), V(07, F4, F4, F3), V(25, EA, EA, CF), \</span>
<span id="L166"><span class="lineNum">     166</span>              :     V(AF, 65, 65, CA), V(8E, 7A, 7A, F4), V(E9, AE, AE, 47), V(18, 08, 08, 10), \</span>
<span id="L167"><span class="lineNum">     167</span>              :     V(D5, BA, BA, 6F), V(88, 78, 78, F0), V(6F, 25, 25, 4A), V(72, 2E, 2E, 5C), \</span>
<span id="L168"><span class="lineNum">     168</span>              :     V(24, 1C, 1C, 38), V(F1, A6, A6, 57), V(C7, B4, B4, 73), V(51, C6, C6, 97), \</span>
<span id="L169"><span class="lineNum">     169</span>              :     V(23, E8, E8, CB), V(7C, DD, DD, A1), V(9C, 74, 74, E8), V(21, 1F, 1F, 3E), \</span>
<span id="L170"><span class="lineNum">     170</span>              :     V(DD, 4B, 4B, 96), V(DC, BD, BD, 61), V(86, 8B, 8B, 0D), V(85, 8A, 8A, 0F), \</span>
<span id="L171"><span class="lineNum">     171</span>              :     V(90, 70, 70, E0), V(42, 3E, 3E, 7C), V(C4, B5, B5, 71), V(AA, 66, 66, CC), \</span>
<span id="L172"><span class="lineNum">     172</span>              :     V(D8, 48, 48, 90), V(05, 03, 03, 06), V(01, F6, F6, F7), V(12, 0E, 0E, 1C), \</span>
<span id="L173"><span class="lineNum">     173</span>              :     V(A3, 61, 61, C2), V(5F, 35, 35, 6A), V(F9, 57, 57, AE), V(D0, B9, B9, 69), \</span>
<span id="L174"><span class="lineNum">     174</span>              :     V(91, 86, 86, 17), V(58, C1, C1, 99), V(27, 1D, 1D, 3A), V(B9, 9E, 9E, 27), \</span>
<span id="L175"><span class="lineNum">     175</span>              :     V(38, E1, E1, D9), V(13, F8, F8, EB), V(B3, 98, 98, 2B), V(33, 11, 11, 22), \</span>
<span id="L176"><span class="lineNum">     176</span>              :     V(BB, 69, 69, D2), V(70, D9, D9, A9), V(89, 8E, 8E, 07), V(A7, 94, 94, 33), \</span>
<span id="L177"><span class="lineNum">     177</span>              :     V(B6, 9B, 9B, 2D), V(22, 1E, 1E, 3C), V(92, 87, 87, 15), V(20, E9, E9, C9), \</span>
<span id="L178"><span class="lineNum">     178</span>              :     V(49, CE, CE, 87), V(FF, 55, 55, AA), V(78, 28, 28, 50), V(7A, DF, DF, A5), \</span>
<span id="L179"><span class="lineNum">     179</span>              :     V(8F, 8C, 8C, 03), V(F8, A1, A1, 59), V(80, 89, 89, 09), V(17, 0D, 0D, 1A), \</span>
<span id="L180"><span class="lineNum">     180</span>              :     V(DA, BF, BF, 65), V(31, E6, E6, D7), V(C6, 42, 42, 84), V(B8, 68, 68, D0), \</span>
<span id="L181"><span class="lineNum">     181</span>              :     V(C3, 41, 41, 82), V(B0, 99, 99, 29), V(77, 2D, 2D, 5A), V(11, 0F, 0F, 1E), \</span>
<span id="L182"><span class="lineNum">     182</span>              :     V(CB, B0, B0, 7B), V(FC, 54, 54, A8), V(D6, BB, BB, 6D), V(3A, 16, 16, 2C)</span>
<span id="L183"><span class="lineNum">     183</span>              : </span>
<span id="L184"><span class="lineNum">     184</span>              : #define V(a, b, c, d) 0x##a##b##c##d</span>
<span id="L185"><span class="lineNum">     185</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t FT0[256] = { FT };</span>
<span id="L186"><span class="lineNum">     186</span>              : #undef V</span>
<span id="L187"><span class="lineNum">     187</span>              : </span>
<span id="L188"><span class="lineNum">     188</span>              : #define V(a, b, c, d) 0x##b##c##d##a</span>
<span id="L189"><span class="lineNum">     189</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t FT1[256] = { FT };</span>
<span id="L190"><span class="lineNum">     190</span>              : #undef V</span>
<span id="L191"><span class="lineNum">     191</span>              : </span>
<span id="L192"><span class="lineNum">     192</span>              : #define V(a, b, c, d) 0x##c##d##a##b</span>
<span id="L193"><span class="lineNum">     193</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t FT2[256] = { FT };</span>
<span id="L194"><span class="lineNum">     194</span>              : #undef V</span>
<span id="L195"><span class="lineNum">     195</span>              : </span>
<span id="L196"><span class="lineNum">     196</span>              : #define V(a, b, c, d) 0x##d##a##b##c</span>
<span id="L197"><span class="lineNum">     197</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t FT3[256] = { FT };</span>
<span id="L198"><span class="lineNum">     198</span>              : #undef V</span>
<span id="L199"><span class="lineNum">     199</span>              : </span>
<span id="L200"><span class="lineNum">     200</span>              : #undef FT</span>
<span id="L201"><span class="lineNum">     201</span>              : </span>
<span id="L202"><span class="lineNum">     202</span>              : /*</span>
<span id="L203"><span class="lineNum">     203</span>              :  * Reverse S-box</span>
<span id="L204"><span class="lineNum">     204</span>              :  */</span>
<span id="L205"><span class="lineNum">     205</span>              : MBEDTLS_MAYBE_UNUSED static const unsigned char RSb[256] =</span>
<span id="L206"><span class="lineNum">     206</span>              : {</span>
<span id="L207"><span class="lineNum">     207</span>              :     0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38,</span>
<span id="L208"><span class="lineNum">     208</span>              :     0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB,</span>
<span id="L209"><span class="lineNum">     209</span>              :     0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87,</span>
<span id="L210"><span class="lineNum">     210</span>              :     0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB,</span>
<span id="L211"><span class="lineNum">     211</span>              :     0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D,</span>
<span id="L212"><span class="lineNum">     212</span>              :     0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E,</span>
<span id="L213"><span class="lineNum">     213</span>              :     0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2,</span>
<span id="L214"><span class="lineNum">     214</span>              :     0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25,</span>
<span id="L215"><span class="lineNum">     215</span>              :     0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16,</span>
<span id="L216"><span class="lineNum">     216</span>              :     0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92,</span>
<span id="L217"><span class="lineNum">     217</span>              :     0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA,</span>
<span id="L218"><span class="lineNum">     218</span>              :     0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84,</span>
<span id="L219"><span class="lineNum">     219</span>              :     0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A,</span>
<span id="L220"><span class="lineNum">     220</span>              :     0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06,</span>
<span id="L221"><span class="lineNum">     221</span>              :     0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02,</span>
<span id="L222"><span class="lineNum">     222</span>              :     0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B,</span>
<span id="L223"><span class="lineNum">     223</span>              :     0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA,</span>
<span id="L224"><span class="lineNum">     224</span>              :     0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73,</span>
<span id="L225"><span class="lineNum">     225</span>              :     0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85,</span>
<span id="L226"><span class="lineNum">     226</span>              :     0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E,</span>
<span id="L227"><span class="lineNum">     227</span>              :     0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89,</span>
<span id="L228"><span class="lineNum">     228</span>              :     0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B,</span>
<span id="L229"><span class="lineNum">     229</span>              :     0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20,</span>
<span id="L230"><span class="lineNum">     230</span>              :     0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4,</span>
<span id="L231"><span class="lineNum">     231</span>              :     0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31,</span>
<span id="L232"><span class="lineNum">     232</span>              :     0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F,</span>
<span id="L233"><span class="lineNum">     233</span>              :     0x60, 0x51, 0x7F, 0xA9, 0x19, 0xB5, 0x4A, 0x0D,</span>
<span id="L234"><span class="lineNum">     234</span>              :     0x2D, 0xE5, 0x7A, 0x9F, 0x93, 0xC9, 0x9C, 0xEF,</span>
<span id="L235"><span class="lineNum">     235</span>              :     0xA0, 0xE0, 0x3B, 0x4D, 0xAE, 0x2A, 0xF5, 0xB0,</span>
<span id="L236"><span class="lineNum">     236</span>              :     0xC8, 0xEB, 0xBB, 0x3C, 0x83, 0x53, 0x99, 0x61,</span>
<span id="L237"><span class="lineNum">     237</span>              :     0x17, 0x2B, 0x04, 0x7E, 0xBA, 0x77, 0xD6, 0x26,</span>
<span id="L238"><span class="lineNum">     238</span>              :     0xE1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0C, 0x7D</span>
<span id="L239"><span class="lineNum">     239</span>              : };</span>
<span id="L240"><span class="lineNum">     240</span>              : </span>
<span id="L241"><span class="lineNum">     241</span>              : /*</span>
<span id="L242"><span class="lineNum">     242</span>              :  * Reverse tables</span>
<span id="L243"><span class="lineNum">     243</span>              :  */</span>
<span id="L244"><span class="lineNum">     244</span>              : #define RT \</span>
<span id="L245"><span class="lineNum">     245</span>              : \</span>
<span id="L246"><span class="lineNum">     246</span>              :     V(50, A7, F4, 51), V(53, 65, 41, 7E), V(C3, A4, 17, 1A), V(96, 5E, 27, 3A), \</span>
<span id="L247"><span class="lineNum">     247</span>              :     V(CB, 6B, AB, 3B), V(F1, 45, 9D, 1F), V(AB, 58, FA, AC), V(93, 03, E3, 4B), \</span>
<span id="L248"><span class="lineNum">     248</span>              :     V(55, FA, 30, 20), V(F6, 6D, 76, AD), V(91, 76, CC, 88), V(25, 4C, 02, F5), \</span>
<span id="L249"><span class="lineNum">     249</span>              :     V(FC, D7, E5, 4F), V(D7, CB, 2A, C5), V(80, 44, 35, 26), V(8F, A3, 62, B5), \</span>
<span id="L250"><span class="lineNum">     250</span>              :     V(49, 5A, B1, DE), V(67, 1B, BA, 25), V(98, 0E, EA, 45), V(E1, C0, FE, 5D), \</span>
<span id="L251"><span class="lineNum">     251</span>              :     V(02, 75, 2F, C3), V(12, F0, 4C, 81), V(A3, 97, 46, 8D), V(C6, F9, D3, 6B), \</span>
<span id="L252"><span class="lineNum">     252</span>              :     V(E7, 5F, 8F, 03), V(95, 9C, 92, 15), V(EB, 7A, 6D, BF), V(DA, 59, 52, 95), \</span>
<span id="L253"><span class="lineNum">     253</span>              :     V(2D, 83, BE, D4), V(D3, 21, 74, 58), V(29, 69, E0, 49), V(44, C8, C9, 8E), \</span>
<span id="L254"><span class="lineNum">     254</span>              :     V(6A, 89, C2, 75), V(78, 79, 8E, F4), V(6B, 3E, 58, 99), V(DD, 71, B9, 27), \</span>
<span id="L255"><span class="lineNum">     255</span>              :     V(B6, 4F, E1, BE), V(17, AD, 88, F0), V(66, AC, 20, C9), V(B4, 3A, CE, 7D), \</span>
<span id="L256"><span class="lineNum">     256</span>              :     V(18, 4A, DF, 63), V(82, 31, 1A, E5), V(60, 33, 51, 97), V(45, 7F, 53, 62), \</span>
<span id="L257"><span class="lineNum">     257</span>              :     V(E0, 77, 64, B1), V(84, AE, 6B, BB), V(1C, A0, 81, FE), V(94, 2B, 08, F9), \</span>
<span id="L258"><span class="lineNum">     258</span>              :     V(58, 68, 48, 70), V(19, FD, 45, 8F), V(87, 6C, DE, 94), V(B7, F8, 7B, 52), \</span>
<span id="L259"><span class="lineNum">     259</span>              :     V(23, D3, 73, AB), V(E2, 02, 4B, 72), V(57, 8F, 1F, E3), V(2A, AB, 55, 66), \</span>
<span id="L260"><span class="lineNum">     260</span>              :     V(07, 28, EB, B2), V(03, C2, B5, 2F), V(9A, 7B, C5, 86), V(A5, 08, 37, D3), \</span>
<span id="L261"><span class="lineNum">     261</span>              :     V(F2, 87, 28, 30), V(B2, A5, BF, 23), V(BA, 6A, 03, 02), V(5C, 82, 16, ED), \</span>
<span id="L262"><span class="lineNum">     262</span>              :     V(2B, 1C, CF, 8A), V(92, B4, 79, A7), V(F0, F2, 07, F3), V(A1, E2, 69, 4E), \</span>
<span id="L263"><span class="lineNum">     263</span>              :     V(CD, F4, DA, 65), V(D5, BE, 05, 06), V(1F, 62, 34, D1), V(8A, FE, A6, C4), \</span>
<span id="L264"><span class="lineNum">     264</span>              :     V(9D, 53, 2E, 34), V(A0, 55, F3, A2), V(32, E1, 8A, 05), V(75, EB, F6, A4), \</span>
<span id="L265"><span class="lineNum">     265</span>              :     V(39, EC, 83, 0B), V(AA, EF, 60, 40), V(06, 9F, 71, 5E), V(51, 10, 6E, BD), \</span>
<span id="L266"><span class="lineNum">     266</span>              :     V(F9, 8A, 21, 3E), V(3D, 06, DD, 96), V(AE, 05, 3E, DD), V(46, BD, E6, 4D), \</span>
<span id="L267"><span class="lineNum">     267</span>              :     V(B5, 8D, 54, 91), V(05, 5D, C4, 71), V(6F, D4, 06, 04), V(FF, 15, 50, 60), \</span>
<span id="L268"><span class="lineNum">     268</span>              :     V(24, FB, 98, 19), V(97, E9, BD, D6), V(CC, 43, 40, 89), V(77, 9E, D9, 67), \</span>
<span id="L269"><span class="lineNum">     269</span>              :     V(BD, 42, E8, B0), V(88, 8B, 89, 07), V(38, 5B, 19, E7), V(DB, EE, C8, 79), \</span>
<span id="L270"><span class="lineNum">     270</span>              :     V(47, 0A, 7C, A1), V(E9, 0F, 42, 7C), V(C9, 1E, 84, F8), V(00, 00, 00, 00), \</span>
<span id="L271"><span class="lineNum">     271</span>              :     V(83, 86, 80, 09), V(48, ED, 2B, 32), V(AC, 70, 11, 1E), V(4E, 72, 5A, 6C), \</span>
<span id="L272"><span class="lineNum">     272</span>              :     V(FB, FF, 0E, FD), V(56, 38, 85, 0F), V(1E, D5, AE, 3D), V(27, 39, 2D, 36), \</span>
<span id="L273"><span class="lineNum">     273</span>              :     V(64, D9, 0F, 0A), V(21, A6, 5C, 68), V(D1, 54, 5B, 9B), V(3A, 2E, 36, 24), \</span>
<span id="L274"><span class="lineNum">     274</span>              :     V(B1, 67, 0A, 0C), V(0F, E7, 57, 93), V(D2, 96, EE, B4), V(9E, 91, 9B, 1B), \</span>
<span id="L275"><span class="lineNum">     275</span>              :     V(4F, C5, C0, 80), V(A2, 20, DC, 61), V(69, 4B, 77, 5A), V(16, 1A, 12, 1C), \</span>
<span id="L276"><span class="lineNum">     276</span>              :     V(0A, BA, 93, E2), V(E5, 2A, A0, C0), V(43, E0, 22, 3C), V(1D, 17, 1B, 12), \</span>
<span id="L277"><span class="lineNum">     277</span>              :     V(0B, 0D, 09, 0E), V(AD, C7, 8B, F2), V(B9, A8, B6, 2D), V(C8, A9, 1E, 14), \</span>
<span id="L278"><span class="lineNum">     278</span>              :     V(85, 19, F1, 57), V(4C, 07, 75, AF), V(BB, DD, 99, EE), V(FD, 60, 7F, A3), \</span>
<span id="L279"><span class="lineNum">     279</span>              :     V(9F, 26, 01, F7), V(BC, F5, 72, 5C), V(C5, 3B, 66, 44), V(34, 7E, FB, 5B), \</span>
<span id="L280"><span class="lineNum">     280</span>              :     V(76, 29, 43, 8B), V(DC, C6, 23, CB), V(68, FC, ED, B6), V(63, F1, E4, B8), \</span>
<span id="L281"><span class="lineNum">     281</span>              :     V(CA, DC, 31, D7), V(10, 85, 63, 42), V(40, 22, 97, 13), V(20, 11, C6, 84), \</span>
<span id="L282"><span class="lineNum">     282</span>              :     V(7D, 24, 4A, 85), V(F8, 3D, BB, D2), V(11, 32, F9, AE), V(6D, A1, 29, C7), \</span>
<span id="L283"><span class="lineNum">     283</span>              :     V(4B, 2F, 9E, 1D), V(F3, 30, B2, DC), V(EC, 52, 86, 0D), V(D0, E3, C1, 77), \</span>
<span id="L284"><span class="lineNum">     284</span>              :     V(6C, 16, B3, 2B), V(99, B9, 70, A9), V(FA, 48, 94, 11), V(22, 64, E9, 47), \</span>
<span id="L285"><span class="lineNum">     285</span>              :     V(C4, 8C, FC, A8), V(1A, 3F, F0, A0), V(D8, 2C, 7D, 56), V(EF, 90, 33, 22), \</span>
<span id="L286"><span class="lineNum">     286</span>              :     V(C7, 4E, 49, 87), V(C1, D1, 38, D9), V(FE, A2, CA, 8C), V(36, 0B, D4, 98), \</span>
<span id="L287"><span class="lineNum">     287</span>              :     V(CF, 81, F5, A6), V(28, DE, 7A, A5), V(26, 8E, B7, DA), V(A4, BF, AD, 3F), \</span>
<span id="L288"><span class="lineNum">     288</span>              :     V(E4, 9D, 3A, 2C), V(0D, 92, 78, 50), V(9B, CC, 5F, 6A), V(62, 46, 7E, 54), \</span>
<span id="L289"><span class="lineNum">     289</span>              :     V(C2, 13, 8D, F6), V(E8, B8, D8, 90), V(5E, F7, 39, 2E), V(F5, AF, C3, 82), \</span>
<span id="L290"><span class="lineNum">     290</span>              :     V(BE, 80, 5D, 9F), V(7C, 93, D0, 69), V(A9, 2D, D5, 6F), V(B3, 12, 25, CF), \</span>
<span id="L291"><span class="lineNum">     291</span>              :     V(3B, 99, AC, C8), V(A7, 7D, 18, 10), V(6E, 63, 9C, E8), V(7B, BB, 3B, DB), \</span>
<span id="L292"><span class="lineNum">     292</span>              :     V(09, 78, 26, CD), V(F4, 18, 59, 6E), V(01, B7, 9A, EC), V(A8, 9A, 4F, 83), \</span>
<span id="L293"><span class="lineNum">     293</span>              :     V(65, 6E, 95, E6), V(7E, E6, FF, AA), V(08, CF, BC, 21), V(E6, E8, 15, EF), \</span>
<span id="L294"><span class="lineNum">     294</span>              :     V(D9, 9B, E7, BA), V(CE, 36, 6F, 4A), V(D4, 09, 9F, EA), V(D6, 7C, B0, 29), \</span>
<span id="L295"><span class="lineNum">     295</span>              :     V(AF, B2, A4, 31), V(31, 23, 3F, 2A), V(30, 94, A5, C6), V(C0, 66, A2, 35), \</span>
<span id="L296"><span class="lineNum">     296</span>              :     V(37, BC, 4E, 74), V(A6, CA, 82, FC), V(B0, D0, 90, E0), V(15, D8, A7, 33), \</span>
<span id="L297"><span class="lineNum">     297</span>              :     V(4A, 98, 04, F1), V(F7, DA, EC, 41), V(0E, 50, CD, 7F), V(2F, F6, 91, 17), \</span>
<span id="L298"><span class="lineNum">     298</span>              :     V(8D, D6, 4D, 76), V(4D, B0, EF, 43), V(54, 4D, AA, CC), V(DF, 04, 96, E4), \</span>
<span id="L299"><span class="lineNum">     299</span>              :     V(E3, B5, D1, 9E), V(1B, 88, 6A, 4C), V(B8, 1F, 2C, C1), V(7F, 51, 65, 46), \</span>
<span id="L300"><span class="lineNum">     300</span>              :     V(04, EA, 5E, 9D), V(5D, 35, 8C, 01), V(73, 74, 87, FA), V(2E, 41, 0B, FB), \</span>
<span id="L301"><span class="lineNum">     301</span>              :     V(5A, 1D, 67, B3), V(52, D2, DB, 92), V(33, 56, 10, E9), V(13, 47, D6, 6D), \</span>
<span id="L302"><span class="lineNum">     302</span>              :     V(8C, 61, D7, 9A), V(7A, 0C, A1, 37), V(8E, 14, F8, 59), V(89, 3C, 13, EB), \</span>
<span id="L303"><span class="lineNum">     303</span>              :     V(EE, 27, A9, CE), V(35, C9, 61, B7), V(ED, E5, 1C, E1), V(3C, B1, 47, 7A), \</span>
<span id="L304"><span class="lineNum">     304</span>              :     V(59, DF, D2, 9C), V(3F, 73, F2, 55), V(79, CE, 14, 18), V(BF, 37, C7, 73), \</span>
<span id="L305"><span class="lineNum">     305</span>              :     V(EA, CD, F7, 53), V(5B, AA, FD, 5F), V(14, 6F, 3D, DF), V(86, DB, 44, 78), \</span>
<span id="L306"><span class="lineNum">     306</span>              :     V(81, F3, AF, CA), V(3E, C4, 68, B9), V(2C, 34, 24, 38), V(5F, 40, A3, C2), \</span>
<span id="L307"><span class="lineNum">     307</span>              :     V(72, C3, 1D, 16), V(0C, 25, E2, BC), V(8B, 49, 3C, 28), V(41, 95, 0D, FF), \</span>
<span id="L308"><span class="lineNum">     308</span>              :     V(71, 01, A8, 39), V(DE, B3, 0C, 08), V(9C, E4, B4, D8), V(90, C1, 56, 64), \</span>
<span id="L309"><span class="lineNum">     309</span>              :     V(61, 84, CB, 7B), V(70, B6, 32, D5), V(74, 5C, 6C, 48), V(42, 57, B8, D0)</span>
<span id="L310"><span class="lineNum">     310</span>              : </span>
<span id="L311"><span class="lineNum">     311</span>              : </span>
<span id="L312"><span class="lineNum">     312</span>              : #define V(a, b, c, d) 0x##a##b##c##d</span>
<span id="L313"><span class="lineNum">     313</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t RT0[256] = { RT };</span>
<span id="L314"><span class="lineNum">     314</span>              : #undef V</span>
<span id="L315"><span class="lineNum">     315</span>              : </span>
<span id="L316"><span class="lineNum">     316</span>              : #define V(a, b, c, d) 0x##b##c##d##a</span>
<span id="L317"><span class="lineNum">     317</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t RT1[256] = { RT };</span>
<span id="L318"><span class="lineNum">     318</span>              : #undef V</span>
<span id="L319"><span class="lineNum">     319</span>              : </span>
<span id="L320"><span class="lineNum">     320</span>              : #define V(a, b, c, d) 0x##c##d##a##b</span>
<span id="L321"><span class="lineNum">     321</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t RT2[256] = { RT };</span>
<span id="L322"><span class="lineNum">     322</span>              : #undef V</span>
<span id="L323"><span class="lineNum">     323</span>              : </span>
<span id="L324"><span class="lineNum">     324</span>              : #define V(a, b, c, d) 0x##d##a##b##c</span>
<span id="L325"><span class="lineNum">     325</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t RT3[256] = { RT };</span>
<span id="L326"><span class="lineNum">     326</span>              : #undef V</span>
<span id="L327"><span class="lineNum">     327</span>              : </span>
<span id="L328"><span class="lineNum">     328</span>              : #undef RT</span>
<span id="L329"><span class="lineNum">     329</span>              : </span>
<span id="L330"><span class="lineNum">     330</span>              : /*</span>
<span id="L331"><span class="lineNum">     331</span>              :  * Round constants</span>
<span id="L332"><span class="lineNum">     332</span>              :  */</span>
<span id="L333"><span class="lineNum">     333</span>              : MBEDTLS_MAYBE_UNUSED static const uint32_t round_constants[10] =</span>
<span id="L334"><span class="lineNum">     334</span>              : {</span>
<span id="L335"><span class="lineNum">     335</span>              :     0x00000001, 0x00000002, 0x00000004, 0x00000008,</span>
<span id="L336"><span class="lineNum">     336</span>              :     0x00000010, 0x00000020, 0x00000040, 0x00000080,</span>
<span id="L337"><span class="lineNum">     337</span>              :     0x0000001B, 0x00000036</span>
<span id="L338"><span class="lineNum">     338</span>              : };</span>
<span id="L339"><span class="lineNum">     339</span>              : </span>
<span id="L340"><span class="lineNum">     340</span>              : #else /* MBEDTLS_AES_ROM_TABLES */</span>
<span id="L341"><span class="lineNum">     341</span>              : </span>
<span id="L342"><span class="lineNum">     342</span>              : /*</span>
<span id="L343"><span class="lineNum">     343</span>              :  * Forward S-box &amp; tables</span>
<span id="L344"><span class="lineNum">     344</span>              :  */</span>
<span id="L345"><span class="lineNum">     345</span>              : MBEDTLS_MAYBE_UNUSED static unsigned char FSb[256];</span>
<span id="L346"><span class="lineNum">     346</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t FT0[256];</span>
<span id="L347"><span class="lineNum">     347</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t FT1[256];</span>
<span id="L348"><span class="lineNum">     348</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t FT2[256];</span>
<span id="L349"><span class="lineNum">     349</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t FT3[256];</span>
<span id="L350"><span class="lineNum">     350</span>              : </span>
<span id="L351"><span class="lineNum">     351</span>              : /*</span>
<span id="L352"><span class="lineNum">     352</span>              :  * Reverse S-box &amp; tables</span>
<span id="L353"><span class="lineNum">     353</span>              :  */</span>
<span id="L354"><span class="lineNum">     354</span>              : MBEDTLS_MAYBE_UNUSED static unsigned char RSb[256];</span>
<span id="L355"><span class="lineNum">     355</span>              : </span>
<span id="L356"><span class="lineNum">     356</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t RT0[256];</span>
<span id="L357"><span class="lineNum">     357</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t RT1[256];</span>
<span id="L358"><span class="lineNum">     358</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t RT2[256];</span>
<span id="L359"><span class="lineNum">     359</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t RT3[256];</span>
<span id="L360"><span class="lineNum">     360</span>              : </span>
<span id="L361"><span class="lineNum">     361</span>              : /*</span>
<span id="L362"><span class="lineNum">     362</span>              :  * Round constants</span>
<span id="L363"><span class="lineNum">     363</span>              :  */</span>
<span id="L364"><span class="lineNum">     364</span>              : MBEDTLS_MAYBE_UNUSED static uint32_t round_constants[10];</span>
<span id="L365"><span class="lineNum">     365</span>              : </span>
<span id="L366"><span class="lineNum">     366</span>              : /*</span>
<span id="L367"><span class="lineNum">     367</span>              :  * Tables generation code</span>
<span id="L368"><span class="lineNum">     368</span>              :  */</span>
<span id="L369"><span class="lineNum">     369</span>              : #define ROTL8(x) (((x) &lt;&lt; 8) &amp; 0xFFFFFFFF) | ((x) &gt;&gt; 24)</span>
<span id="L370"><span class="lineNum">     370</span>              : #define XTIME(x) (((x) &lt;&lt; 1) ^ (((x) &amp; 0x80) ? 0x1B : 0x00))</span>
<span id="L371"><span class="lineNum">     371</span>              : #define MUL(x, y) (((x) &amp;&amp; (y)) ? pow[(log[(x)]+log[(y)]) % 255] : 0)</span>
<span id="L372"><span class="lineNum">     372</span>              : </span>
<span id="L373"><span class="lineNum">     373</span>              : MBEDTLS_MAYBE_UNUSED static int aes_init_done = 0;</span>
<span id="L374"><span class="lineNum">     374</span>              : </span>
<span id="L375"><span class="lineNum">     375</span> <span class="tlaGNC tlaBgGNC">           2 : MBEDTLS_MAYBE_UNUSED static void aes_gen_tables(void)</span></span>
<span id="L376"><span class="lineNum">     376</span>              : {</span>
<span id="L377"><span class="lineNum">     377</span>              :     int i;</span>
<span id="L378"><span class="lineNum">     378</span>              :     uint8_t x, y, z;</span>
<span id="L379"><span class="lineNum">     379</span>              :     uint8_t pow[256];</span>
<span id="L380"><span class="lineNum">     380</span>              :     uint8_t log[256];</span>
<span id="L381"><span class="lineNum">     381</span>              : </span>
<span id="L382"><span class="lineNum">     382</span>              :     /*</span>
<span id="L383"><span class="lineNum">     383</span>              :      * compute pow and log tables over GF(2^8)</span>
<span id="L384"><span class="lineNum">     384</span>              :      */</span>
<span id="L385"><span class="lineNum">     385</span> <span class="tlaGNC">         514 :     for (i = 0, x = 1; i &lt; 256; i++) {</span></span>
<span id="L386"><span class="lineNum">     386</span> <span class="tlaGNC">         512 :         pow[i] = x;</span></span>
<span id="L387"><span class="lineNum">     387</span> <span class="tlaGNC">         512 :         log[x] = (uint8_t) i;</span></span>
<span id="L388"><span class="lineNum">     388</span> <span class="tlaGNC">         512 :         x ^= XTIME(x);</span></span>
<span id="L389"><span class="lineNum">     389</span>              :     }</span>
<span id="L390"><span class="lineNum">     390</span>              : </span>
<span id="L391"><span class="lineNum">     391</span>              :     /*</span>
<span id="L392"><span class="lineNum">     392</span>              :      * calculate the round constants</span>
<span id="L393"><span class="lineNum">     393</span>              :      */</span>
<span id="L394"><span class="lineNum">     394</span> <span class="tlaGNC">          22 :     for (i = 0, x = 1; i &lt; 10; i++) {</span></span>
<span id="L395"><span class="lineNum">     395</span> <span class="tlaGNC">          20 :         round_constants[i] = x;</span></span>
<span id="L396"><span class="lineNum">     396</span> <span class="tlaGNC">          20 :         x = XTIME(x);</span></span>
<span id="L397"><span class="lineNum">     397</span>              :     }</span>
<span id="L398"><span class="lineNum">     398</span>              : </span>
<span id="L399"><span class="lineNum">     399</span>              :     /*</span>
<span id="L400"><span class="lineNum">     400</span>              :      * generate the forward and reverse S-boxes</span>
<span id="L401"><span class="lineNum">     401</span>              :      */</span>
<span id="L402"><span class="lineNum">     402</span> <span class="tlaGNC">           2 :     FSb[0x00] = 0x63;</span></span>
<span id="L403"><span class="lineNum">     403</span>              : #if defined(MBEDTLS_AES_NEED_REVERSE_TABLES)</span>
<span id="L404"><span class="lineNum">     404</span> <span class="tlaGNC">           2 :     RSb[0x63] = 0x00;</span></span>
<span id="L405"><span class="lineNum">     405</span>              : #endif</span>
<span id="L406"><span class="lineNum">     406</span>              : </span>
<span id="L407"><span class="lineNum">     407</span> <span class="tlaGNC">         512 :     for (i = 1; i &lt; 256; i++) {</span></span>
<span id="L408"><span class="lineNum">     408</span> <span class="tlaGNC">         510 :         x = pow[255 - log[i]];</span></span>
<span id="L409"><span class="lineNum">     409</span>              : </span>
<span id="L410"><span class="lineNum">     410</span> <span class="tlaGNC">         510 :         y  = x; y = (y &lt;&lt; 1) | (y &gt;&gt; 7);</span></span>
<span id="L411"><span class="lineNum">     411</span> <span class="tlaGNC">         510 :         x ^= y; y = (y &lt;&lt; 1) | (y &gt;&gt; 7);</span></span>
<span id="L412"><span class="lineNum">     412</span> <span class="tlaGNC">         510 :         x ^= y; y = (y &lt;&lt; 1) | (y &gt;&gt; 7);</span></span>
<span id="L413"><span class="lineNum">     413</span> <span class="tlaGNC">         510 :         x ^= y; y = (y &lt;&lt; 1) | (y &gt;&gt; 7);</span></span>
<span id="L414"><span class="lineNum">     414</span> <span class="tlaGNC">         510 :         x ^= y ^ 0x63;</span></span>
<span id="L415"><span class="lineNum">     415</span>              : </span>
<span id="L416"><span class="lineNum">     416</span> <span class="tlaGNC">         510 :         FSb[i] = x;</span></span>
<span id="L417"><span class="lineNum">     417</span>              : #if defined(MBEDTLS_AES_NEED_REVERSE_TABLES)</span>
<span id="L418"><span class="lineNum">     418</span> <span class="tlaGNC">         510 :         RSb[x] = (unsigned char) i;</span></span>
<span id="L419"><span class="lineNum">     419</span>              : #endif</span>
<span id="L420"><span class="lineNum">     420</span>              :     }</span>
<span id="L421"><span class="lineNum">     421</span>              : </span>
<span id="L422"><span class="lineNum">     422</span>              :     /*</span>
<span id="L423"><span class="lineNum">     423</span>              :      * generate the forward and reverse tables</span>
<span id="L424"><span class="lineNum">     424</span>              :      */</span>
<span id="L425"><span class="lineNum">     425</span> <span class="tlaGNC">         514 :     for (i = 0; i &lt; 256; i++) {</span></span>
<span id="L426"><span class="lineNum">     426</span> <span class="tlaGNC">         512 :         x = FSb[i];</span></span>
<span id="L427"><span class="lineNum">     427</span> <span class="tlaGNC">         512 :         y = XTIME(x);</span></span>
<span id="L428"><span class="lineNum">     428</span> <span class="tlaGNC">         512 :         z = y ^ x;</span></span>
<span id="L429"><span class="lineNum">     429</span>              : </span>
<span id="L430"><span class="lineNum">     430</span> <span class="tlaGNC">         512 :         FT0[i] = ((uint32_t) y) ^</span></span>
<span id="L431"><span class="lineNum">     431</span> <span class="tlaGNC">         512 :                  ((uint32_t) x &lt;&lt;  8) ^</span></span>
<span id="L432"><span class="lineNum">     432</span> <span class="tlaGNC">         512 :                  ((uint32_t) x &lt;&lt; 16) ^</span></span>
<span id="L433"><span class="lineNum">     433</span> <span class="tlaGNC">         512 :                  ((uint32_t) z &lt;&lt; 24);</span></span>
<span id="L434"><span class="lineNum">     434</span>              : </span>
<span id="L435"><span class="lineNum">     435</span>              : #if !defined(MBEDTLS_AES_FEWER_TABLES)</span>
<span id="L436"><span class="lineNum">     436</span> <span class="tlaGNC">         512 :         FT1[i] = ROTL8(FT0[i]);</span></span>
<span id="L437"><span class="lineNum">     437</span> <span class="tlaGNC">         512 :         FT2[i] = ROTL8(FT1[i]);</span></span>
<span id="L438"><span class="lineNum">     438</span> <span class="tlaGNC">         512 :         FT3[i] = ROTL8(FT2[i]);</span></span>
<span id="L439"><span class="lineNum">     439</span>              : #endif /* !MBEDTLS_AES_FEWER_TABLES */</span>
<span id="L440"><span class="lineNum">     440</span>              : </span>
<span id="L441"><span class="lineNum">     441</span>              : #if defined(MBEDTLS_AES_NEED_REVERSE_TABLES)</span>
<span id="L442"><span class="lineNum">     442</span> <span class="tlaGNC">         512 :         x = RSb[i];</span></span>
<span id="L443"><span class="lineNum">     443</span>              : </span>
<span id="L444"><span class="lineNum">     444</span> <span class="tlaGNC">         512 :         RT0[i] = ((uint32_t) MUL(0x0E, x)) ^</span></span>
<span id="L445"><span class="lineNum">     445</span> <span class="tlaGNC">         512 :                  ((uint32_t) MUL(0x09, x) &lt;&lt;  8) ^</span></span>
<span id="L446"><span class="lineNum">     446</span> <span class="tlaGNC">         512 :                  ((uint32_t) MUL(0x0D, x) &lt;&lt; 16) ^</span></span>
<span id="L447"><span class="lineNum">     447</span> <span class="tlaGNC">         512 :                  ((uint32_t) MUL(0x0B, x) &lt;&lt; 24);</span></span>
<span id="L448"><span class="lineNum">     448</span>              : </span>
<span id="L449"><span class="lineNum">     449</span>              : #if !defined(MBEDTLS_AES_FEWER_TABLES)</span>
<span id="L450"><span class="lineNum">     450</span> <span class="tlaGNC">         512 :         RT1[i] = ROTL8(RT0[i]);</span></span>
<span id="L451"><span class="lineNum">     451</span> <span class="tlaGNC">         512 :         RT2[i] = ROTL8(RT1[i]);</span></span>
<span id="L452"><span class="lineNum">     452</span> <span class="tlaGNC">         512 :         RT3[i] = ROTL8(RT2[i]);</span></span>
<span id="L453"><span class="lineNum">     453</span>              : #endif /* !MBEDTLS_AES_FEWER_TABLES */</span>
<span id="L454"><span class="lineNum">     454</span>              : #endif /* MBEDTLS_AES_NEED_REVERSE_TABLES */</span>
<span id="L455"><span class="lineNum">     455</span>              :     }</span>
<span id="L456"><span class="lineNum">     456</span> <span class="tlaGNC">           2 : }</span></span>
<span id="L457"><span class="lineNum">     457</span>              : </span>
<span id="L458"><span class="lineNum">     458</span>              : #undef ROTL8</span>
<span id="L459"><span class="lineNum">     459</span>              : </span>
<span id="L460"><span class="lineNum">     460</span>              : #endif /* MBEDTLS_AES_ROM_TABLES */</span>
<span id="L461"><span class="lineNum">     461</span>              : </span>
<span id="L462"><span class="lineNum">     462</span>              : #if defined(MBEDTLS_AES_FEWER_TABLES)</span>
<span id="L463"><span class="lineNum">     463</span>              : </span>
<span id="L464"><span class="lineNum">     464</span>              : #define ROTL8(x)  ((uint32_t) ((x) &lt;&lt;  8) + (uint32_t) ((x) &gt;&gt; 24))</span>
<span id="L465"><span class="lineNum">     465</span>              : #define ROTL16(x) ((uint32_t) ((x) &lt;&lt; 16) + (uint32_t) ((x) &gt;&gt; 16))</span>
<span id="L466"><span class="lineNum">     466</span>              : #define ROTL24(x) ((uint32_t) ((x) &lt;&lt; 24) + (uint32_t) ((x) &gt;&gt;  8))</span>
<span id="L467"><span class="lineNum">     467</span>              : </span>
<span id="L468"><span class="lineNum">     468</span>              : #define AES_RT0(idx) RT0[idx]</span>
<span id="L469"><span class="lineNum">     469</span>              : #define AES_RT1(idx) ROTL8(RT0[idx])</span>
<span id="L470"><span class="lineNum">     470</span>              : #define AES_RT2(idx) ROTL16(RT0[idx])</span>
<span id="L471"><span class="lineNum">     471</span>              : #define AES_RT3(idx) ROTL24(RT0[idx])</span>
<span id="L472"><span class="lineNum">     472</span>              : </span>
<span id="L473"><span class="lineNum">     473</span>              : #define AES_FT0(idx) FT0[idx]</span>
<span id="L474"><span class="lineNum">     474</span>              : #define AES_FT1(idx) ROTL8(FT0[idx])</span>
<span id="L475"><span class="lineNum">     475</span>              : #define AES_FT2(idx) ROTL16(FT0[idx])</span>
<span id="L476"><span class="lineNum">     476</span>              : #define AES_FT3(idx) ROTL24(FT0[idx])</span>
<span id="L477"><span class="lineNum">     477</span>              : </span>
<span id="L478"><span class="lineNum">     478</span>              : #else /* MBEDTLS_AES_FEWER_TABLES */</span>
<span id="L479"><span class="lineNum">     479</span>              : </span>
<span id="L480"><span class="lineNum">     480</span>              : #define AES_RT0(idx) RT0[idx]</span>
<span id="L481"><span class="lineNum">     481</span>              : #define AES_RT1(idx) RT1[idx]</span>
<span id="L482"><span class="lineNum">     482</span>              : #define AES_RT2(idx) RT2[idx]</span>
<span id="L483"><span class="lineNum">     483</span>              : #define AES_RT3(idx) RT3[idx]</span>
<span id="L484"><span class="lineNum">     484</span>              : </span>
<span id="L485"><span class="lineNum">     485</span>              : #define AES_FT0(idx) FT0[idx]</span>
<span id="L486"><span class="lineNum">     486</span>              : #define AES_FT1(idx) FT1[idx]</span>
<span id="L487"><span class="lineNum">     487</span>              : #define AES_FT2(idx) FT2[idx]</span>
<span id="L488"><span class="lineNum">     488</span>              : #define AES_FT3(idx) FT3[idx]</span>
<span id="L489"><span class="lineNum">     489</span>              : </span>
<span id="L490"><span class="lineNum">     490</span>              : #endif /* MBEDTLS_AES_FEWER_TABLES */</span>
<span id="L491"><span class="lineNum">     491</span>              : </span>
<span id="L492"><span class="lineNum">     492</span> <span class="tlaGNC">         819 : void mbedtls_aes_init(mbedtls_aes_context *ctx)</span></span>
<span id="L493"><span class="lineNum">     493</span>              : {</span>
<span id="L494"><span class="lineNum">     494</span> <span class="tlaGNC">         819 :     memset(ctx, 0, sizeof(mbedtls_aes_context));</span></span>
<span id="L495"><span class="lineNum">     495</span> <span class="tlaGNC">         819 : }</span></span>
<span id="L496"><span class="lineNum">     496</span>              : </span>
<span id="L497"><span class="lineNum">     497</span> <span class="tlaGNC">         819 : void mbedtls_aes_free(mbedtls_aes_context *ctx)</span></span>
<span id="L498"><span class="lineNum">     498</span>              : {</span>
<span id="L499"><span class="lineNum">     499</span> <span class="tlaGNC">         819 :     if (ctx == NULL) {</span></span>
<span id="L500"><span class="lineNum">     500</span> <span class="tlaUNC tlaBgUNC">           0 :         return;</span></span>
<span id="L501"><span class="lineNum">     501</span>              :     }</span>
<span id="L502"><span class="lineNum">     502</span>              : </span>
<span id="L503"><span class="lineNum">     503</span> <span class="tlaGNC tlaBgGNC">         819 :     mbedtls_platform_zeroize(ctx, sizeof(mbedtls_aes_context));</span></span>
<span id="L504"><span class="lineNum">     504</span>              : }</span>
<span id="L505"><span class="lineNum">     505</span>              : </span>
<span id="L506"><span class="lineNum">     506</span>              : #if defined(MBEDTLS_CIPHER_MODE_XTS)</span>
<span id="L507"><span class="lineNum">     507</span>              : void mbedtls_aes_xts_init(mbedtls_aes_xts_context *ctx)</span>
<span id="L508"><span class="lineNum">     508</span>              : {</span>
<span id="L509"><span class="lineNum">     509</span>              :     mbedtls_aes_init(&amp;ctx-&gt;crypt);</span>
<span id="L510"><span class="lineNum">     510</span>              :     mbedtls_aes_init(&amp;ctx-&gt;tweak);</span>
<span id="L511"><span class="lineNum">     511</span>              : }</span>
<span id="L512"><span class="lineNum">     512</span>              : </span>
<span id="L513"><span class="lineNum">     513</span>              : void mbedtls_aes_xts_free(mbedtls_aes_xts_context *ctx)</span>
<span id="L514"><span class="lineNum">     514</span>              : {</span>
<span id="L515"><span class="lineNum">     515</span>              :     if (ctx == NULL) {</span>
<span id="L516"><span class="lineNum">     516</span>              :         return;</span>
<span id="L517"><span class="lineNum">     517</span>              :     }</span>
<span id="L518"><span class="lineNum">     518</span>              : </span>
<span id="L519"><span class="lineNum">     519</span>              :     mbedtls_aes_free(&amp;ctx-&gt;crypt);</span>
<span id="L520"><span class="lineNum">     520</span>              :     mbedtls_aes_free(&amp;ctx-&gt;tweak);</span>
<span id="L521"><span class="lineNum">     521</span>              : }</span>
<span id="L522"><span class="lineNum">     522</span>              : #endif /* MBEDTLS_CIPHER_MODE_XTS */</span>
<span id="L523"><span class="lineNum">     523</span>              : </span>
<span id="L524"><span class="lineNum">     524</span>              : /* Some implementations need the round keys to be aligned.</span>
<span id="L525"><span class="lineNum">     525</span>              :  * Return an offset to be added to buf, such that (buf + offset) is</span>
<span id="L526"><span class="lineNum">     526</span>              :  * correctly aligned.</span>
<span id="L527"><span class="lineNum">     527</span>              :  * Note that the offset is in units of elements of buf, i.e. 32-bit words,</span>
<span id="L528"><span class="lineNum">     528</span>              :  * i.e. an offset of 1 means 4 bytes and so on.</span>
<span id="L529"><span class="lineNum">     529</span>              :  */</span>
<span id="L530"><span class="lineNum">     530</span>              : #if (defined(MBEDTLS_VIA_PADLOCK_HAVE_CODE)) ||        \</span>
<span id="L531"><span class="lineNum">     531</span>              :     (defined(MBEDTLS_AESNI_C) &amp;&amp; MBEDTLS_AESNI_HAVE_CODE == 2)</span>
<span id="L532"><span class="lineNum">     532</span>              : #define MAY_NEED_TO_ALIGN</span>
<span id="L533"><span class="lineNum">     533</span>              : #endif</span>
<span id="L534"><span class="lineNum">     534</span>              : </span>
<span id="L535"><span class="lineNum">     535</span> <span class="tlaGNC">         819 : MBEDTLS_MAYBE_UNUSED static unsigned mbedtls_aes_rk_offset(uint32_t *buf)</span></span>
<span id="L536"><span class="lineNum">     536</span>              : {</span>
<span id="L537"><span class="lineNum">     537</span>              : #if defined(MAY_NEED_TO_ALIGN)</span>
<span id="L538"><span class="lineNum">     538</span>              :     int align_16_bytes = 0;</span>
<span id="L539"><span class="lineNum">     539</span>              : </span>
<span id="L540"><span class="lineNum">     540</span>              : #if defined(MBEDTLS_VIA_PADLOCK_HAVE_CODE)</span>
<span id="L541"><span class="lineNum">     541</span>              :     if (aes_padlock_ace == -1) {</span>
<span id="L542"><span class="lineNum">     542</span>              :         aes_padlock_ace = mbedtls_padlock_has_support(MBEDTLS_PADLOCK_ACE);</span>
<span id="L543"><span class="lineNum">     543</span>              :     }</span>
<span id="L544"><span class="lineNum">     544</span>              :     if (aes_padlock_ace) {</span>
<span id="L545"><span class="lineNum">     545</span>              :         align_16_bytes = 1;</span>
<span id="L546"><span class="lineNum">     546</span>              :     }</span>
<span id="L547"><span class="lineNum">     547</span>              : #endif</span>
<span id="L548"><span class="lineNum">     548</span>              : </span>
<span id="L549"><span class="lineNum">     549</span>              : #if defined(MBEDTLS_AESNI_C) &amp;&amp; MBEDTLS_AESNI_HAVE_CODE == 2</span>
<span id="L550"><span class="lineNum">     550</span>              :     if (mbedtls_aesni_has_support(MBEDTLS_AESNI_AES)) {</span>
<span id="L551"><span class="lineNum">     551</span>              :         align_16_bytes = 1;</span>
<span id="L552"><span class="lineNum">     552</span>              :     }</span>
<span id="L553"><span class="lineNum">     553</span>              : #endif</span>
<span id="L554"><span class="lineNum">     554</span>              : </span>
<span id="L555"><span class="lineNum">     555</span>              :     if (align_16_bytes) {</span>
<span id="L556"><span class="lineNum">     556</span>              :         /* These implementations needs 16-byte alignment</span>
<span id="L557"><span class="lineNum">     557</span>              :          * for the round key array. */</span>
<span id="L558"><span class="lineNum">     558</span>              :         unsigned delta = ((uintptr_t) buf &amp; 0x0000000fU) / 4;</span>
<span id="L559"><span class="lineNum">     559</span>              :         if (delta == 0) {</span>
<span id="L560"><span class="lineNum">     560</span>              :             return 0;</span>
<span id="L561"><span class="lineNum">     561</span>              :         } else {</span>
<span id="L562"><span class="lineNum">     562</span>              :             return 4 - delta; // 16 bytes = 4 uint32_t</span>
<span id="L563"><span class="lineNum">     563</span>              :         }</span>
<span id="L564"><span class="lineNum">     564</span>              :     }</span>
<span id="L565"><span class="lineNum">     565</span>              : #else /* MAY_NEED_TO_ALIGN */</span>
<span id="L566"><span class="lineNum">     566</span>              :     (void) buf;</span>
<span id="L567"><span class="lineNum">     567</span>              : #endif /* MAY_NEED_TO_ALIGN */</span>
<span id="L568"><span class="lineNum">     568</span>              : </span>
<span id="L569"><span class="lineNum">     569</span> <span class="tlaGNC">         819 :     return 0;</span></span>
<span id="L570"><span class="lineNum">     570</span>              : }</span>
<span id="L571"><span class="lineNum">     571</span>              : </span>
<span id="L572"><span class="lineNum">     572</span>              : /*</span>
<span id="L573"><span class="lineNum">     573</span>              :  * AES key schedule (encryption)</span>
<span id="L574"><span class="lineNum">     574</span>              :  */</span>
<span id="L575"><span class="lineNum">     575</span>              : #if !defined(MBEDTLS_AES_SETKEY_ENC_ALT)</span>
<span id="L576"><span class="lineNum">     576</span> <span class="tlaGNC">         819 : int mbedtls_aes_setkey_enc(mbedtls_aes_context *ctx, const unsigned char *key,</span></span>
<span id="L577"><span class="lineNum">     577</span>              :                            unsigned int keybits)</span>
<span id="L578"><span class="lineNum">     578</span>              : {</span>
<span id="L579"><span class="lineNum">     579</span>              :     uint32_t *RK;</span>
<span id="L580"><span class="lineNum">     580</span>              : </span>
<span id="L581"><span class="lineNum">     581</span> <span class="tlaGNC">         819 :     switch (keybits) {</span></span>
<span id="L582"><span class="lineNum">     582</span> <span class="tlaGNC">           2 :         case 128: ctx-&gt;nr = 10; break;</span></span>
<span id="L583"><span class="lineNum">     583</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L584"><span class="lineNum">     584</span> <span class="tlaUNC tlaBgUNC">           0 :         case 192: ctx-&gt;nr = 12; break;</span></span>
<span id="L585"><span class="lineNum">     585</span> <span class="tlaGNC tlaBgGNC">         817 :         case 256: ctx-&gt;nr = 14; break;</span></span>
<span id="L586"><span class="lineNum">     586</span>              : #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */</span>
<span id="L587"><span class="lineNum">     587</span> <span class="tlaUNC tlaBgUNC">           0 :         default: return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;</span></span>
<span id="L588"><span class="lineNum">     588</span>              :     }</span>
<span id="L589"><span class="lineNum">     589</span>              : </span>
<span id="L590"><span class="lineNum">     590</span>              : #if !defined(MBEDTLS_AES_ROM_TABLES)</span>
<span id="L591"><span class="lineNum">     591</span> <span class="tlaGNC tlaBgGNC">         819 :     if (aes_init_done == 0) {</span></span>
<span id="L592"><span class="lineNum">     592</span> <span class="tlaGNC">           2 :         aes_gen_tables();</span></span>
<span id="L593"><span class="lineNum">     593</span> <span class="tlaGNC">           2 :         aes_init_done = 1;</span></span>
<span id="L594"><span class="lineNum">     594</span>              :     }</span>
<span id="L595"><span class="lineNum">     595</span>              : #endif</span>
<span id="L596"><span class="lineNum">     596</span>              : </span>
<span id="L597"><span class="lineNum">     597</span> <span class="tlaGNC">         819 :     ctx-&gt;rk_offset = mbedtls_aes_rk_offset(ctx-&gt;buf);</span></span>
<span id="L598"><span class="lineNum">     598</span> <span class="tlaGNC">         819 :     RK = ctx-&gt;buf + ctx-&gt;rk_offset;</span></span>
<span id="L599"><span class="lineNum">     599</span>              : </span>
<span id="L600"><span class="lineNum">     600</span>              : #if defined(MBEDTLS_AESNI_HAVE_CODE)</span>
<span id="L601"><span class="lineNum">     601</span> <span class="tlaGNC">         819 :     if (mbedtls_aesni_has_support(MBEDTLS_AESNI_AES)) {</span></span>
<span id="L602"><span class="lineNum">     602</span> <span class="tlaGNC">         819 :         return mbedtls_aesni_setkey_enc((unsigned char *) RK, key, keybits);</span></span>
<span id="L603"><span class="lineNum">     603</span>              :     }</span>
<span id="L604"><span class="lineNum">     604</span>              : #endif</span>
<span id="L605"><span class="lineNum">     605</span>              : </span>
<span id="L606"><span class="lineNum">     606</span>              : #if defined(MBEDTLS_AESCE_HAVE_CODE)</span>
<span id="L607"><span class="lineNum">     607</span>              :     if (MBEDTLS_AESCE_HAS_SUPPORT()) {</span>
<span id="L608"><span class="lineNum">     608</span>              :         return mbedtls_aesce_setkey_enc((unsigned char *) RK, key, keybits);</span>
<span id="L609"><span class="lineNum">     609</span>              :     }</span>
<span id="L610"><span class="lineNum">     610</span>              : #endif</span>
<span id="L611"><span class="lineNum">     611</span>              : </span>
<span id="L612"><span class="lineNum">     612</span>              : #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L613"><span class="lineNum">     613</span> <span class="tlaUNC tlaBgUNC">           0 :     for (unsigned int i = 0; i &lt; (keybits &gt;&gt; 5); i++) {</span></span>
<span id="L614"><span class="lineNum">     614</span> <span class="tlaUNC">           0 :         RK[i] = MBEDTLS_GET_UINT32_LE(key, i &lt;&lt; 2);</span></span>
<span id="L615"><span class="lineNum">     615</span>              :     }</span>
<span id="L616"><span class="lineNum">     616</span>              : </span>
<span id="L617"><span class="lineNum">     617</span> <span class="tlaUNC">           0 :     switch (ctx-&gt;nr) {</span></span>
<span id="L618"><span class="lineNum">     618</span> <span class="tlaUNC">           0 :         case 10:</span></span>
<span id="L619"><span class="lineNum">     619</span>              : </span>
<span id="L620"><span class="lineNum">     620</span> <span class="tlaUNC">           0 :             for (unsigned int i = 0; i &lt; 10; i++, RK += 4) {</span></span>
<span id="L621"><span class="lineNum">     621</span> <span class="tlaUNC">           0 :                 RK[4]  = RK[0] ^ round_constants[i] ^</span></span>
<span id="L622"><span class="lineNum">     622</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[3])]) ^</span></span>
<span id="L623"><span class="lineNum">     623</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[3])] &lt;&lt;  8) ^</span></span>
<span id="L624"><span class="lineNum">     624</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[3])] &lt;&lt; 16) ^</span></span>
<span id="L625"><span class="lineNum">     625</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[3])] &lt;&lt; 24);</span></span>
<span id="L626"><span class="lineNum">     626</span>              : </span>
<span id="L627"><span class="lineNum">     627</span> <span class="tlaUNC">           0 :                 RK[5]  = RK[1] ^ RK[4];</span></span>
<span id="L628"><span class="lineNum">     628</span> <span class="tlaUNC">           0 :                 RK[6]  = RK[2] ^ RK[5];</span></span>
<span id="L629"><span class="lineNum">     629</span> <span class="tlaUNC">           0 :                 RK[7]  = RK[3] ^ RK[6];</span></span>
<span id="L630"><span class="lineNum">     630</span>              :             }</span>
<span id="L631"><span class="lineNum">     631</span> <span class="tlaUNC">           0 :             break;</span></span>
<span id="L632"><span class="lineNum">     632</span>              : </span>
<span id="L633"><span class="lineNum">     633</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L634"><span class="lineNum">     634</span> <span class="tlaUNC">           0 :         case 12:</span></span>
<span id="L635"><span class="lineNum">     635</span>              : </span>
<span id="L636"><span class="lineNum">     636</span> <span class="tlaUNC">           0 :             for (unsigned int i = 0; i &lt; 8; i++, RK += 6) {</span></span>
<span id="L637"><span class="lineNum">     637</span> <span class="tlaUNC">           0 :                 RK[6]  = RK[0] ^ round_constants[i] ^</span></span>
<span id="L638"><span class="lineNum">     638</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[5])]) ^</span></span>
<span id="L639"><span class="lineNum">     639</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[5])] &lt;&lt;  8) ^</span></span>
<span id="L640"><span class="lineNum">     640</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[5])] &lt;&lt; 16) ^</span></span>
<span id="L641"><span class="lineNum">     641</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[5])] &lt;&lt; 24);</span></span>
<span id="L642"><span class="lineNum">     642</span>              : </span>
<span id="L643"><span class="lineNum">     643</span> <span class="tlaUNC">           0 :                 RK[7]  = RK[1] ^ RK[6];</span></span>
<span id="L644"><span class="lineNum">     644</span> <span class="tlaUNC">           0 :                 RK[8]  = RK[2] ^ RK[7];</span></span>
<span id="L645"><span class="lineNum">     645</span> <span class="tlaUNC">           0 :                 RK[9]  = RK[3] ^ RK[8];</span></span>
<span id="L646"><span class="lineNum">     646</span> <span class="tlaUNC">           0 :                 RK[10] = RK[4] ^ RK[9];</span></span>
<span id="L647"><span class="lineNum">     647</span> <span class="tlaUNC">           0 :                 RK[11] = RK[5] ^ RK[10];</span></span>
<span id="L648"><span class="lineNum">     648</span>              :             }</span>
<span id="L649"><span class="lineNum">     649</span> <span class="tlaUNC">           0 :             break;</span></span>
<span id="L650"><span class="lineNum">     650</span>              : </span>
<span id="L651"><span class="lineNum">     651</span> <span class="tlaUNC">           0 :         case 14:</span></span>
<span id="L652"><span class="lineNum">     652</span>              : </span>
<span id="L653"><span class="lineNum">     653</span> <span class="tlaUNC">           0 :             for (unsigned int i = 0; i &lt; 7; i++, RK += 8) {</span></span>
<span id="L654"><span class="lineNum">     654</span> <span class="tlaUNC">           0 :                 RK[8]  = RK[0] ^ round_constants[i] ^</span></span>
<span id="L655"><span class="lineNum">     655</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[7])]) ^</span></span>
<span id="L656"><span class="lineNum">     656</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[7])] &lt;&lt;  8) ^</span></span>
<span id="L657"><span class="lineNum">     657</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[7])] &lt;&lt; 16) ^</span></span>
<span id="L658"><span class="lineNum">     658</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[7])] &lt;&lt; 24);</span></span>
<span id="L659"><span class="lineNum">     659</span>              : </span>
<span id="L660"><span class="lineNum">     660</span> <span class="tlaUNC">           0 :                 RK[9]  = RK[1] ^ RK[8];</span></span>
<span id="L661"><span class="lineNum">     661</span> <span class="tlaUNC">           0 :                 RK[10] = RK[2] ^ RK[9];</span></span>
<span id="L662"><span class="lineNum">     662</span> <span class="tlaUNC">           0 :                 RK[11] = RK[3] ^ RK[10];</span></span>
<span id="L663"><span class="lineNum">     663</span>              : </span>
<span id="L664"><span class="lineNum">     664</span> <span class="tlaUNC">           0 :                 RK[12] = RK[4] ^</span></span>
<span id="L665"><span class="lineNum">     665</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_0(RK[11])]) ^</span></span>
<span id="L666"><span class="lineNum">     666</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_1(RK[11])] &lt;&lt;  8) ^</span></span>
<span id="L667"><span class="lineNum">     667</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_2(RK[11])] &lt;&lt; 16) ^</span></span>
<span id="L668"><span class="lineNum">     668</span> <span class="tlaUNC">           0 :                          ((uint32_t) FSb[MBEDTLS_BYTE_3(RK[11])] &lt;&lt; 24);</span></span>
<span id="L669"><span class="lineNum">     669</span>              : </span>
<span id="L670"><span class="lineNum">     670</span> <span class="tlaUNC">           0 :                 RK[13] = RK[5] ^ RK[12];</span></span>
<span id="L671"><span class="lineNum">     671</span> <span class="tlaUNC">           0 :                 RK[14] = RK[6] ^ RK[13];</span></span>
<span id="L672"><span class="lineNum">     672</span> <span class="tlaUNC">           0 :                 RK[15] = RK[7] ^ RK[14];</span></span>
<span id="L673"><span class="lineNum">     673</span>              :             }</span>
<span id="L674"><span class="lineNum">     674</span> <span class="tlaUNC">           0 :             break;</span></span>
<span id="L675"><span class="lineNum">     675</span>              : #endif /* !MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH */</span>
<span id="L676"><span class="lineNum">     676</span>              :     }</span>
<span id="L677"><span class="lineNum">     677</span>              : </span>
<span id="L678"><span class="lineNum">     678</span> <span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L679"><span class="lineNum">     679</span>              : #endif /* !MBEDTLS_AES_USE_HARDWARE_ONLY */</span>
<span id="L680"><span class="lineNum">     680</span>              : }</span>
<span id="L681"><span class="lineNum">     681</span>              : #endif /* !MBEDTLS_AES_SETKEY_ENC_ALT */</span>
<span id="L682"><span class="lineNum">     682</span>              : </span>
<span id="L683"><span class="lineNum">     683</span>              : /*</span>
<span id="L684"><span class="lineNum">     684</span>              :  * AES key schedule (decryption)</span>
<span id="L685"><span class="lineNum">     685</span>              :  */</span>
<span id="L686"><span class="lineNum">     686</span>              : #if !defined(MBEDTLS_AES_SETKEY_DEC_ALT) &amp;&amp; !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L687"><span class="lineNum">     687</span> <span class="tlaUNC">           0 : int mbedtls_aes_setkey_dec(mbedtls_aes_context *ctx, const unsigned char *key,</span></span>
<span id="L688"><span class="lineNum">     688</span>              :                            unsigned int keybits)</span>
<span id="L689"><span class="lineNum">     689</span>              : {</span>
<span id="L690"><span class="lineNum">     690</span>              : #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L691"><span class="lineNum">     691</span>              :     uint32_t *SK;</span>
<span id="L692"><span class="lineNum">     692</span>              : #endif</span>
<span id="L693"><span class="lineNum">     693</span>              :     int ret;</span>
<span id="L694"><span class="lineNum">     694</span>              :     mbedtls_aes_context cty;</span>
<span id="L695"><span class="lineNum">     695</span>              :     uint32_t *RK;</span>
<span id="L696"><span class="lineNum">     696</span>              : </span>
<span id="L697"><span class="lineNum">     697</span>              : </span>
<span id="L698"><span class="lineNum">     698</span> <span class="tlaUNC">           0 :     mbedtls_aes_init(&amp;cty);</span></span>
<span id="L699"><span class="lineNum">     699</span>              : </span>
<span id="L700"><span class="lineNum">     700</span> <span class="tlaUNC">           0 :     ctx-&gt;rk_offset = mbedtls_aes_rk_offset(ctx-&gt;buf);</span></span>
<span id="L701"><span class="lineNum">     701</span> <span class="tlaUNC">           0 :     RK = ctx-&gt;buf + ctx-&gt;rk_offset;</span></span>
<span id="L702"><span class="lineNum">     702</span>              : </span>
<span id="L703"><span class="lineNum">     703</span>              :     /* Also checks keybits */</span>
<span id="L704"><span class="lineNum">     704</span> <span class="tlaUNC">           0 :     if ((ret = mbedtls_aes_setkey_enc(&amp;cty, key, keybits)) != 0) {</span></span>
<span id="L705"><span class="lineNum">     705</span> <span class="tlaUNC">           0 :         goto exit;</span></span>
<span id="L706"><span class="lineNum">     706</span>              :     }</span>
<span id="L707"><span class="lineNum">     707</span>              : </span>
<span id="L708"><span class="lineNum">     708</span> <span class="tlaUNC">           0 :     ctx-&gt;nr = cty.nr;</span></span>
<span id="L709"><span class="lineNum">     709</span>              : </span>
<span id="L710"><span class="lineNum">     710</span>              : #if defined(MBEDTLS_AESNI_HAVE_CODE)</span>
<span id="L711"><span class="lineNum">     711</span> <span class="tlaUNC">           0 :     if (mbedtls_aesni_has_support(MBEDTLS_AESNI_AES)) {</span></span>
<span id="L712"><span class="lineNum">     712</span> <span class="tlaUNC">           0 :         mbedtls_aesni_inverse_key((unsigned char *) RK,</span></span>
<span id="L713"><span class="lineNum">     713</span> <span class="tlaUNC">           0 :                                   (const unsigned char *) (cty.buf + cty.rk_offset), ctx-&gt;nr);</span></span>
<span id="L714"><span class="lineNum">     714</span> <span class="tlaUNC">           0 :         goto exit;</span></span>
<span id="L715"><span class="lineNum">     715</span>              :     }</span>
<span id="L716"><span class="lineNum">     716</span>              : #endif</span>
<span id="L717"><span class="lineNum">     717</span>              : </span>
<span id="L718"><span class="lineNum">     718</span>              : #if defined(MBEDTLS_AESCE_HAVE_CODE)</span>
<span id="L719"><span class="lineNum">     719</span>              :     if (MBEDTLS_AESCE_HAS_SUPPORT()) {</span>
<span id="L720"><span class="lineNum">     720</span>              :         mbedtls_aesce_inverse_key(</span>
<span id="L721"><span class="lineNum">     721</span>              :             (unsigned char *) RK,</span>
<span id="L722"><span class="lineNum">     722</span>              :             (const unsigned char *) (cty.buf + cty.rk_offset),</span>
<span id="L723"><span class="lineNum">     723</span>              :             ctx-&gt;nr);</span>
<span id="L724"><span class="lineNum">     724</span>              :         goto exit;</span>
<span id="L725"><span class="lineNum">     725</span>              :     }</span>
<span id="L726"><span class="lineNum">     726</span>              : #endif</span>
<span id="L727"><span class="lineNum">     727</span>              : </span>
<span id="L728"><span class="lineNum">     728</span>              : #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L729"><span class="lineNum">     729</span> <span class="tlaUNC">           0 :     SK = cty.buf + cty.rk_offset + cty.nr * 4;</span></span>
<span id="L730"><span class="lineNum">     730</span>              : </span>
<span id="L731"><span class="lineNum">     731</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L732"><span class="lineNum">     732</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L733"><span class="lineNum">     733</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L734"><span class="lineNum">     734</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L735"><span class="lineNum">     735</span> <span class="tlaUNC">           0 :     SK -= 8;</span></span>
<span id="L736"><span class="lineNum">     736</span> <span class="tlaUNC">           0 :     for (int i = ctx-&gt;nr - 1; i &gt; 0; i--, SK -= 8) {</span></span>
<span id="L737"><span class="lineNum">     737</span> <span class="tlaUNC">           0 :         for (int j = 0; j &lt; 4; j++, SK++) {</span></span>
<span id="L738"><span class="lineNum">     738</span> <span class="tlaUNC">           0 :             *RK++ = AES_RT0(FSb[MBEDTLS_BYTE_0(*SK)]) ^</span></span>
<span id="L739"><span class="lineNum">     739</span> <span class="tlaUNC">           0 :                     AES_RT1(FSb[MBEDTLS_BYTE_1(*SK)]) ^</span></span>
<span id="L740"><span class="lineNum">     740</span> <span class="tlaUNC">           0 :                     AES_RT2(FSb[MBEDTLS_BYTE_2(*SK)]) ^</span></span>
<span id="L741"><span class="lineNum">     741</span> <span class="tlaUNC">           0 :                     AES_RT3(FSb[MBEDTLS_BYTE_3(*SK)]);</span></span>
<span id="L742"><span class="lineNum">     742</span>              :         }</span>
<span id="L743"><span class="lineNum">     743</span>              :     }</span>
<span id="L744"><span class="lineNum">     744</span>              : </span>
<span id="L745"><span class="lineNum">     745</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L746"><span class="lineNum">     746</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L747"><span class="lineNum">     747</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L748"><span class="lineNum">     748</span> <span class="tlaUNC">           0 :     *RK++ = *SK++;</span></span>
<span id="L749"><span class="lineNum">     749</span>              : #endif /* !MBEDTLS_AES_USE_HARDWARE_ONLY */</span>
<span id="L750"><span class="lineNum">     750</span> <span class="tlaUNC">           0 : exit:</span></span>
<span id="L751"><span class="lineNum">     751</span> <span class="tlaUNC">           0 :     mbedtls_aes_free(&amp;cty);</span></span>
<span id="L752"><span class="lineNum">     752</span>              : </span>
<span id="L753"><span class="lineNum">     753</span> <span class="tlaUNC">           0 :     return ret;</span></span>
<span id="L754"><span class="lineNum">     754</span>              : }</span>
<span id="L755"><span class="lineNum">     755</span>              : #endif /* !MBEDTLS_AES_SETKEY_DEC_ALT &amp;&amp; !MBEDTLS_BLOCK_CIPHER_NO_DECRYPT */</span>
<span id="L756"><span class="lineNum">     756</span>              : </span>
<span id="L757"><span class="lineNum">     757</span>              : #if defined(MBEDTLS_CIPHER_MODE_XTS)</span>
<span id="L758"><span class="lineNum">     758</span>              : static int mbedtls_aes_xts_decode_keys(const unsigned char *key,</span>
<span id="L759"><span class="lineNum">     759</span>              :                                        unsigned int keybits,</span>
<span id="L760"><span class="lineNum">     760</span>              :                                        const unsigned char **key1,</span>
<span id="L761"><span class="lineNum">     761</span>              :                                        unsigned int *key1bits,</span>
<span id="L762"><span class="lineNum">     762</span>              :                                        const unsigned char **key2,</span>
<span id="L763"><span class="lineNum">     763</span>              :                                        unsigned int *key2bits)</span>
<span id="L764"><span class="lineNum">     764</span>              : {</span>
<span id="L765"><span class="lineNum">     765</span>              :     const unsigned int half_keybits = keybits / 2;</span>
<span id="L766"><span class="lineNum">     766</span>              :     const unsigned int half_keybytes = half_keybits / 8;</span>
<span id="L767"><span class="lineNum">     767</span>              : </span>
<span id="L768"><span class="lineNum">     768</span>              :     switch (keybits) {</span>
<span id="L769"><span class="lineNum">     769</span>              :         case 256: break;</span>
<span id="L770"><span class="lineNum">     770</span>              :         case 512: break;</span>
<span id="L771"><span class="lineNum">     771</span>              :         default: return MBEDTLS_ERR_AES_INVALID_KEY_LENGTH;</span>
<span id="L772"><span class="lineNum">     772</span>              :     }</span>
<span id="L773"><span class="lineNum">     773</span>              : </span>
<span id="L774"><span class="lineNum">     774</span>              :     *key1bits = half_keybits;</span>
<span id="L775"><span class="lineNum">     775</span>              :     *key2bits = half_keybits;</span>
<span id="L776"><span class="lineNum">     776</span>              :     *key1 = &amp;key[0];</span>
<span id="L777"><span class="lineNum">     777</span>              :     *key2 = &amp;key[half_keybytes];</span>
<span id="L778"><span class="lineNum">     778</span>              : </span>
<span id="L779"><span class="lineNum">     779</span>              :     return 0;</span>
<span id="L780"><span class="lineNum">     780</span>              : }</span>
<span id="L781"><span class="lineNum">     781</span>              : </span>
<span id="L782"><span class="lineNum">     782</span>              : int mbedtls_aes_xts_setkey_enc(mbedtls_aes_xts_context *ctx,</span>
<span id="L783"><span class="lineNum">     783</span>              :                                const unsigned char *key,</span>
<span id="L784"><span class="lineNum">     784</span>              :                                unsigned int keybits)</span>
<span id="L785"><span class="lineNum">     785</span>              : {</span>
<span id="L786"><span class="lineNum">     786</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L787"><span class="lineNum">     787</span>              :     const unsigned char *key1, *key2;</span>
<span id="L788"><span class="lineNum">     788</span>              :     unsigned int key1bits, key2bits;</span>
<span id="L789"><span class="lineNum">     789</span>              : </span>
<span id="L790"><span class="lineNum">     790</span>              :     ret = mbedtls_aes_xts_decode_keys(key, keybits, &amp;key1, &amp;key1bits,</span>
<span id="L791"><span class="lineNum">     791</span>              :                                       &amp;key2, &amp;key2bits);</span>
<span id="L792"><span class="lineNum">     792</span>              :     if (ret != 0) {</span>
<span id="L793"><span class="lineNum">     793</span>              :         return ret;</span>
<span id="L794"><span class="lineNum">     794</span>              :     }</span>
<span id="L795"><span class="lineNum">     795</span>              : </span>
<span id="L796"><span class="lineNum">     796</span>              :     /* Set the tweak key. Always set tweak key for the encryption mode. */</span>
<span id="L797"><span class="lineNum">     797</span>              :     ret = mbedtls_aes_setkey_enc(&amp;ctx-&gt;tweak, key2, key2bits);</span>
<span id="L798"><span class="lineNum">     798</span>              :     if (ret != 0) {</span>
<span id="L799"><span class="lineNum">     799</span>              :         return ret;</span>
<span id="L800"><span class="lineNum">     800</span>              :     }</span>
<span id="L801"><span class="lineNum">     801</span>              : </span>
<span id="L802"><span class="lineNum">     802</span>              :     /* Set crypt key for encryption. */</span>
<span id="L803"><span class="lineNum">     803</span>              :     return mbedtls_aes_setkey_enc(&amp;ctx-&gt;crypt, key1, key1bits);</span>
<span id="L804"><span class="lineNum">     804</span>              : }</span>
<span id="L805"><span class="lineNum">     805</span>              : </span>
<span id="L806"><span class="lineNum">     806</span>              : int mbedtls_aes_xts_setkey_dec(mbedtls_aes_xts_context *ctx,</span>
<span id="L807"><span class="lineNum">     807</span>              :                                const unsigned char *key,</span>
<span id="L808"><span class="lineNum">     808</span>              :                                unsigned int keybits)</span>
<span id="L809"><span class="lineNum">     809</span>              : {</span>
<span id="L810"><span class="lineNum">     810</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L811"><span class="lineNum">     811</span>              :     const unsigned char *key1, *key2;</span>
<span id="L812"><span class="lineNum">     812</span>              :     unsigned int key1bits, key2bits;</span>
<span id="L813"><span class="lineNum">     813</span>              : </span>
<span id="L814"><span class="lineNum">     814</span>              :     ret = mbedtls_aes_xts_decode_keys(key, keybits, &amp;key1, &amp;key1bits,</span>
<span id="L815"><span class="lineNum">     815</span>              :                                       &amp;key2, &amp;key2bits);</span>
<span id="L816"><span class="lineNum">     816</span>              :     if (ret != 0) {</span>
<span id="L817"><span class="lineNum">     817</span>              :         return ret;</span>
<span id="L818"><span class="lineNum">     818</span>              :     }</span>
<span id="L819"><span class="lineNum">     819</span>              : </span>
<span id="L820"><span class="lineNum">     820</span>              :     /* Set the tweak key. Always set tweak key for encryption. */</span>
<span id="L821"><span class="lineNum">     821</span>              :     ret = mbedtls_aes_setkey_enc(&amp;ctx-&gt;tweak, key2, key2bits);</span>
<span id="L822"><span class="lineNum">     822</span>              :     if (ret != 0) {</span>
<span id="L823"><span class="lineNum">     823</span>              :         return ret;</span>
<span id="L824"><span class="lineNum">     824</span>              :     }</span>
<span id="L825"><span class="lineNum">     825</span>              : </span>
<span id="L826"><span class="lineNum">     826</span>              :     /* Set crypt key for decryption. */</span>
<span id="L827"><span class="lineNum">     827</span>              :     return mbedtls_aes_setkey_dec(&amp;ctx-&gt;crypt, key1, key1bits);</span>
<span id="L828"><span class="lineNum">     828</span>              : }</span>
<span id="L829"><span class="lineNum">     829</span>              : #endif /* MBEDTLS_CIPHER_MODE_XTS */</span>
<span id="L830"><span class="lineNum">     830</span>              : </span>
<span id="L831"><span class="lineNum">     831</span>              : #define AES_FROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)                 \</span>
<span id="L832"><span class="lineNum">     832</span>              :     do                                                      \</span>
<span id="L833"><span class="lineNum">     833</span>              :     {                                                       \</span>
<span id="L834"><span class="lineNum">     834</span>              :         (X0) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y0)) ^    \</span>
<span id="L835"><span class="lineNum">     835</span>              :                AES_FT1(MBEDTLS_BYTE_1(Y1)) ^    \</span>
<span id="L836"><span class="lineNum">     836</span>              :                AES_FT2(MBEDTLS_BYTE_2(Y2)) ^    \</span>
<span id="L837"><span class="lineNum">     837</span>              :                AES_FT3(MBEDTLS_BYTE_3(Y3));     \</span>
<span id="L838"><span class="lineNum">     838</span>              :                                                             \</span>
<span id="L839"><span class="lineNum">     839</span>              :         (X1) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y1)) ^    \</span>
<span id="L840"><span class="lineNum">     840</span>              :                AES_FT1(MBEDTLS_BYTE_1(Y2)) ^    \</span>
<span id="L841"><span class="lineNum">     841</span>              :                AES_FT2(MBEDTLS_BYTE_2(Y3)) ^    \</span>
<span id="L842"><span class="lineNum">     842</span>              :                AES_FT3(MBEDTLS_BYTE_3(Y0));     \</span>
<span id="L843"><span class="lineNum">     843</span>              :                                                             \</span>
<span id="L844"><span class="lineNum">     844</span>              :         (X2) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y2)) ^    \</span>
<span id="L845"><span class="lineNum">     845</span>              :                AES_FT1(MBEDTLS_BYTE_1(Y3)) ^    \</span>
<span id="L846"><span class="lineNum">     846</span>              :                AES_FT2(MBEDTLS_BYTE_2(Y0)) ^    \</span>
<span id="L847"><span class="lineNum">     847</span>              :                AES_FT3(MBEDTLS_BYTE_3(Y1));     \</span>
<span id="L848"><span class="lineNum">     848</span>              :                                                             \</span>
<span id="L849"><span class="lineNum">     849</span>              :         (X3) = *RK++ ^ AES_FT0(MBEDTLS_BYTE_0(Y3)) ^    \</span>
<span id="L850"><span class="lineNum">     850</span>              :                AES_FT1(MBEDTLS_BYTE_1(Y0)) ^    \</span>
<span id="L851"><span class="lineNum">     851</span>              :                AES_FT2(MBEDTLS_BYTE_2(Y1)) ^    \</span>
<span id="L852"><span class="lineNum">     852</span>              :                AES_FT3(MBEDTLS_BYTE_3(Y2));     \</span>
<span id="L853"><span class="lineNum">     853</span>              :     } while (0)</span>
<span id="L854"><span class="lineNum">     854</span>              : </span>
<span id="L855"><span class="lineNum">     855</span>              : #define AES_RROUND(X0, X1, X2, X3, Y0, Y1, Y2, Y3)                 \</span>
<span id="L856"><span class="lineNum">     856</span>              :     do                                                      \</span>
<span id="L857"><span class="lineNum">     857</span>              :     {                                                       \</span>
<span id="L858"><span class="lineNum">     858</span>              :         (X0) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y0)) ^    \</span>
<span id="L859"><span class="lineNum">     859</span>              :                AES_RT1(MBEDTLS_BYTE_1(Y3)) ^    \</span>
<span id="L860"><span class="lineNum">     860</span>              :                AES_RT2(MBEDTLS_BYTE_2(Y2)) ^    \</span>
<span id="L861"><span class="lineNum">     861</span>              :                AES_RT3(MBEDTLS_BYTE_3(Y1));     \</span>
<span id="L862"><span class="lineNum">     862</span>              :                                                             \</span>
<span id="L863"><span class="lineNum">     863</span>              :         (X1) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y1)) ^    \</span>
<span id="L864"><span class="lineNum">     864</span>              :                AES_RT1(MBEDTLS_BYTE_1(Y0)) ^    \</span>
<span id="L865"><span class="lineNum">     865</span>              :                AES_RT2(MBEDTLS_BYTE_2(Y3)) ^    \</span>
<span id="L866"><span class="lineNum">     866</span>              :                AES_RT3(MBEDTLS_BYTE_3(Y2));     \</span>
<span id="L867"><span class="lineNum">     867</span>              :                                                             \</span>
<span id="L868"><span class="lineNum">     868</span>              :         (X2) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y2)) ^    \</span>
<span id="L869"><span class="lineNum">     869</span>              :                AES_RT1(MBEDTLS_BYTE_1(Y1)) ^    \</span>
<span id="L870"><span class="lineNum">     870</span>              :                AES_RT2(MBEDTLS_BYTE_2(Y0)) ^    \</span>
<span id="L871"><span class="lineNum">     871</span>              :                AES_RT3(MBEDTLS_BYTE_3(Y3));     \</span>
<span id="L872"><span class="lineNum">     872</span>              :                                                             \</span>
<span id="L873"><span class="lineNum">     873</span>              :         (X3) = *RK++ ^ AES_RT0(MBEDTLS_BYTE_0(Y3)) ^    \</span>
<span id="L874"><span class="lineNum">     874</span>              :                AES_RT1(MBEDTLS_BYTE_1(Y2)) ^    \</span>
<span id="L875"><span class="lineNum">     875</span>              :                AES_RT2(MBEDTLS_BYTE_2(Y1)) ^    \</span>
<span id="L876"><span class="lineNum">     876</span>              :                AES_RT3(MBEDTLS_BYTE_3(Y0));     \</span>
<span id="L877"><span class="lineNum">     877</span>              :     } while (0)</span>
<span id="L878"><span class="lineNum">     878</span>              : </span>
<span id="L879"><span class="lineNum">     879</span>              : /*</span>
<span id="L880"><span class="lineNum">     880</span>              :  * AES-ECB block encryption</span>
<span id="L881"><span class="lineNum">     881</span>              :  */</span>
<span id="L882"><span class="lineNum">     882</span>              : #if !defined(MBEDTLS_AES_ENCRYPT_ALT)</span>
<span id="L883"><span class="lineNum">     883</span> <span class="tlaUNC">           0 : int mbedtls_internal_aes_encrypt(mbedtls_aes_context *ctx,</span></span>
<span id="L884"><span class="lineNum">     884</span>              :                                  const unsigned char input[16],</span>
<span id="L885"><span class="lineNum">     885</span>              :                                  unsigned char output[16])</span>
<span id="L886"><span class="lineNum">     886</span>              : {</span>
<span id="L887"><span class="lineNum">     887</span>              :     int i;</span>
<span id="L888"><span class="lineNum">     888</span> <span class="tlaUNC">           0 :     uint32_t *RK = ctx-&gt;buf + ctx-&gt;rk_offset;</span></span>
<span id="L889"><span class="lineNum">     889</span>              :     struct {</span>
<span id="L890"><span class="lineNum">     890</span>              :         uint32_t X[4];</span>
<span id="L891"><span class="lineNum">     891</span>              :         uint32_t Y[4];</span>
<span id="L892"><span class="lineNum">     892</span>              :     } t;</span>
<span id="L893"><span class="lineNum">     893</span>              : </span>
<span id="L894"><span class="lineNum">     894</span> <span class="tlaUNC">           0 :     t.X[0] = MBEDTLS_GET_UINT32_LE(input,  0); t.X[0] ^= *RK++;</span></span>
<span id="L895"><span class="lineNum">     895</span> <span class="tlaUNC">           0 :     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;</span></span>
<span id="L896"><span class="lineNum">     896</span> <span class="tlaUNC">           0 :     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;</span></span>
<span id="L897"><span class="lineNum">     897</span> <span class="tlaUNC">           0 :     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;</span></span>
<span id="L898"><span class="lineNum">     898</span>              : </span>
<span id="L899"><span class="lineNum">     899</span> <span class="tlaUNC">           0 :     for (i = (ctx-&gt;nr &gt;&gt; 1) - 1; i &gt; 0; i--) {</span></span>
<span id="L900"><span class="lineNum">     900</span> <span class="tlaUNC">           0 :         AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);</span></span>
<span id="L901"><span class="lineNum">     901</span> <span class="tlaUNC">           0 :         AES_FROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);</span></span>
<span id="L902"><span class="lineNum">     902</span>              :     }</span>
<span id="L903"><span class="lineNum">     903</span>              : </span>
<span id="L904"><span class="lineNum">     904</span> <span class="tlaUNC">           0 :     AES_FROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);</span></span>
<span id="L905"><span class="lineNum">     905</span>              : </span>
<span id="L906"><span class="lineNum">     906</span> <span class="tlaUNC">           0 :     t.X[0] = *RK++ ^ \</span></span>
<span id="L907"><span class="lineNum">     907</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[0])]) ^</span></span>
<span id="L908"><span class="lineNum">     908</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[1])] &lt;&lt;  8) ^</span></span>
<span id="L909"><span class="lineNum">     909</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[2])] &lt;&lt; 16) ^</span></span>
<span id="L910"><span class="lineNum">     910</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[3])] &lt;&lt; 24);</span></span>
<span id="L911"><span class="lineNum">     911</span>              : </span>
<span id="L912"><span class="lineNum">     912</span> <span class="tlaUNC">           0 :     t.X[1] = *RK++ ^ \</span></span>
<span id="L913"><span class="lineNum">     913</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[1])]) ^</span></span>
<span id="L914"><span class="lineNum">     914</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[2])] &lt;&lt;  8) ^</span></span>
<span id="L915"><span class="lineNum">     915</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[3])] &lt;&lt; 16) ^</span></span>
<span id="L916"><span class="lineNum">     916</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[0])] &lt;&lt; 24);</span></span>
<span id="L917"><span class="lineNum">     917</span>              : </span>
<span id="L918"><span class="lineNum">     918</span> <span class="tlaUNC">           0 :     t.X[2] = *RK++ ^ \</span></span>
<span id="L919"><span class="lineNum">     919</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[2])]) ^</span></span>
<span id="L920"><span class="lineNum">     920</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[3])] &lt;&lt;  8) ^</span></span>
<span id="L921"><span class="lineNum">     921</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[0])] &lt;&lt; 16) ^</span></span>
<span id="L922"><span class="lineNum">     922</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[1])] &lt;&lt; 24);</span></span>
<span id="L923"><span class="lineNum">     923</span>              : </span>
<span id="L924"><span class="lineNum">     924</span> <span class="tlaUNC">           0 :     t.X[3] = *RK++ ^ \</span></span>
<span id="L925"><span class="lineNum">     925</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_0(t.Y[3])]) ^</span></span>
<span id="L926"><span class="lineNum">     926</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_1(t.Y[0])] &lt;&lt;  8) ^</span></span>
<span id="L927"><span class="lineNum">     927</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_2(t.Y[1])] &lt;&lt; 16) ^</span></span>
<span id="L928"><span class="lineNum">     928</span> <span class="tlaUNC">           0 :              ((uint32_t) FSb[MBEDTLS_BYTE_3(t.Y[2])] &lt;&lt; 24);</span></span>
<span id="L929"><span class="lineNum">     929</span>              : </span>
<span id="L930"><span class="lineNum">     930</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[0], output,  0);</span></span>
<span id="L931"><span class="lineNum">     931</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);</span></span>
<span id="L932"><span class="lineNum">     932</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);</span></span>
<span id="L933"><span class="lineNum">     933</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);</span></span>
<span id="L934"><span class="lineNum">     934</span>              : </span>
<span id="L935"><span class="lineNum">     935</span> <span class="tlaUNC">           0 :     mbedtls_platform_zeroize(&amp;t, sizeof(t));</span></span>
<span id="L936"><span class="lineNum">     936</span>              : </span>
<span id="L937"><span class="lineNum">     937</span> <span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L938"><span class="lineNum">     938</span>              : }</span>
<span id="L939"><span class="lineNum">     939</span>              : #endif /* !MBEDTLS_AES_ENCRYPT_ALT */</span>
<span id="L940"><span class="lineNum">     940</span>              : </span>
<span id="L941"><span class="lineNum">     941</span>              : /*</span>
<span id="L942"><span class="lineNum">     942</span>              :  * AES-ECB block decryption</span>
<span id="L943"><span class="lineNum">     943</span>              :  */</span>
<span id="L944"><span class="lineNum">     944</span>              : #if !defined(MBEDTLS_AES_DECRYPT_ALT) &amp;&amp; !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L945"><span class="lineNum">     945</span> <span class="tlaUNC">           0 : int mbedtls_internal_aes_decrypt(mbedtls_aes_context *ctx,</span></span>
<span id="L946"><span class="lineNum">     946</span>              :                                  const unsigned char input[16],</span>
<span id="L947"><span class="lineNum">     947</span>              :                                  unsigned char output[16])</span>
<span id="L948"><span class="lineNum">     948</span>              : {</span>
<span id="L949"><span class="lineNum">     949</span>              :     int i;</span>
<span id="L950"><span class="lineNum">     950</span> <span class="tlaUNC">           0 :     uint32_t *RK = ctx-&gt;buf + ctx-&gt;rk_offset;</span></span>
<span id="L951"><span class="lineNum">     951</span>              :     struct {</span>
<span id="L952"><span class="lineNum">     952</span>              :         uint32_t X[4];</span>
<span id="L953"><span class="lineNum">     953</span>              :         uint32_t Y[4];</span>
<span id="L954"><span class="lineNum">     954</span>              :     } t;</span>
<span id="L955"><span class="lineNum">     955</span>              : </span>
<span id="L956"><span class="lineNum">     956</span> <span class="tlaUNC">           0 :     t.X[0] = MBEDTLS_GET_UINT32_LE(input,  0); t.X[0] ^= *RK++;</span></span>
<span id="L957"><span class="lineNum">     957</span> <span class="tlaUNC">           0 :     t.X[1] = MBEDTLS_GET_UINT32_LE(input,  4); t.X[1] ^= *RK++;</span></span>
<span id="L958"><span class="lineNum">     958</span> <span class="tlaUNC">           0 :     t.X[2] = MBEDTLS_GET_UINT32_LE(input,  8); t.X[2] ^= *RK++;</span></span>
<span id="L959"><span class="lineNum">     959</span> <span class="tlaUNC">           0 :     t.X[3] = MBEDTLS_GET_UINT32_LE(input, 12); t.X[3] ^= *RK++;</span></span>
<span id="L960"><span class="lineNum">     960</span>              : </span>
<span id="L961"><span class="lineNum">     961</span> <span class="tlaUNC">           0 :     for (i = (ctx-&gt;nr &gt;&gt; 1) - 1; i &gt; 0; i--) {</span></span>
<span id="L962"><span class="lineNum">     962</span> <span class="tlaUNC">           0 :         AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);</span></span>
<span id="L963"><span class="lineNum">     963</span> <span class="tlaUNC">           0 :         AES_RROUND(t.X[0], t.X[1], t.X[2], t.X[3], t.Y[0], t.Y[1], t.Y[2], t.Y[3]);</span></span>
<span id="L964"><span class="lineNum">     964</span>              :     }</span>
<span id="L965"><span class="lineNum">     965</span>              : </span>
<span id="L966"><span class="lineNum">     966</span> <span class="tlaUNC">           0 :     AES_RROUND(t.Y[0], t.Y[1], t.Y[2], t.Y[3], t.X[0], t.X[1], t.X[2], t.X[3]);</span></span>
<span id="L967"><span class="lineNum">     967</span>              : </span>
<span id="L968"><span class="lineNum">     968</span> <span class="tlaUNC">           0 :     t.X[0] = *RK++ ^ \</span></span>
<span id="L969"><span class="lineNum">     969</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[0])]) ^</span></span>
<span id="L970"><span class="lineNum">     970</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[3])] &lt;&lt;  8) ^</span></span>
<span id="L971"><span class="lineNum">     971</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[2])] &lt;&lt; 16) ^</span></span>
<span id="L972"><span class="lineNum">     972</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[1])] &lt;&lt; 24);</span></span>
<span id="L973"><span class="lineNum">     973</span>              : </span>
<span id="L974"><span class="lineNum">     974</span> <span class="tlaUNC">           0 :     t.X[1] = *RK++ ^ \</span></span>
<span id="L975"><span class="lineNum">     975</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[1])]) ^</span></span>
<span id="L976"><span class="lineNum">     976</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[0])] &lt;&lt;  8) ^</span></span>
<span id="L977"><span class="lineNum">     977</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[3])] &lt;&lt; 16) ^</span></span>
<span id="L978"><span class="lineNum">     978</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[2])] &lt;&lt; 24);</span></span>
<span id="L979"><span class="lineNum">     979</span>              : </span>
<span id="L980"><span class="lineNum">     980</span> <span class="tlaUNC">           0 :     t.X[2] = *RK++ ^ \</span></span>
<span id="L981"><span class="lineNum">     981</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[2])]) ^</span></span>
<span id="L982"><span class="lineNum">     982</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[1])] &lt;&lt;  8) ^</span></span>
<span id="L983"><span class="lineNum">     983</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[0])] &lt;&lt; 16) ^</span></span>
<span id="L984"><span class="lineNum">     984</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[3])] &lt;&lt; 24);</span></span>
<span id="L985"><span class="lineNum">     985</span>              : </span>
<span id="L986"><span class="lineNum">     986</span> <span class="tlaUNC">           0 :     t.X[3] = *RK++ ^ \</span></span>
<span id="L987"><span class="lineNum">     987</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_0(t.Y[3])]) ^</span></span>
<span id="L988"><span class="lineNum">     988</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_1(t.Y[2])] &lt;&lt;  8) ^</span></span>
<span id="L989"><span class="lineNum">     989</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_2(t.Y[1])] &lt;&lt; 16) ^</span></span>
<span id="L990"><span class="lineNum">     990</span> <span class="tlaUNC">           0 :              ((uint32_t) RSb[MBEDTLS_BYTE_3(t.Y[0])] &lt;&lt; 24);</span></span>
<span id="L991"><span class="lineNum">     991</span>              : </span>
<span id="L992"><span class="lineNum">     992</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[0], output,  0);</span></span>
<span id="L993"><span class="lineNum">     993</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[1], output,  4);</span></span>
<span id="L994"><span class="lineNum">     994</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[2], output,  8);</span></span>
<span id="L995"><span class="lineNum">     995</span> <span class="tlaUNC">           0 :     MBEDTLS_PUT_UINT32_LE(t.X[3], output, 12);</span></span>
<span id="L996"><span class="lineNum">     996</span>              : </span>
<span id="L997"><span class="lineNum">     997</span> <span class="tlaUNC">           0 :     mbedtls_platform_zeroize(&amp;t, sizeof(t));</span></span>
<span id="L998"><span class="lineNum">     998</span>              : </span>
<span id="L999"><span class="lineNum">     999</span> <span class="tlaUNC">           0 :     return 0;</span></span>
<span id="L1000"><span class="lineNum">    1000</span>              : }</span>
<span id="L1001"><span class="lineNum">    1001</span>              : #endif /* !MBEDTLS_AES_DECRYPT_ALT &amp;&amp; !MBEDTLS_BLOCK_CIPHER_NO_DECRYPT */</span>
<span id="L1002"><span class="lineNum">    1002</span>              : </span>
<span id="L1003"><span class="lineNum">    1003</span>              : /* VIA Padlock and our intrinsics-based implementation of AESNI require</span>
<span id="L1004"><span class="lineNum">    1004</span>              :  * the round keys to be aligned on a 16-byte boundary. We take care of this</span>
<span id="L1005"><span class="lineNum">    1005</span>              :  * before creating them, but the AES context may have moved (this can happen</span>
<span id="L1006"><span class="lineNum">    1006</span>              :  * if the library is called from a language with managed memory), and in later</span>
<span id="L1007"><span class="lineNum">    1007</span>              :  * calls it might have a different alignment with respect to 16-byte memory.</span>
<span id="L1008"><span class="lineNum">    1008</span>              :  * So we may need to realign.</span>
<span id="L1009"><span class="lineNum">    1009</span>              :  */</span>
<span id="L1010"><span class="lineNum">    1010</span> <span class="tlaUNC">           0 : MBEDTLS_MAYBE_UNUSED static void aes_maybe_realign(mbedtls_aes_context *ctx)</span></span>
<span id="L1011"><span class="lineNum">    1011</span>              : {</span>
<span id="L1012"><span class="lineNum">    1012</span> <span class="tlaUNC">           0 :     unsigned new_offset = mbedtls_aes_rk_offset(ctx-&gt;buf);</span></span>
<span id="L1013"><span class="lineNum">    1013</span> <span class="tlaUNC">           0 :     if (new_offset != ctx-&gt;rk_offset) {</span></span>
<span id="L1014"><span class="lineNum">    1014</span> <span class="tlaUNC">           0 :         memmove(ctx-&gt;buf + new_offset,     // new address</span></span>
<span id="L1015"><span class="lineNum">    1015</span> <span class="tlaUNC">           0 :                 ctx-&gt;buf + ctx-&gt;rk_offset, // current address</span></span>
<span id="L1016"><span class="lineNum">    1016</span> <span class="tlaUNC">           0 :                 (ctx-&gt;nr + 1) * 16);       // number of round keys * bytes per rk</span></span>
<span id="L1017"><span class="lineNum">    1017</span> <span class="tlaUNC">           0 :         ctx-&gt;rk_offset = new_offset;</span></span>
<span id="L1018"><span class="lineNum">    1018</span>              :     }</span>
<span id="L1019"><span class="lineNum">    1019</span> <span class="tlaUNC">           0 : }</span></span>
<span id="L1020"><span class="lineNum">    1020</span>              : </span>
<span id="L1021"><span class="lineNum">    1021</span>              : /*</span>
<span id="L1022"><span class="lineNum">    1022</span>              :  * AES-ECB block encryption/decryption</span>
<span id="L1023"><span class="lineNum">    1023</span>              :  */</span>
<span id="L1024"><span class="lineNum">    1024</span> <span class="tlaGNC tlaBgGNC">        3795 : int mbedtls_aes_crypt_ecb(mbedtls_aes_context *ctx,</span></span>
<span id="L1025"><span class="lineNum">    1025</span>              :                           int mode,</span>
<span id="L1026"><span class="lineNum">    1026</span>              :                           const unsigned char input[16],</span>
<span id="L1027"><span class="lineNum">    1027</span>              :                           unsigned char output[16])</span>
<span id="L1028"><span class="lineNum">    1028</span>              : {</span>
<span id="L1029"><span class="lineNum">    1029</span> <span class="tlaGNC">        3795 :     if (mode != MBEDTLS_AES_ENCRYPT &amp;&amp; mode != MBEDTLS_AES_DECRYPT) {</span></span>
<span id="L1030"><span class="lineNum">    1030</span> <span class="tlaUNC tlaBgUNC">           0 :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span></span>
<span id="L1031"><span class="lineNum">    1031</span>              :     }</span>
<span id="L1032"><span class="lineNum">    1032</span>              : </span>
<span id="L1033"><span class="lineNum">    1033</span>              : #if defined(MAY_NEED_TO_ALIGN)</span>
<span id="L1034"><span class="lineNum">    1034</span>              :     aes_maybe_realign(ctx);</span>
<span id="L1035"><span class="lineNum">    1035</span>              : #endif</span>
<span id="L1036"><span class="lineNum">    1036</span>              : </span>
<span id="L1037"><span class="lineNum">    1037</span>              : #if defined(MBEDTLS_AESNI_HAVE_CODE)</span>
<span id="L1038"><span class="lineNum">    1038</span> <span class="tlaGNC tlaBgGNC">        3795 :     if (mbedtls_aesni_has_support(MBEDTLS_AESNI_AES)) {</span></span>
<span id="L1039"><span class="lineNum">    1039</span> <span class="tlaGNC">        3795 :         return mbedtls_aesni_crypt_ecb(ctx, mode, input, output);</span></span>
<span id="L1040"><span class="lineNum">    1040</span>              :     }</span>
<span id="L1041"><span class="lineNum">    1041</span>              : #endif</span>
<span id="L1042"><span class="lineNum">    1042</span>              : </span>
<span id="L1043"><span class="lineNum">    1043</span>              : #if defined(MBEDTLS_AESCE_HAVE_CODE)</span>
<span id="L1044"><span class="lineNum">    1044</span>              :     if (MBEDTLS_AESCE_HAS_SUPPORT()) {</span>
<span id="L1045"><span class="lineNum">    1045</span>              :         return mbedtls_aesce_crypt_ecb(ctx, mode, input, output);</span>
<span id="L1046"><span class="lineNum">    1046</span>              :     }</span>
<span id="L1047"><span class="lineNum">    1047</span>              : #endif</span>
<span id="L1048"><span class="lineNum">    1048</span>              : </span>
<span id="L1049"><span class="lineNum">    1049</span>              : #if defined(MBEDTLS_VIA_PADLOCK_HAVE_CODE)</span>
<span id="L1050"><span class="lineNum">    1050</span>              :     if (aes_padlock_ace &gt; 0) {</span>
<span id="L1051"><span class="lineNum">    1051</span>              :         return mbedtls_padlock_xcryptecb(ctx, mode, input, output);</span>
<span id="L1052"><span class="lineNum">    1052</span>              :     }</span>
<span id="L1053"><span class="lineNum">    1053</span>              : #endif</span>
<span id="L1054"><span class="lineNum">    1054</span>              : </span>
<span id="L1055"><span class="lineNum">    1055</span>              : #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L1056"><span class="lineNum">    1056</span>              : #if !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L1057"><span class="lineNum">    1057</span> <span class="tlaUNC tlaBgUNC">           0 :     if (mode == MBEDTLS_AES_DECRYPT) {</span></span>
<span id="L1058"><span class="lineNum">    1058</span> <span class="tlaUNC">           0 :         return mbedtls_internal_aes_decrypt(ctx, input, output);</span></span>
<span id="L1059"><span class="lineNum">    1059</span>              :     } else</span>
<span id="L1060"><span class="lineNum">    1060</span>              : #endif</span>
<span id="L1061"><span class="lineNum">    1061</span>              :     {</span>
<span id="L1062"><span class="lineNum">    1062</span> <span class="tlaUNC">           0 :         return mbedtls_internal_aes_encrypt(ctx, input, output);</span></span>
<span id="L1063"><span class="lineNum">    1063</span>              :     }</span>
<span id="L1064"><span class="lineNum">    1064</span>              : #endif /* !MBEDTLS_AES_USE_HARDWARE_ONLY */</span>
<span id="L1065"><span class="lineNum">    1065</span>              : }</span>
<span id="L1066"><span class="lineNum">    1066</span>              : </span>
<span id="L1067"><span class="lineNum">    1067</span>              : #if defined(MBEDTLS_CIPHER_MODE_CBC)</span>
<span id="L1068"><span class="lineNum">    1068</span>              : </span>
<span id="L1069"><span class="lineNum">    1069</span>              : /*</span>
<span id="L1070"><span class="lineNum">    1070</span>              :  * AES-CBC buffer encryption/decryption</span>
<span id="L1071"><span class="lineNum">    1071</span>              :  */</span>
<span id="L1072"><span class="lineNum">    1072</span>              : int mbedtls_aes_crypt_cbc(mbedtls_aes_context *ctx,</span>
<span id="L1073"><span class="lineNum">    1073</span>              :                           int mode,</span>
<span id="L1074"><span class="lineNum">    1074</span>              :                           size_t length,</span>
<span id="L1075"><span class="lineNum">    1075</span>              :                           unsigned char iv[16],</span>
<span id="L1076"><span class="lineNum">    1076</span>              :                           const unsigned char *input,</span>
<span id="L1077"><span class="lineNum">    1077</span>              :                           unsigned char *output)</span>
<span id="L1078"><span class="lineNum">    1078</span>              : {</span>
<span id="L1079"><span class="lineNum">    1079</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L1080"><span class="lineNum">    1080</span>              :     unsigned char temp[16];</span>
<span id="L1081"><span class="lineNum">    1081</span>              : </span>
<span id="L1082"><span class="lineNum">    1082</span>              :     if (mode != MBEDTLS_AES_ENCRYPT &amp;&amp; mode != MBEDTLS_AES_DECRYPT) {</span>
<span id="L1083"><span class="lineNum">    1083</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1084"><span class="lineNum">    1084</span>              :     }</span>
<span id="L1085"><span class="lineNum">    1085</span>              : </span>
<span id="L1086"><span class="lineNum">    1086</span>              :     /* Nothing to do if length is zero. */</span>
<span id="L1087"><span class="lineNum">    1087</span>              :     if (length == 0) {</span>
<span id="L1088"><span class="lineNum">    1088</span>              :         return 0;</span>
<span id="L1089"><span class="lineNum">    1089</span>              :     }</span>
<span id="L1090"><span class="lineNum">    1090</span>              : </span>
<span id="L1091"><span class="lineNum">    1091</span>              :     if (length % 16) {</span>
<span id="L1092"><span class="lineNum">    1092</span>              :         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;</span>
<span id="L1093"><span class="lineNum">    1093</span>              :     }</span>
<span id="L1094"><span class="lineNum">    1094</span>              : </span>
<span id="L1095"><span class="lineNum">    1095</span>              : #if defined(MBEDTLS_VIA_PADLOCK_HAVE_CODE)</span>
<span id="L1096"><span class="lineNum">    1096</span>              :     if (aes_padlock_ace &gt; 0) {</span>
<span id="L1097"><span class="lineNum">    1097</span>              :         if (mbedtls_padlock_xcryptcbc(ctx, mode, length, iv, input, output) == 0) {</span>
<span id="L1098"><span class="lineNum">    1098</span>              :             return 0;</span>
<span id="L1099"><span class="lineNum">    1099</span>              :         }</span>
<span id="L1100"><span class="lineNum">    1100</span>              : </span>
<span id="L1101"><span class="lineNum">    1101</span>              :         // If padlock data misaligned, we just fall back to</span>
<span id="L1102"><span class="lineNum">    1102</span>              :         // unaccelerated mode</span>
<span id="L1103"><span class="lineNum">    1103</span>              :         //</span>
<span id="L1104"><span class="lineNum">    1104</span>              :     }</span>
<span id="L1105"><span class="lineNum">    1105</span>              : #endif</span>
<span id="L1106"><span class="lineNum">    1106</span>              : </span>
<span id="L1107"><span class="lineNum">    1107</span>              :     const unsigned char *ivp = iv;</span>
<span id="L1108"><span class="lineNum">    1108</span>              : </span>
<span id="L1109"><span class="lineNum">    1109</span>              :     if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L1110"><span class="lineNum">    1110</span>              :         while (length &gt; 0) {</span>
<span id="L1111"><span class="lineNum">    1111</span>              :             memcpy(temp, input, 16);</span>
<span id="L1112"><span class="lineNum">    1112</span>              :             ret = mbedtls_aes_crypt_ecb(ctx, mode, input, output);</span>
<span id="L1113"><span class="lineNum">    1113</span>              :             if (ret != 0) {</span>
<span id="L1114"><span class="lineNum">    1114</span>              :                 goto exit;</span>
<span id="L1115"><span class="lineNum">    1115</span>              :             }</span>
<span id="L1116"><span class="lineNum">    1116</span>              :             /* Avoid using the NEON implementation of mbedtls_xor. Because of the dependency on</span>
<span id="L1117"><span class="lineNum">    1117</span>              :              * the result for the next block in CBC, and the cost of transferring that data from</span>
<span id="L1118"><span class="lineNum">    1118</span>              :              * NEON registers, NEON is slower on aarch64. */</span>
<span id="L1119"><span class="lineNum">    1119</span>              :             mbedtls_xor_no_simd(output, output, iv, 16);</span>
<span id="L1120"><span class="lineNum">    1120</span>              : </span>
<span id="L1121"><span class="lineNum">    1121</span>              :             memcpy(iv, temp, 16);</span>
<span id="L1122"><span class="lineNum">    1122</span>              : </span>
<span id="L1123"><span class="lineNum">    1123</span>              :             input  += 16;</span>
<span id="L1124"><span class="lineNum">    1124</span>              :             output += 16;</span>
<span id="L1125"><span class="lineNum">    1125</span>              :             length -= 16;</span>
<span id="L1126"><span class="lineNum">    1126</span>              :         }</span>
<span id="L1127"><span class="lineNum">    1127</span>              :     } else {</span>
<span id="L1128"><span class="lineNum">    1128</span>              :         while (length &gt; 0) {</span>
<span id="L1129"><span class="lineNum">    1129</span>              :             mbedtls_xor_no_simd(output, input, ivp, 16);</span>
<span id="L1130"><span class="lineNum">    1130</span>              : </span>
<span id="L1131"><span class="lineNum">    1131</span>              :             ret = mbedtls_aes_crypt_ecb(ctx, mode, output, output);</span>
<span id="L1132"><span class="lineNum">    1132</span>              :             if (ret != 0) {</span>
<span id="L1133"><span class="lineNum">    1133</span>              :                 goto exit;</span>
<span id="L1134"><span class="lineNum">    1134</span>              :             }</span>
<span id="L1135"><span class="lineNum">    1135</span>              :             ivp = output;</span>
<span id="L1136"><span class="lineNum">    1136</span>              : </span>
<span id="L1137"><span class="lineNum">    1137</span>              :             input  += 16;</span>
<span id="L1138"><span class="lineNum">    1138</span>              :             output += 16;</span>
<span id="L1139"><span class="lineNum">    1139</span>              :             length -= 16;</span>
<span id="L1140"><span class="lineNum">    1140</span>              :         }</span>
<span id="L1141"><span class="lineNum">    1141</span>              :         memcpy(iv, ivp, 16);</span>
<span id="L1142"><span class="lineNum">    1142</span>              :     }</span>
<span id="L1143"><span class="lineNum">    1143</span>              :     ret = 0;</span>
<span id="L1144"><span class="lineNum">    1144</span>              : </span>
<span id="L1145"><span class="lineNum">    1145</span>              : exit:</span>
<span id="L1146"><span class="lineNum">    1146</span>              :     return ret;</span>
<span id="L1147"><span class="lineNum">    1147</span>              : }</span>
<span id="L1148"><span class="lineNum">    1148</span>              : #endif /* MBEDTLS_CIPHER_MODE_CBC */</span>
<span id="L1149"><span class="lineNum">    1149</span>              : </span>
<span id="L1150"><span class="lineNum">    1150</span>              : #if defined(MBEDTLS_CIPHER_MODE_XTS)</span>
<span id="L1151"><span class="lineNum">    1151</span>              : </span>
<span id="L1152"><span class="lineNum">    1152</span>              : typedef unsigned char mbedtls_be128[16];</span>
<span id="L1153"><span class="lineNum">    1153</span>              : </span>
<span id="L1154"><span class="lineNum">    1154</span>              : /*</span>
<span id="L1155"><span class="lineNum">    1155</span>              :  * GF(2^128) multiplication function</span>
<span id="L1156"><span class="lineNum">    1156</span>              :  *</span>
<span id="L1157"><span class="lineNum">    1157</span>              :  * This function multiplies a field element by x in the polynomial field</span>
<span id="L1158"><span class="lineNum">    1158</span>              :  * representation. It uses 64-bit word operations to gain speed but compensates</span>
<span id="L1159"><span class="lineNum">    1159</span>              :  * for machine endianness and hence works correctly on both big and little</span>
<span id="L1160"><span class="lineNum">    1160</span>              :  * endian machines.</span>
<span id="L1161"><span class="lineNum">    1161</span>              :  */</span>
<span id="L1162"><span class="lineNum">    1162</span>              : #if defined(MBEDTLS_AESCE_C) || defined(MBEDTLS_AESNI_C)</span>
<span id="L1163"><span class="lineNum">    1163</span>              : MBEDTLS_OPTIMIZE_FOR_PERFORMANCE</span>
<span id="L1164"><span class="lineNum">    1164</span>              : #endif</span>
<span id="L1165"><span class="lineNum">    1165</span>              : static inline void mbedtls_gf128mul_x_ble(unsigned char r[16],</span>
<span id="L1166"><span class="lineNum">    1166</span>              :                                           const unsigned char x[16])</span>
<span id="L1167"><span class="lineNum">    1167</span>              : {</span>
<span id="L1168"><span class="lineNum">    1168</span>              :     uint64_t a, b, ra, rb;</span>
<span id="L1169"><span class="lineNum">    1169</span>              : </span>
<span id="L1170"><span class="lineNum">    1170</span>              :     a = MBEDTLS_GET_UINT64_LE(x, 0);</span>
<span id="L1171"><span class="lineNum">    1171</span>              :     b = MBEDTLS_GET_UINT64_LE(x, 8);</span>
<span id="L1172"><span class="lineNum">    1172</span>              : </span>
<span id="L1173"><span class="lineNum">    1173</span>              :     ra = (a &lt;&lt; 1)  ^ 0x0087 &gt;&gt; (8 - ((b &gt;&gt; 63) &lt;&lt; 3));</span>
<span id="L1174"><span class="lineNum">    1174</span>              :     rb = (a &gt;&gt; 63) | (b &lt;&lt; 1);</span>
<span id="L1175"><span class="lineNum">    1175</span>              : </span>
<span id="L1176"><span class="lineNum">    1176</span>              :     MBEDTLS_PUT_UINT64_LE(ra, r, 0);</span>
<span id="L1177"><span class="lineNum">    1177</span>              :     MBEDTLS_PUT_UINT64_LE(rb, r, 8);</span>
<span id="L1178"><span class="lineNum">    1178</span>              : }</span>
<span id="L1179"><span class="lineNum">    1179</span>              : </span>
<span id="L1180"><span class="lineNum">    1180</span>              : /*</span>
<span id="L1181"><span class="lineNum">    1181</span>              :  * AES-XTS buffer encryption/decryption</span>
<span id="L1182"><span class="lineNum">    1182</span>              :  *</span>
<span id="L1183"><span class="lineNum">    1183</span>              :  * Use of MBEDTLS_OPTIMIZE_FOR_PERFORMANCE here and for mbedtls_gf128mul_x_ble()</span>
<span id="L1184"><span class="lineNum">    1184</span>              :  * is a 3x performance improvement for gcc -Os, if we have hardware AES support.</span>
<span id="L1185"><span class="lineNum">    1185</span>              :  */</span>
<span id="L1186"><span class="lineNum">    1186</span>              : #if defined(MBEDTLS_AESCE_C) || defined(MBEDTLS_AESNI_C)</span>
<span id="L1187"><span class="lineNum">    1187</span>              : MBEDTLS_OPTIMIZE_FOR_PERFORMANCE</span>
<span id="L1188"><span class="lineNum">    1188</span>              : #endif</span>
<span id="L1189"><span class="lineNum">    1189</span>              : int mbedtls_aes_crypt_xts(mbedtls_aes_xts_context *ctx,</span>
<span id="L1190"><span class="lineNum">    1190</span>              :                           int mode,</span>
<span id="L1191"><span class="lineNum">    1191</span>              :                           size_t length,</span>
<span id="L1192"><span class="lineNum">    1192</span>              :                           const unsigned char data_unit[16],</span>
<span id="L1193"><span class="lineNum">    1193</span>              :                           const unsigned char *input,</span>
<span id="L1194"><span class="lineNum">    1194</span>              :                           unsigned char *output)</span>
<span id="L1195"><span class="lineNum">    1195</span>              : {</span>
<span id="L1196"><span class="lineNum">    1196</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L1197"><span class="lineNum">    1197</span>              :     size_t blocks = length / 16;</span>
<span id="L1198"><span class="lineNum">    1198</span>              :     size_t leftover = length % 16;</span>
<span id="L1199"><span class="lineNum">    1199</span>              :     unsigned char tweak[16];</span>
<span id="L1200"><span class="lineNum">    1200</span>              :     unsigned char prev_tweak[16];</span>
<span id="L1201"><span class="lineNum">    1201</span>              :     unsigned char tmp[16];</span>
<span id="L1202"><span class="lineNum">    1202</span>              : </span>
<span id="L1203"><span class="lineNum">    1203</span>              :     if (mode != MBEDTLS_AES_ENCRYPT &amp;&amp; mode != MBEDTLS_AES_DECRYPT) {</span>
<span id="L1204"><span class="lineNum">    1204</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1205"><span class="lineNum">    1205</span>              :     }</span>
<span id="L1206"><span class="lineNum">    1206</span>              : </span>
<span id="L1207"><span class="lineNum">    1207</span>              :     /* Data units must be at least 16 bytes long. */</span>
<span id="L1208"><span class="lineNum">    1208</span>              :     if (length &lt; 16) {</span>
<span id="L1209"><span class="lineNum">    1209</span>              :         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;</span>
<span id="L1210"><span class="lineNum">    1210</span>              :     }</span>
<span id="L1211"><span class="lineNum">    1211</span>              : </span>
<span id="L1212"><span class="lineNum">    1212</span>              :     /* NIST SP 800-38E disallows data units larger than 2**20 blocks. */</span>
<span id="L1213"><span class="lineNum">    1213</span>              :     if (length &gt; (1 &lt;&lt; 20) * 16) {</span>
<span id="L1214"><span class="lineNum">    1214</span>              :         return MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH;</span>
<span id="L1215"><span class="lineNum">    1215</span>              :     }</span>
<span id="L1216"><span class="lineNum">    1216</span>              : </span>
<span id="L1217"><span class="lineNum">    1217</span>              :     /* Compute the tweak. */</span>
<span id="L1218"><span class="lineNum">    1218</span>              :     ret = mbedtls_aes_crypt_ecb(&amp;ctx-&gt;tweak, MBEDTLS_AES_ENCRYPT,</span>
<span id="L1219"><span class="lineNum">    1219</span>              :                                 data_unit, tweak);</span>
<span id="L1220"><span class="lineNum">    1220</span>              :     if (ret != 0) {</span>
<span id="L1221"><span class="lineNum">    1221</span>              :         return ret;</span>
<span id="L1222"><span class="lineNum">    1222</span>              :     }</span>
<span id="L1223"><span class="lineNum">    1223</span>              : </span>
<span id="L1224"><span class="lineNum">    1224</span>              :     while (blocks--) {</span>
<span id="L1225"><span class="lineNum">    1225</span>              :         if (MBEDTLS_UNLIKELY(leftover &amp;&amp; (mode == MBEDTLS_AES_DECRYPT) &amp;&amp; blocks == 0)) {</span>
<span id="L1226"><span class="lineNum">    1226</span>              :             /* We are on the last block in a decrypt operation that has</span>
<span id="L1227"><span class="lineNum">    1227</span>              :              * leftover bytes, so we need to use the next tweak for this block,</span>
<span id="L1228"><span class="lineNum">    1228</span>              :              * and this tweak for the leftover bytes. Save the current tweak for</span>
<span id="L1229"><span class="lineNum">    1229</span>              :              * the leftovers and then update the current tweak for use on this,</span>
<span id="L1230"><span class="lineNum">    1230</span>              :              * the last full block. */</span>
<span id="L1231"><span class="lineNum">    1231</span>              :             memcpy(prev_tweak, tweak, sizeof(tweak));</span>
<span id="L1232"><span class="lineNum">    1232</span>              :             mbedtls_gf128mul_x_ble(tweak, tweak);</span>
<span id="L1233"><span class="lineNum">    1233</span>              :         }</span>
<span id="L1234"><span class="lineNum">    1234</span>              : </span>
<span id="L1235"><span class="lineNum">    1235</span>              :         mbedtls_xor(tmp, input, tweak, 16);</span>
<span id="L1236"><span class="lineNum">    1236</span>              : </span>
<span id="L1237"><span class="lineNum">    1237</span>              :         ret = mbedtls_aes_crypt_ecb(&amp;ctx-&gt;crypt, mode, tmp, tmp);</span>
<span id="L1238"><span class="lineNum">    1238</span>              :         if (ret != 0) {</span>
<span id="L1239"><span class="lineNum">    1239</span>              :             return ret;</span>
<span id="L1240"><span class="lineNum">    1240</span>              :         }</span>
<span id="L1241"><span class="lineNum">    1241</span>              : </span>
<span id="L1242"><span class="lineNum">    1242</span>              :         mbedtls_xor(output, tmp, tweak, 16);</span>
<span id="L1243"><span class="lineNum">    1243</span>              : </span>
<span id="L1244"><span class="lineNum">    1244</span>              :         /* Update the tweak for the next block. */</span>
<span id="L1245"><span class="lineNum">    1245</span>              :         mbedtls_gf128mul_x_ble(tweak, tweak);</span>
<span id="L1246"><span class="lineNum">    1246</span>              : </span>
<span id="L1247"><span class="lineNum">    1247</span>              :         output += 16;</span>
<span id="L1248"><span class="lineNum">    1248</span>              :         input += 16;</span>
<span id="L1249"><span class="lineNum">    1249</span>              :     }</span>
<span id="L1250"><span class="lineNum">    1250</span>              : </span>
<span id="L1251"><span class="lineNum">    1251</span>              :     if (leftover) {</span>
<span id="L1252"><span class="lineNum">    1252</span>              :         /* If we are on the leftover bytes in a decrypt operation, we need to</span>
<span id="L1253"><span class="lineNum">    1253</span>              :          * use the previous tweak for these bytes (as saved in prev_tweak). */</span>
<span id="L1254"><span class="lineNum">    1254</span>              :         unsigned char *t = mode == MBEDTLS_AES_DECRYPT ? prev_tweak : tweak;</span>
<span id="L1255"><span class="lineNum">    1255</span>              : </span>
<span id="L1256"><span class="lineNum">    1256</span>              :         /* We are now on the final part of the data unit, which doesn't divide</span>
<span id="L1257"><span class="lineNum">    1257</span>              :          * evenly by 16. It's time for ciphertext stealing. */</span>
<span id="L1258"><span class="lineNum">    1258</span>              :         size_t i;</span>
<span id="L1259"><span class="lineNum">    1259</span>              :         unsigned char *prev_output = output - 16;</span>
<span id="L1260"><span class="lineNum">    1260</span>              : </span>
<span id="L1261"><span class="lineNum">    1261</span>              :         /* Copy ciphertext bytes from the previous block to our output for each</span>
<span id="L1262"><span class="lineNum">    1262</span>              :          * byte of ciphertext we won't steal. */</span>
<span id="L1263"><span class="lineNum">    1263</span>              :         for (i = 0; i &lt; leftover; i++) {</span>
<span id="L1264"><span class="lineNum">    1264</span>              :             output[i] = prev_output[i];</span>
<span id="L1265"><span class="lineNum">    1265</span>              :         }</span>
<span id="L1266"><span class="lineNum">    1266</span>              : </span>
<span id="L1267"><span class="lineNum">    1267</span>              :         /* Copy the remainder of the input for this final round. */</span>
<span id="L1268"><span class="lineNum">    1268</span>              :         mbedtls_xor(tmp, input, t, leftover);</span>
<span id="L1269"><span class="lineNum">    1269</span>              : </span>
<span id="L1270"><span class="lineNum">    1270</span>              :         /* Copy ciphertext bytes from the previous block for input in this</span>
<span id="L1271"><span class="lineNum">    1271</span>              :          * round. */</span>
<span id="L1272"><span class="lineNum">    1272</span>              :         mbedtls_xor(tmp + i, prev_output + i, t + i, 16 - i);</span>
<span id="L1273"><span class="lineNum">    1273</span>              : </span>
<span id="L1274"><span class="lineNum">    1274</span>              :         ret = mbedtls_aes_crypt_ecb(&amp;ctx-&gt;crypt, mode, tmp, tmp);</span>
<span id="L1275"><span class="lineNum">    1275</span>              :         if (ret != 0) {</span>
<span id="L1276"><span class="lineNum">    1276</span>              :             return ret;</span>
<span id="L1277"><span class="lineNum">    1277</span>              :         }</span>
<span id="L1278"><span class="lineNum">    1278</span>              : </span>
<span id="L1279"><span class="lineNum">    1279</span>              :         /* Write the result back to the previous block, overriding the previous</span>
<span id="L1280"><span class="lineNum">    1280</span>              :          * output we copied. */</span>
<span id="L1281"><span class="lineNum">    1281</span>              :         mbedtls_xor(prev_output, tmp, t, 16);</span>
<span id="L1282"><span class="lineNum">    1282</span>              :     }</span>
<span id="L1283"><span class="lineNum">    1283</span>              : </span>
<span id="L1284"><span class="lineNum">    1284</span>              :     return 0;</span>
<span id="L1285"><span class="lineNum">    1285</span>              : }</span>
<span id="L1286"><span class="lineNum">    1286</span>              : #endif /* MBEDTLS_CIPHER_MODE_XTS */</span>
<span id="L1287"><span class="lineNum">    1287</span>              : </span>
<span id="L1288"><span class="lineNum">    1288</span>              : #if defined(MBEDTLS_CIPHER_MODE_CFB)</span>
<span id="L1289"><span class="lineNum">    1289</span>              : /*</span>
<span id="L1290"><span class="lineNum">    1290</span>              :  * AES-CFB128 buffer encryption/decryption</span>
<span id="L1291"><span class="lineNum">    1291</span>              :  */</span>
<span id="L1292"><span class="lineNum">    1292</span>              : int mbedtls_aes_crypt_cfb128(mbedtls_aes_context *ctx,</span>
<span id="L1293"><span class="lineNum">    1293</span>              :                              int mode,</span>
<span id="L1294"><span class="lineNum">    1294</span>              :                              size_t length,</span>
<span id="L1295"><span class="lineNum">    1295</span>              :                              size_t *iv_off,</span>
<span id="L1296"><span class="lineNum">    1296</span>              :                              unsigned char iv[16],</span>
<span id="L1297"><span class="lineNum">    1297</span>              :                              const unsigned char *input,</span>
<span id="L1298"><span class="lineNum">    1298</span>              :                              unsigned char *output)</span>
<span id="L1299"><span class="lineNum">    1299</span>              : {</span>
<span id="L1300"><span class="lineNum">    1300</span>              :     int c;</span>
<span id="L1301"><span class="lineNum">    1301</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L1302"><span class="lineNum">    1302</span>              :     size_t n;</span>
<span id="L1303"><span class="lineNum">    1303</span>              : </span>
<span id="L1304"><span class="lineNum">    1304</span>              :     if (mode != MBEDTLS_AES_ENCRYPT &amp;&amp; mode != MBEDTLS_AES_DECRYPT) {</span>
<span id="L1305"><span class="lineNum">    1305</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1306"><span class="lineNum">    1306</span>              :     }</span>
<span id="L1307"><span class="lineNum">    1307</span>              : </span>
<span id="L1308"><span class="lineNum">    1308</span>              :     n = *iv_off;</span>
<span id="L1309"><span class="lineNum">    1309</span>              : </span>
<span id="L1310"><span class="lineNum">    1310</span>              :     if (n &gt; 15) {</span>
<span id="L1311"><span class="lineNum">    1311</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1312"><span class="lineNum">    1312</span>              :     }</span>
<span id="L1313"><span class="lineNum">    1313</span>              : </span>
<span id="L1314"><span class="lineNum">    1314</span>              :     if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L1315"><span class="lineNum">    1315</span>              :         while (length--) {</span>
<span id="L1316"><span class="lineNum">    1316</span>              :             if (n == 0) {</span>
<span id="L1317"><span class="lineNum">    1317</span>              :                 ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);</span>
<span id="L1318"><span class="lineNum">    1318</span>              :                 if (ret != 0) {</span>
<span id="L1319"><span class="lineNum">    1319</span>              :                     goto exit;</span>
<span id="L1320"><span class="lineNum">    1320</span>              :                 }</span>
<span id="L1321"><span class="lineNum">    1321</span>              :             }</span>
<span id="L1322"><span class="lineNum">    1322</span>              : </span>
<span id="L1323"><span class="lineNum">    1323</span>              :             c = *input++;</span>
<span id="L1324"><span class="lineNum">    1324</span>              :             *output++ = (unsigned char) (c ^ iv[n]);</span>
<span id="L1325"><span class="lineNum">    1325</span>              :             iv[n] = (unsigned char) c;</span>
<span id="L1326"><span class="lineNum">    1326</span>              : </span>
<span id="L1327"><span class="lineNum">    1327</span>              :             n = (n + 1) &amp; 0x0F;</span>
<span id="L1328"><span class="lineNum">    1328</span>              :         }</span>
<span id="L1329"><span class="lineNum">    1329</span>              :     } else {</span>
<span id="L1330"><span class="lineNum">    1330</span>              :         while (length--) {</span>
<span id="L1331"><span class="lineNum">    1331</span>              :             if (n == 0) {</span>
<span id="L1332"><span class="lineNum">    1332</span>              :                 ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);</span>
<span id="L1333"><span class="lineNum">    1333</span>              :                 if (ret != 0) {</span>
<span id="L1334"><span class="lineNum">    1334</span>              :                     goto exit;</span>
<span id="L1335"><span class="lineNum">    1335</span>              :                 }</span>
<span id="L1336"><span class="lineNum">    1336</span>              :             }</span>
<span id="L1337"><span class="lineNum">    1337</span>              : </span>
<span id="L1338"><span class="lineNum">    1338</span>              :             iv[n] = *output++ = (unsigned char) (iv[n] ^ *input++);</span>
<span id="L1339"><span class="lineNum">    1339</span>              : </span>
<span id="L1340"><span class="lineNum">    1340</span>              :             n = (n + 1) &amp; 0x0F;</span>
<span id="L1341"><span class="lineNum">    1341</span>              :         }</span>
<span id="L1342"><span class="lineNum">    1342</span>              :     }</span>
<span id="L1343"><span class="lineNum">    1343</span>              : </span>
<span id="L1344"><span class="lineNum">    1344</span>              :     *iv_off = n;</span>
<span id="L1345"><span class="lineNum">    1345</span>              :     ret = 0;</span>
<span id="L1346"><span class="lineNum">    1346</span>              : </span>
<span id="L1347"><span class="lineNum">    1347</span>              : exit:</span>
<span id="L1348"><span class="lineNum">    1348</span>              :     return ret;</span>
<span id="L1349"><span class="lineNum">    1349</span>              : }</span>
<span id="L1350"><span class="lineNum">    1350</span>              : </span>
<span id="L1351"><span class="lineNum">    1351</span>              : /*</span>
<span id="L1352"><span class="lineNum">    1352</span>              :  * AES-CFB8 buffer encryption/decryption</span>
<span id="L1353"><span class="lineNum">    1353</span>              :  */</span>
<span id="L1354"><span class="lineNum">    1354</span>              : int mbedtls_aes_crypt_cfb8(mbedtls_aes_context *ctx,</span>
<span id="L1355"><span class="lineNum">    1355</span>              :                            int mode,</span>
<span id="L1356"><span class="lineNum">    1356</span>              :                            size_t length,</span>
<span id="L1357"><span class="lineNum">    1357</span>              :                            unsigned char iv[16],</span>
<span id="L1358"><span class="lineNum">    1358</span>              :                            const unsigned char *input,</span>
<span id="L1359"><span class="lineNum">    1359</span>              :                            unsigned char *output)</span>
<span id="L1360"><span class="lineNum">    1360</span>              : {</span>
<span id="L1361"><span class="lineNum">    1361</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L1362"><span class="lineNum">    1362</span>              :     unsigned char c;</span>
<span id="L1363"><span class="lineNum">    1363</span>              :     unsigned char ov[17];</span>
<span id="L1364"><span class="lineNum">    1364</span>              : </span>
<span id="L1365"><span class="lineNum">    1365</span>              :     if (mode != MBEDTLS_AES_ENCRYPT &amp;&amp; mode != MBEDTLS_AES_DECRYPT) {</span>
<span id="L1366"><span class="lineNum">    1366</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1367"><span class="lineNum">    1367</span>              :     }</span>
<span id="L1368"><span class="lineNum">    1368</span>              :     while (length--) {</span>
<span id="L1369"><span class="lineNum">    1369</span>              :         memcpy(ov, iv, 16);</span>
<span id="L1370"><span class="lineNum">    1370</span>              :         ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);</span>
<span id="L1371"><span class="lineNum">    1371</span>              :         if (ret != 0) {</span>
<span id="L1372"><span class="lineNum">    1372</span>              :             goto exit;</span>
<span id="L1373"><span class="lineNum">    1373</span>              :         }</span>
<span id="L1374"><span class="lineNum">    1374</span>              : </span>
<span id="L1375"><span class="lineNum">    1375</span>              :         if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L1376"><span class="lineNum">    1376</span>              :             ov[16] = *input;</span>
<span id="L1377"><span class="lineNum">    1377</span>              :         }</span>
<span id="L1378"><span class="lineNum">    1378</span>              : </span>
<span id="L1379"><span class="lineNum">    1379</span>              :         c = *output++ = (unsigned char) (iv[0] ^ *input++);</span>
<span id="L1380"><span class="lineNum">    1380</span>              : </span>
<span id="L1381"><span class="lineNum">    1381</span>              :         if (mode == MBEDTLS_AES_ENCRYPT) {</span>
<span id="L1382"><span class="lineNum">    1382</span>              :             ov[16] = c;</span>
<span id="L1383"><span class="lineNum">    1383</span>              :         }</span>
<span id="L1384"><span class="lineNum">    1384</span>              : </span>
<span id="L1385"><span class="lineNum">    1385</span>              :         memcpy(iv, ov + 1, 16);</span>
<span id="L1386"><span class="lineNum">    1386</span>              :     }</span>
<span id="L1387"><span class="lineNum">    1387</span>              :     ret = 0;</span>
<span id="L1388"><span class="lineNum">    1388</span>              : </span>
<span id="L1389"><span class="lineNum">    1389</span>              : exit:</span>
<span id="L1390"><span class="lineNum">    1390</span>              :     return ret;</span>
<span id="L1391"><span class="lineNum">    1391</span>              : }</span>
<span id="L1392"><span class="lineNum">    1392</span>              : #endif /* MBEDTLS_CIPHER_MODE_CFB */</span>
<span id="L1393"><span class="lineNum">    1393</span>              : </span>
<span id="L1394"><span class="lineNum">    1394</span>              : #if defined(MBEDTLS_CIPHER_MODE_OFB)</span>
<span id="L1395"><span class="lineNum">    1395</span>              : /*</span>
<span id="L1396"><span class="lineNum">    1396</span>              :  * AES-OFB (Output Feedback Mode) buffer encryption/decryption</span>
<span id="L1397"><span class="lineNum">    1397</span>              :  */</span>
<span id="L1398"><span class="lineNum">    1398</span>              : int mbedtls_aes_crypt_ofb(mbedtls_aes_context *ctx,</span>
<span id="L1399"><span class="lineNum">    1399</span>              :                           size_t length,</span>
<span id="L1400"><span class="lineNum">    1400</span>              :                           size_t *iv_off,</span>
<span id="L1401"><span class="lineNum">    1401</span>              :                           unsigned char iv[16],</span>
<span id="L1402"><span class="lineNum">    1402</span>              :                           const unsigned char *input,</span>
<span id="L1403"><span class="lineNum">    1403</span>              :                           unsigned char *output)</span>
<span id="L1404"><span class="lineNum">    1404</span>              : {</span>
<span id="L1405"><span class="lineNum">    1405</span>              :     int ret = 0;</span>
<span id="L1406"><span class="lineNum">    1406</span>              :     size_t n;</span>
<span id="L1407"><span class="lineNum">    1407</span>              : </span>
<span id="L1408"><span class="lineNum">    1408</span>              :     n = *iv_off;</span>
<span id="L1409"><span class="lineNum">    1409</span>              : </span>
<span id="L1410"><span class="lineNum">    1410</span>              :     if (n &gt; 15) {</span>
<span id="L1411"><span class="lineNum">    1411</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1412"><span class="lineNum">    1412</span>              :     }</span>
<span id="L1413"><span class="lineNum">    1413</span>              : </span>
<span id="L1414"><span class="lineNum">    1414</span>              :     while (length--) {</span>
<span id="L1415"><span class="lineNum">    1415</span>              :         if (n == 0) {</span>
<span id="L1416"><span class="lineNum">    1416</span>              :             ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, iv, iv);</span>
<span id="L1417"><span class="lineNum">    1417</span>              :             if (ret != 0) {</span>
<span id="L1418"><span class="lineNum">    1418</span>              :                 goto exit;</span>
<span id="L1419"><span class="lineNum">    1419</span>              :             }</span>
<span id="L1420"><span class="lineNum">    1420</span>              :         }</span>
<span id="L1421"><span class="lineNum">    1421</span>              :         *output++ =  *input++ ^ iv[n];</span>
<span id="L1422"><span class="lineNum">    1422</span>              : </span>
<span id="L1423"><span class="lineNum">    1423</span>              :         n = (n + 1) &amp; 0x0F;</span>
<span id="L1424"><span class="lineNum">    1424</span>              :     }</span>
<span id="L1425"><span class="lineNum">    1425</span>              : </span>
<span id="L1426"><span class="lineNum">    1426</span>              :     *iv_off = n;</span>
<span id="L1427"><span class="lineNum">    1427</span>              : </span>
<span id="L1428"><span class="lineNum">    1428</span>              : exit:</span>
<span id="L1429"><span class="lineNum">    1429</span>              :     return ret;</span>
<span id="L1430"><span class="lineNum">    1430</span>              : }</span>
<span id="L1431"><span class="lineNum">    1431</span>              : #endif /* MBEDTLS_CIPHER_MODE_OFB */</span>
<span id="L1432"><span class="lineNum">    1432</span>              : </span>
<span id="L1433"><span class="lineNum">    1433</span>              : #if defined(MBEDTLS_CIPHER_MODE_CTR)</span>
<span id="L1434"><span class="lineNum">    1434</span>              : /*</span>
<span id="L1435"><span class="lineNum">    1435</span>              :  * AES-CTR buffer encryption/decryption</span>
<span id="L1436"><span class="lineNum">    1436</span>              :  */</span>
<span id="L1437"><span class="lineNum">    1437</span>              : int mbedtls_aes_crypt_ctr(mbedtls_aes_context *ctx,</span>
<span id="L1438"><span class="lineNum">    1438</span>              :                           size_t length,</span>
<span id="L1439"><span class="lineNum">    1439</span>              :                           size_t *nc_off,</span>
<span id="L1440"><span class="lineNum">    1440</span>              :                           unsigned char nonce_counter[16],</span>
<span id="L1441"><span class="lineNum">    1441</span>              :                           unsigned char stream_block[16],</span>
<span id="L1442"><span class="lineNum">    1442</span>              :                           const unsigned char *input,</span>
<span id="L1443"><span class="lineNum">    1443</span>              :                           unsigned char *output)</span>
<span id="L1444"><span class="lineNum">    1444</span>              : {</span>
<span id="L1445"><span class="lineNum">    1445</span>              :     int ret = MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED;</span>
<span id="L1446"><span class="lineNum">    1446</span>              : </span>
<span id="L1447"><span class="lineNum">    1447</span>              :     size_t offset = *nc_off;</span>
<span id="L1448"><span class="lineNum">    1448</span>              : </span>
<span id="L1449"><span class="lineNum">    1449</span>              :     if (offset &gt; 0x0F) {</span>
<span id="L1450"><span class="lineNum">    1450</span>              :         return MBEDTLS_ERR_AES_BAD_INPUT_DATA;</span>
<span id="L1451"><span class="lineNum">    1451</span>              :     }</span>
<span id="L1452"><span class="lineNum">    1452</span>              : </span>
<span id="L1453"><span class="lineNum">    1453</span>              :     for (size_t i = 0; i &lt; length;) {</span>
<span id="L1454"><span class="lineNum">    1454</span>              :         size_t n = 16;</span>
<span id="L1455"><span class="lineNum">    1455</span>              :         if (offset == 0) {</span>
<span id="L1456"><span class="lineNum">    1456</span>              :             ret = mbedtls_aes_crypt_ecb(ctx, MBEDTLS_AES_ENCRYPT, nonce_counter, stream_block);</span>
<span id="L1457"><span class="lineNum">    1457</span>              :             if (ret != 0) {</span>
<span id="L1458"><span class="lineNum">    1458</span>              :                 goto exit;</span>
<span id="L1459"><span class="lineNum">    1459</span>              :             }</span>
<span id="L1460"><span class="lineNum">    1460</span>              :             mbedtls_ctr_increment_counter(nonce_counter);</span>
<span id="L1461"><span class="lineNum">    1461</span>              :         } else {</span>
<span id="L1462"><span class="lineNum">    1462</span>              :             n -= offset;</span>
<span id="L1463"><span class="lineNum">    1463</span>              :         }</span>
<span id="L1464"><span class="lineNum">    1464</span>              : </span>
<span id="L1465"><span class="lineNum">    1465</span>              :         if (n &gt; (length - i)) {</span>
<span id="L1466"><span class="lineNum">    1466</span>              :             n = (length - i);</span>
<span id="L1467"><span class="lineNum">    1467</span>              :         }</span>
<span id="L1468"><span class="lineNum">    1468</span>              :         mbedtls_xor(&amp;output[i], &amp;input[i], &amp;stream_block[offset], n);</span>
<span id="L1469"><span class="lineNum">    1469</span>              :         // offset might be non-zero for the last block, but in that case, we don't use it again</span>
<span id="L1470"><span class="lineNum">    1470</span>              :         offset = 0;</span>
<span id="L1471"><span class="lineNum">    1471</span>              :         i += n;</span>
<span id="L1472"><span class="lineNum">    1472</span>              :     }</span>
<span id="L1473"><span class="lineNum">    1473</span>              : </span>
<span id="L1474"><span class="lineNum">    1474</span>              :     // capture offset for future resumption</span>
<span id="L1475"><span class="lineNum">    1475</span>              :     *nc_off = (*nc_off + length) % 16;</span>
<span id="L1476"><span class="lineNum">    1476</span>              : </span>
<span id="L1477"><span class="lineNum">    1477</span>              :     ret = 0;</span>
<span id="L1478"><span class="lineNum">    1478</span>              : </span>
<span id="L1479"><span class="lineNum">    1479</span>              : exit:</span>
<span id="L1480"><span class="lineNum">    1480</span>              :     return ret;</span>
<span id="L1481"><span class="lineNum">    1481</span>              : }</span>
<span id="L1482"><span class="lineNum">    1482</span>              : #endif /* MBEDTLS_CIPHER_MODE_CTR */</span>
<span id="L1483"><span class="lineNum">    1483</span>              : </span>
<span id="L1484"><span class="lineNum">    1484</span>              : #endif /* !MBEDTLS_AES_ALT */</span>
<span id="L1485"><span class="lineNum">    1485</span>              : </span>
<span id="L1486"><span class="lineNum">    1486</span>              : #if defined(MBEDTLS_SELF_TEST)</span>
<span id="L1487"><span class="lineNum">    1487</span>              : /*</span>
<span id="L1488"><span class="lineNum">    1488</span>              :  * AES test vectors from:</span>
<span id="L1489"><span class="lineNum">    1489</span>              :  *</span>
<span id="L1490"><span class="lineNum">    1490</span>              :  * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip</span>
<span id="L1491"><span class="lineNum">    1491</span>              :  */</span>
<span id="L1492"><span class="lineNum">    1492</span>              : #if !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L1493"><span class="lineNum">    1493</span>              : static const unsigned char aes_test_ecb_dec[][16] =</span>
<span id="L1494"><span class="lineNum">    1494</span>              : {</span>
<span id="L1495"><span class="lineNum">    1495</span>              :     { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,</span>
<span id="L1496"><span class="lineNum">    1496</span>              :       0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },</span>
<span id="L1497"><span class="lineNum">    1497</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1498"><span class="lineNum">    1498</span>              :     { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,</span>
<span id="L1499"><span class="lineNum">    1499</span>              :       0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },</span>
<span id="L1500"><span class="lineNum">    1500</span>              :     { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,</span>
<span id="L1501"><span class="lineNum">    1501</span>              :       0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }</span>
<span id="L1502"><span class="lineNum">    1502</span>              : #endif</span>
<span id="L1503"><span class="lineNum">    1503</span>              : };</span>
<span id="L1504"><span class="lineNum">    1504</span>              : #endif</span>
<span id="L1505"><span class="lineNum">    1505</span>              : </span>
<span id="L1506"><span class="lineNum">    1506</span>              : static const unsigned char aes_test_ecb_enc[][16] =</span>
<span id="L1507"><span class="lineNum">    1507</span>              : {</span>
<span id="L1508"><span class="lineNum">    1508</span>              :     { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,</span>
<span id="L1509"><span class="lineNum">    1509</span>              :       0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },</span>
<span id="L1510"><span class="lineNum">    1510</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1511"><span class="lineNum">    1511</span>              :     { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,</span>
<span id="L1512"><span class="lineNum">    1512</span>              :       0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },</span>
<span id="L1513"><span class="lineNum">    1513</span>              :     { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,</span>
<span id="L1514"><span class="lineNum">    1514</span>              :       0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }</span>
<span id="L1515"><span class="lineNum">    1515</span>              : #endif</span>
<span id="L1516"><span class="lineNum">    1516</span>              : };</span>
<span id="L1517"><span class="lineNum">    1517</span>              : </span>
<span id="L1518"><span class="lineNum">    1518</span>              : #if defined(MBEDTLS_CIPHER_MODE_CBC)</span>
<span id="L1519"><span class="lineNum">    1519</span>              : static const unsigned char aes_test_cbc_dec[][16] =</span>
<span id="L1520"><span class="lineNum">    1520</span>              : {</span>
<span id="L1521"><span class="lineNum">    1521</span>              :     { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,</span>
<span id="L1522"><span class="lineNum">    1522</span>              :       0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },</span>
<span id="L1523"><span class="lineNum">    1523</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1524"><span class="lineNum">    1524</span>              :     { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,</span>
<span id="L1525"><span class="lineNum">    1525</span>              :       0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },</span>
<span id="L1526"><span class="lineNum">    1526</span>              :     { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,</span>
<span id="L1527"><span class="lineNum">    1527</span>              :       0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }</span>
<span id="L1528"><span class="lineNum">    1528</span>              : #endif</span>
<span id="L1529"><span class="lineNum">    1529</span>              : };</span>
<span id="L1530"><span class="lineNum">    1530</span>              : </span>
<span id="L1531"><span class="lineNum">    1531</span>              : static const unsigned char aes_test_cbc_enc[][16] =</span>
<span id="L1532"><span class="lineNum">    1532</span>              : {</span>
<span id="L1533"><span class="lineNum">    1533</span>              :     { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,</span>
<span id="L1534"><span class="lineNum">    1534</span>              :       0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },</span>
<span id="L1535"><span class="lineNum">    1535</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1536"><span class="lineNum">    1536</span>              :     { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,</span>
<span id="L1537"><span class="lineNum">    1537</span>              :       0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },</span>
<span id="L1538"><span class="lineNum">    1538</span>              :     { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,</span>
<span id="L1539"><span class="lineNum">    1539</span>              :       0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }</span>
<span id="L1540"><span class="lineNum">    1540</span>              : #endif</span>
<span id="L1541"><span class="lineNum">    1541</span>              : };</span>
<span id="L1542"><span class="lineNum">    1542</span>              : #endif /* MBEDTLS_CIPHER_MODE_CBC */</span>
<span id="L1543"><span class="lineNum">    1543</span>              : </span>
<span id="L1544"><span class="lineNum">    1544</span>              : #if defined(MBEDTLS_CIPHER_MODE_CFB)</span>
<span id="L1545"><span class="lineNum">    1545</span>              : /*</span>
<span id="L1546"><span class="lineNum">    1546</span>              :  * AES-CFB128 test vectors from:</span>
<span id="L1547"><span class="lineNum">    1547</span>              :  *</span>
<span id="L1548"><span class="lineNum">    1548</span>              :  * http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf</span>
<span id="L1549"><span class="lineNum">    1549</span>              :  */</span>
<span id="L1550"><span class="lineNum">    1550</span>              : static const unsigned char aes_test_cfb128_key[][32] =</span>
<span id="L1551"><span class="lineNum">    1551</span>              : {</span>
<span id="L1552"><span class="lineNum">    1552</span>              :     { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,</span>
<span id="L1553"><span class="lineNum">    1553</span>              :       0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },</span>
<span id="L1554"><span class="lineNum">    1554</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1555"><span class="lineNum">    1555</span>              :     { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,</span>
<span id="L1556"><span class="lineNum">    1556</span>              :       0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,</span>
<span id="L1557"><span class="lineNum">    1557</span>              :       0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },</span>
<span id="L1558"><span class="lineNum">    1558</span>              :     { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,</span>
<span id="L1559"><span class="lineNum">    1559</span>              :       0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,</span>
<span id="L1560"><span class="lineNum">    1560</span>              :       0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,</span>
<span id="L1561"><span class="lineNum">    1561</span>              :       0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }</span>
<span id="L1562"><span class="lineNum">    1562</span>              : #endif</span>
<span id="L1563"><span class="lineNum">    1563</span>              : };</span>
<span id="L1564"><span class="lineNum">    1564</span>              : </span>
<span id="L1565"><span class="lineNum">    1565</span>              : static const unsigned char aes_test_cfb128_iv[16] =</span>
<span id="L1566"><span class="lineNum">    1566</span>              : {</span>
<span id="L1567"><span class="lineNum">    1567</span>              :     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</span>
<span id="L1568"><span class="lineNum">    1568</span>              :     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F</span>
<span id="L1569"><span class="lineNum">    1569</span>              : };</span>
<span id="L1570"><span class="lineNum">    1570</span>              : </span>
<span id="L1571"><span class="lineNum">    1571</span>              : static const unsigned char aes_test_cfb128_pt[64] =</span>
<span id="L1572"><span class="lineNum">    1572</span>              : {</span>
<span id="L1573"><span class="lineNum">    1573</span>              :     0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,</span>
<span id="L1574"><span class="lineNum">    1574</span>              :     0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,</span>
<span id="L1575"><span class="lineNum">    1575</span>              :     0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,</span>
<span id="L1576"><span class="lineNum">    1576</span>              :     0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,</span>
<span id="L1577"><span class="lineNum">    1577</span>              :     0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,</span>
<span id="L1578"><span class="lineNum">    1578</span>              :     0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,</span>
<span id="L1579"><span class="lineNum">    1579</span>              :     0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,</span>
<span id="L1580"><span class="lineNum">    1580</span>              :     0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10</span>
<span id="L1581"><span class="lineNum">    1581</span>              : };</span>
<span id="L1582"><span class="lineNum">    1582</span>              : </span>
<span id="L1583"><span class="lineNum">    1583</span>              : static const unsigned char aes_test_cfb128_ct[][64] =</span>
<span id="L1584"><span class="lineNum">    1584</span>              : {</span>
<span id="L1585"><span class="lineNum">    1585</span>              :     { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,</span>
<span id="L1586"><span class="lineNum">    1586</span>              :       0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,</span>
<span id="L1587"><span class="lineNum">    1587</span>              :       0xC8, 0xA6, 0x45, 0x37, 0xA0, 0xB3, 0xA9, 0x3F,</span>
<span id="L1588"><span class="lineNum">    1588</span>              :       0xCD, 0xE3, 0xCD, 0xAD, 0x9F, 0x1C, 0xE5, 0x8B,</span>
<span id="L1589"><span class="lineNum">    1589</span>              :       0x26, 0x75, 0x1F, 0x67, 0xA3, 0xCB, 0xB1, 0x40,</span>
<span id="L1590"><span class="lineNum">    1590</span>              :       0xB1, 0x80, 0x8C, 0xF1, 0x87, 0xA4, 0xF4, 0xDF,</span>
<span id="L1591"><span class="lineNum">    1591</span>              :       0xC0, 0x4B, 0x05, 0x35, 0x7C, 0x5D, 0x1C, 0x0E,</span>
<span id="L1592"><span class="lineNum">    1592</span>              :       0xEA, 0xC4, 0xC6, 0x6F, 0x9F, 0xF7, 0xF2, 0xE6 },</span>
<span id="L1593"><span class="lineNum">    1593</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1594"><span class="lineNum">    1594</span>              :     { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,</span>
<span id="L1595"><span class="lineNum">    1595</span>              :       0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,</span>
<span id="L1596"><span class="lineNum">    1596</span>              :       0x67, 0xCE, 0x7F, 0x7F, 0x81, 0x17, 0x36, 0x21,</span>
<span id="L1597"><span class="lineNum">    1597</span>              :       0x96, 0x1A, 0x2B, 0x70, 0x17, 0x1D, 0x3D, 0x7A,</span>
<span id="L1598"><span class="lineNum">    1598</span>              :       0x2E, 0x1E, 0x8A, 0x1D, 0xD5, 0x9B, 0x88, 0xB1,</span>
<span id="L1599"><span class="lineNum">    1599</span>              :       0xC8, 0xE6, 0x0F, 0xED, 0x1E, 0xFA, 0xC4, 0xC9,</span>
<span id="L1600"><span class="lineNum">    1600</span>              :       0xC0, 0x5F, 0x9F, 0x9C, 0xA9, 0x83, 0x4F, 0xA0,</span>
<span id="L1601"><span class="lineNum">    1601</span>              :       0x42, 0xAE, 0x8F, 0xBA, 0x58, 0x4B, 0x09, 0xFF },</span>
<span id="L1602"><span class="lineNum">    1602</span>              :     { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,</span>
<span id="L1603"><span class="lineNum">    1603</span>              :       0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,</span>
<span id="L1604"><span class="lineNum">    1604</span>              :       0x39, 0xFF, 0xED, 0x14, 0x3B, 0x28, 0xB1, 0xC8,</span>
<span id="L1605"><span class="lineNum">    1605</span>              :       0x32, 0x11, 0x3C, 0x63, 0x31, 0xE5, 0x40, 0x7B,</span>
<span id="L1606"><span class="lineNum">    1606</span>              :       0xDF, 0x10, 0x13, 0x24, 0x15, 0xE5, 0x4B, 0x92,</span>
<span id="L1607"><span class="lineNum">    1607</span>              :       0xA1, 0x3E, 0xD0, 0xA8, 0x26, 0x7A, 0xE2, 0xF9,</span>
<span id="L1608"><span class="lineNum">    1608</span>              :       0x75, 0xA3, 0x85, 0x74, 0x1A, 0xB9, 0xCE, 0xF8,</span>
<span id="L1609"><span class="lineNum">    1609</span>              :       0x20, 0x31, 0x62, 0x3D, 0x55, 0xB1, 0xE4, 0x71 }</span>
<span id="L1610"><span class="lineNum">    1610</span>              : #endif</span>
<span id="L1611"><span class="lineNum">    1611</span>              : };</span>
<span id="L1612"><span class="lineNum">    1612</span>              : #endif /* MBEDTLS_CIPHER_MODE_CFB */</span>
<span id="L1613"><span class="lineNum">    1613</span>              : </span>
<span id="L1614"><span class="lineNum">    1614</span>              : #if defined(MBEDTLS_CIPHER_MODE_OFB)</span>
<span id="L1615"><span class="lineNum">    1615</span>              : /*</span>
<span id="L1616"><span class="lineNum">    1616</span>              :  * AES-OFB test vectors from:</span>
<span id="L1617"><span class="lineNum">    1617</span>              :  *</span>
<span id="L1618"><span class="lineNum">    1618</span>              :  * https://csrc.nist.gov/publications/detail/sp/800-38a/final</span>
<span id="L1619"><span class="lineNum">    1619</span>              :  */</span>
<span id="L1620"><span class="lineNum">    1620</span>              : static const unsigned char aes_test_ofb_key[][32] =</span>
<span id="L1621"><span class="lineNum">    1621</span>              : {</span>
<span id="L1622"><span class="lineNum">    1622</span>              :     { 0x2B, 0x7E, 0x15, 0x16, 0x28, 0xAE, 0xD2, 0xA6,</span>
<span id="L1623"><span class="lineNum">    1623</span>              :       0xAB, 0xF7, 0x15, 0x88, 0x09, 0xCF, 0x4F, 0x3C },</span>
<span id="L1624"><span class="lineNum">    1624</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1625"><span class="lineNum">    1625</span>              :     { 0x8E, 0x73, 0xB0, 0xF7, 0xDA, 0x0E, 0x64, 0x52,</span>
<span id="L1626"><span class="lineNum">    1626</span>              :       0xC8, 0x10, 0xF3, 0x2B, 0x80, 0x90, 0x79, 0xE5,</span>
<span id="L1627"><span class="lineNum">    1627</span>              :       0x62, 0xF8, 0xEA, 0xD2, 0x52, 0x2C, 0x6B, 0x7B },</span>
<span id="L1628"><span class="lineNum">    1628</span>              :     { 0x60, 0x3D, 0xEB, 0x10, 0x15, 0xCA, 0x71, 0xBE,</span>
<span id="L1629"><span class="lineNum">    1629</span>              :       0x2B, 0x73, 0xAE, 0xF0, 0x85, 0x7D, 0x77, 0x81,</span>
<span id="L1630"><span class="lineNum">    1630</span>              :       0x1F, 0x35, 0x2C, 0x07, 0x3B, 0x61, 0x08, 0xD7,</span>
<span id="L1631"><span class="lineNum">    1631</span>              :       0x2D, 0x98, 0x10, 0xA3, 0x09, 0x14, 0xDF, 0xF4 }</span>
<span id="L1632"><span class="lineNum">    1632</span>              : #endif</span>
<span id="L1633"><span class="lineNum">    1633</span>              : };</span>
<span id="L1634"><span class="lineNum">    1634</span>              : </span>
<span id="L1635"><span class="lineNum">    1635</span>              : static const unsigned char aes_test_ofb_iv[16] =</span>
<span id="L1636"><span class="lineNum">    1636</span>              : {</span>
<span id="L1637"><span class="lineNum">    1637</span>              :     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</span>
<span id="L1638"><span class="lineNum">    1638</span>              :     0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F</span>
<span id="L1639"><span class="lineNum">    1639</span>              : };</span>
<span id="L1640"><span class="lineNum">    1640</span>              : </span>
<span id="L1641"><span class="lineNum">    1641</span>              : static const unsigned char aes_test_ofb_pt[64] =</span>
<span id="L1642"><span class="lineNum">    1642</span>              : {</span>
<span id="L1643"><span class="lineNum">    1643</span>              :     0x6B, 0xC1, 0xBE, 0xE2, 0x2E, 0x40, 0x9F, 0x96,</span>
<span id="L1644"><span class="lineNum">    1644</span>              :     0xE9, 0x3D, 0x7E, 0x11, 0x73, 0x93, 0x17, 0x2A,</span>
<span id="L1645"><span class="lineNum">    1645</span>              :     0xAE, 0x2D, 0x8A, 0x57, 0x1E, 0x03, 0xAC, 0x9C,</span>
<span id="L1646"><span class="lineNum">    1646</span>              :     0x9E, 0xB7, 0x6F, 0xAC, 0x45, 0xAF, 0x8E, 0x51,</span>
<span id="L1647"><span class="lineNum">    1647</span>              :     0x30, 0xC8, 0x1C, 0x46, 0xA3, 0x5C, 0xE4, 0x11,</span>
<span id="L1648"><span class="lineNum">    1648</span>              :     0xE5, 0xFB, 0xC1, 0x19, 0x1A, 0x0A, 0x52, 0xEF,</span>
<span id="L1649"><span class="lineNum">    1649</span>              :     0xF6, 0x9F, 0x24, 0x45, 0xDF, 0x4F, 0x9B, 0x17,</span>
<span id="L1650"><span class="lineNum">    1650</span>              :     0xAD, 0x2B, 0x41, 0x7B, 0xE6, 0x6C, 0x37, 0x10</span>
<span id="L1651"><span class="lineNum">    1651</span>              : };</span>
<span id="L1652"><span class="lineNum">    1652</span>              : </span>
<span id="L1653"><span class="lineNum">    1653</span>              : static const unsigned char aes_test_ofb_ct[][64] =</span>
<span id="L1654"><span class="lineNum">    1654</span>              : {</span>
<span id="L1655"><span class="lineNum">    1655</span>              :     { 0x3B, 0x3F, 0xD9, 0x2E, 0xB7, 0x2D, 0xAD, 0x20,</span>
<span id="L1656"><span class="lineNum">    1656</span>              :       0x33, 0x34, 0x49, 0xF8, 0xE8, 0x3C, 0xFB, 0x4A,</span>
<span id="L1657"><span class="lineNum">    1657</span>              :       0x77, 0x89, 0x50, 0x8d, 0x16, 0x91, 0x8f, 0x03,</span>
<span id="L1658"><span class="lineNum">    1658</span>              :       0xf5, 0x3c, 0x52, 0xda, 0xc5, 0x4e, 0xd8, 0x25,</span>
<span id="L1659"><span class="lineNum">    1659</span>              :       0x97, 0x40, 0x05, 0x1e, 0x9c, 0x5f, 0xec, 0xf6,</span>
<span id="L1660"><span class="lineNum">    1660</span>              :       0x43, 0x44, 0xf7, 0xa8, 0x22, 0x60, 0xed, 0xcc,</span>
<span id="L1661"><span class="lineNum">    1661</span>              :       0x30, 0x4c, 0x65, 0x28, 0xf6, 0x59, 0xc7, 0x78,</span>
<span id="L1662"><span class="lineNum">    1662</span>              :       0x66, 0xa5, 0x10, 0xd9, 0xc1, 0xd6, 0xae, 0x5e },</span>
<span id="L1663"><span class="lineNum">    1663</span>              : #if !defined(MBEDTLS_AES_ONLY_128_BIT_KEY_LENGTH)</span>
<span id="L1664"><span class="lineNum">    1664</span>              :     { 0xCD, 0xC8, 0x0D, 0x6F, 0xDD, 0xF1, 0x8C, 0xAB,</span>
<span id="L1665"><span class="lineNum">    1665</span>              :       0x34, 0xC2, 0x59, 0x09, 0xC9, 0x9A, 0x41, 0x74,</span>
<span id="L1666"><span class="lineNum">    1666</span>              :       0xfc, 0xc2, 0x8b, 0x8d, 0x4c, 0x63, 0x83, 0x7c,</span>
<span id="L1667"><span class="lineNum">    1667</span>              :       0x09, 0xe8, 0x17, 0x00, 0xc1, 0x10, 0x04, 0x01,</span>
<span id="L1668"><span class="lineNum">    1668</span>              :       0x8d, 0x9a, 0x9a, 0xea, 0xc0, 0xf6, 0x59, 0x6f,</span>
<span id="L1669"><span class="lineNum">    1669</span>              :       0x55, 0x9c, 0x6d, 0x4d, 0xaf, 0x59, 0xa5, 0xf2,</span>
<span id="L1670"><span class="lineNum">    1670</span>              :       0x6d, 0x9f, 0x20, 0x08, 0x57, 0xca, 0x6c, 0x3e,</span>
<span id="L1671"><span class="lineNum">    1671</span>              :       0x9c, 0xac, 0x52, 0x4b, 0xd9, 0xac, 0xc9, 0x2a },</span>
<span id="L1672"><span class="lineNum">    1672</span>              :     { 0xDC, 0x7E, 0x84, 0xBF, 0xDA, 0x79, 0x16, 0x4B,</span>
<span id="L1673"><span class="lineNum">    1673</span>              :       0x7E, 0xCD, 0x84, 0x86, 0x98, 0x5D, 0x38, 0x60,</span>
<span id="L1674"><span class="lineNum">    1674</span>              :       0x4f, 0xeb, 0xdc, 0x67, 0x40, 0xd2, 0x0b, 0x3a,</span>
<span id="L1675"><span class="lineNum">    1675</span>              :       0xc8, 0x8f, 0x6a, 0xd8, 0x2a, 0x4f, 0xb0, 0x8d,</span>
<span id="L1676"><span class="lineNum">    1676</span>              :       0x71, 0xab, 0x47, 0xa0, 0x86, 0xe8, 0x6e, 0xed,</span>
<span id="L1677"><span class="lineNum">    1677</span>              :       0xf3, 0x9d, 0x1c, 0x5b, 0xba, 0x97, 0xc4, 0x08,</span>
<span id="L1678"><span class="lineNum">    1678</span>              :       0x01, 0x26, 0x14, 0x1d, 0x67, 0xf3, 0x7b, 0xe8,</span>
<span id="L1679"><span class="lineNum">    1679</span>              :       0x53, 0x8f, 0x5a, 0x8b, 0xe7, 0x40, 0xe4, 0x84 }</span>
<span id="L1680"><span class="lineNum">    1680</span>              : #endif</span>
<span id="L1681"><span class="lineNum">    1681</span>              : };</span>
<span id="L1682"><span class="lineNum">    1682</span>              : #endif /* MBEDTLS_CIPHER_MODE_OFB */</span>
<span id="L1683"><span class="lineNum">    1683</span>              : </span>
<span id="L1684"><span class="lineNum">    1684</span>              : #if defined(MBEDTLS_CIPHER_MODE_CTR)</span>
<span id="L1685"><span class="lineNum">    1685</span>              : /*</span>
<span id="L1686"><span class="lineNum">    1686</span>              :  * AES-CTR test vectors from:</span>
<span id="L1687"><span class="lineNum">    1687</span>              :  *</span>
<span id="L1688"><span class="lineNum">    1688</span>              :  * http://www.faqs.org/rfcs/rfc3686.html</span>
<span id="L1689"><span class="lineNum">    1689</span>              :  */</span>
<span id="L1690"><span class="lineNum">    1690</span>              : </span>
<span id="L1691"><span class="lineNum">    1691</span>              : static const unsigned char aes_test_ctr_key[][16] =</span>
<span id="L1692"><span class="lineNum">    1692</span>              : {</span>
<span id="L1693"><span class="lineNum">    1693</span>              :     { 0xAE, 0x68, 0x52, 0xF8, 0x12, 0x10, 0x67, 0xCC,</span>
<span id="L1694"><span class="lineNum">    1694</span>              :       0x4B, 0xF7, 0xA5, 0x76, 0x55, 0x77, 0xF3, 0x9E },</span>
<span id="L1695"><span class="lineNum">    1695</span>              :     { 0x7E, 0x24, 0x06, 0x78, 0x17, 0xFA, 0xE0, 0xD7,</span>
<span id="L1696"><span class="lineNum">    1696</span>              :       0x43, 0xD6, 0xCE, 0x1F, 0x32, 0x53, 0x91, 0x63 },</span>
<span id="L1697"><span class="lineNum">    1697</span>              :     { 0x76, 0x91, 0xBE, 0x03, 0x5E, 0x50, 0x20, 0xA8,</span>
<span id="L1698"><span class="lineNum">    1698</span>              :       0xAC, 0x6E, 0x61, 0x85, 0x29, 0xF9, 0xA0, 0xDC }</span>
<span id="L1699"><span class="lineNum">    1699</span>              : };</span>
<span id="L1700"><span class="lineNum">    1700</span>              : </span>
<span id="L1701"><span class="lineNum">    1701</span>              : static const unsigned char aes_test_ctr_nonce_counter[][16] =</span>
<span id="L1702"><span class="lineNum">    1702</span>              : {</span>
<span id="L1703"><span class="lineNum">    1703</span>              :     { 0x00, 0x00, 0x00, 0x30, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1704"><span class="lineNum">    1704</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },</span>
<span id="L1705"><span class="lineNum">    1705</span>              :     { 0x00, 0x6C, 0xB6, 0xDB, 0xC0, 0x54, 0x3B, 0x59,</span>
<span id="L1706"><span class="lineNum">    1706</span>              :       0xDA, 0x48, 0xD9, 0x0B, 0x00, 0x00, 0x00, 0x01 },</span>
<span id="L1707"><span class="lineNum">    1707</span>              :     { 0x00, 0xE0, 0x01, 0x7B, 0x27, 0x77, 0x7F, 0x3F,</span>
<span id="L1708"><span class="lineNum">    1708</span>              :       0x4A, 0x17, 0x86, 0xF0, 0x00, 0x00, 0x00, 0x01 }</span>
<span id="L1709"><span class="lineNum">    1709</span>              : };</span>
<span id="L1710"><span class="lineNum">    1710</span>              : </span>
<span id="L1711"><span class="lineNum">    1711</span>              : static const unsigned char aes_test_ctr_pt[][48] =</span>
<span id="L1712"><span class="lineNum">    1712</span>              : {</span>
<span id="L1713"><span class="lineNum">    1713</span>              :     { 0x53, 0x69, 0x6E, 0x67, 0x6C, 0x65, 0x20, 0x62,</span>
<span id="L1714"><span class="lineNum">    1714</span>              :       0x6C, 0x6F, 0x63, 0x6B, 0x20, 0x6D, 0x73, 0x67 },</span>
<span id="L1715"><span class="lineNum">    1715</span>              :     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</span>
<span id="L1716"><span class="lineNum">    1716</span>              :       0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,</span>
<span id="L1717"><span class="lineNum">    1717</span>              :       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,</span>
<span id="L1718"><span class="lineNum">    1718</span>              :       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F },</span>
<span id="L1719"><span class="lineNum">    1719</span>              : </span>
<span id="L1720"><span class="lineNum">    1720</span>              :     { 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,</span>
<span id="L1721"><span class="lineNum">    1721</span>              :       0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,</span>
<span id="L1722"><span class="lineNum">    1722</span>              :       0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,</span>
<span id="L1723"><span class="lineNum">    1723</span>              :       0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,</span>
<span id="L1724"><span class="lineNum">    1724</span>              :       0x20, 0x21, 0x22, 0x23 }</span>
<span id="L1725"><span class="lineNum">    1725</span>              : };</span>
<span id="L1726"><span class="lineNum">    1726</span>              : </span>
<span id="L1727"><span class="lineNum">    1727</span>              : static const unsigned char aes_test_ctr_ct[][48] =</span>
<span id="L1728"><span class="lineNum">    1728</span>              : {</span>
<span id="L1729"><span class="lineNum">    1729</span>              :     { 0xE4, 0x09, 0x5D, 0x4F, 0xB7, 0xA7, 0xB3, 0x79,</span>
<span id="L1730"><span class="lineNum">    1730</span>              :       0x2D, 0x61, 0x75, 0xA3, 0x26, 0x13, 0x11, 0xB8 },</span>
<span id="L1731"><span class="lineNum">    1731</span>              :     { 0x51, 0x04, 0xA1, 0x06, 0x16, 0x8A, 0x72, 0xD9,</span>
<span id="L1732"><span class="lineNum">    1732</span>              :       0x79, 0x0D, 0x41, 0xEE, 0x8E, 0xDA, 0xD3, 0x88,</span>
<span id="L1733"><span class="lineNum">    1733</span>              :       0xEB, 0x2E, 0x1E, 0xFC, 0x46, 0xDA, 0x57, 0xC8,</span>
<span id="L1734"><span class="lineNum">    1734</span>              :       0xFC, 0xE6, 0x30, 0xDF, 0x91, 0x41, 0xBE, 0x28 },</span>
<span id="L1735"><span class="lineNum">    1735</span>              :     { 0xC1, 0xCF, 0x48, 0xA8, 0x9F, 0x2F, 0xFD, 0xD9,</span>
<span id="L1736"><span class="lineNum">    1736</span>              :       0xCF, 0x46, 0x52, 0xE9, 0xEF, 0xDB, 0x72, 0xD7,</span>
<span id="L1737"><span class="lineNum">    1737</span>              :       0x45, 0x40, 0xA4, 0x2B, 0xDE, 0x6D, 0x78, 0x36,</span>
<span id="L1738"><span class="lineNum">    1738</span>              :       0xD5, 0x9A, 0x5C, 0xEA, 0xAE, 0xF3, 0x10, 0x53,</span>
<span id="L1739"><span class="lineNum">    1739</span>              :       0x25, 0xB2, 0x07, 0x2F }</span>
<span id="L1740"><span class="lineNum">    1740</span>              : };</span>
<span id="L1741"><span class="lineNum">    1741</span>              : </span>
<span id="L1742"><span class="lineNum">    1742</span>              : static const int aes_test_ctr_len[3] =</span>
<span id="L1743"><span class="lineNum">    1743</span>              : { 16, 32, 36 };</span>
<span id="L1744"><span class="lineNum">    1744</span>              : #endif /* MBEDTLS_CIPHER_MODE_CTR */</span>
<span id="L1745"><span class="lineNum">    1745</span>              : </span>
<span id="L1746"><span class="lineNum">    1746</span>              : #if defined(MBEDTLS_CIPHER_MODE_XTS)</span>
<span id="L1747"><span class="lineNum">    1747</span>              : /*</span>
<span id="L1748"><span class="lineNum">    1748</span>              :  * AES-XTS test vectors from:</span>
<span id="L1749"><span class="lineNum">    1749</span>              :  *</span>
<span id="L1750"><span class="lineNum">    1750</span>              :  * IEEE P1619/D16 Annex B</span>
<span id="L1751"><span class="lineNum">    1751</span>              :  * https://web.archive.org/web/20150629024421/http://grouper.ieee.org/groups/1619/email/pdf00086.pdf</span>
<span id="L1752"><span class="lineNum">    1752</span>              :  * (Archived from original at http://grouper.ieee.org/groups/1619/email/pdf00086.pdf)</span>
<span id="L1753"><span class="lineNum">    1753</span>              :  */</span>
<span id="L1754"><span class="lineNum">    1754</span>              : static const unsigned char aes_test_xts_key[][32] =</span>
<span id="L1755"><span class="lineNum">    1755</span>              : {</span>
<span id="L1756"><span class="lineNum">    1756</span>              :     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1757"><span class="lineNum">    1757</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1758"><span class="lineNum">    1758</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1759"><span class="lineNum">    1759</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },</span>
<span id="L1760"><span class="lineNum">    1760</span>              :     { 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,</span>
<span id="L1761"><span class="lineNum">    1761</span>              :       0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11,</span>
<span id="L1762"><span class="lineNum">    1762</span>              :       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,</span>
<span id="L1763"><span class="lineNum">    1763</span>              :       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22 },</span>
<span id="L1764"><span class="lineNum">    1764</span>              :     { 0xff, 0xfe, 0xfd, 0xfc, 0xfb, 0xfa, 0xf9, 0xf8,</span>
<span id="L1765"><span class="lineNum">    1765</span>              :       0xf7, 0xf6, 0xf5, 0xf4, 0xf3, 0xf2, 0xf1, 0xf0,</span>
<span id="L1766"><span class="lineNum">    1766</span>              :       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,</span>
<span id="L1767"><span class="lineNum">    1767</span>              :       0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22 },</span>
<span id="L1768"><span class="lineNum">    1768</span>              : };</span>
<span id="L1769"><span class="lineNum">    1769</span>              : </span>
<span id="L1770"><span class="lineNum">    1770</span>              : static const unsigned char aes_test_xts_pt32[][32] =</span>
<span id="L1771"><span class="lineNum">    1771</span>              : {</span>
<span id="L1772"><span class="lineNum">    1772</span>              :     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1773"><span class="lineNum">    1773</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1774"><span class="lineNum">    1774</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1775"><span class="lineNum">    1775</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },</span>
<span id="L1776"><span class="lineNum">    1776</span>              :     { 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,</span>
<span id="L1777"><span class="lineNum">    1777</span>              :       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,</span>
<span id="L1778"><span class="lineNum">    1778</span>              :       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,</span>
<span id="L1779"><span class="lineNum">    1779</span>              :       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44 },</span>
<span id="L1780"><span class="lineNum">    1780</span>              :     { 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,</span>
<span id="L1781"><span class="lineNum">    1781</span>              :       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,</span>
<span id="L1782"><span class="lineNum">    1782</span>              :       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44,</span>
<span id="L1783"><span class="lineNum">    1783</span>              :       0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44, 0x44 },</span>
<span id="L1784"><span class="lineNum">    1784</span>              : };</span>
<span id="L1785"><span class="lineNum">    1785</span>              : </span>
<span id="L1786"><span class="lineNum">    1786</span>              : static const unsigned char aes_test_xts_ct32[][32] =</span>
<span id="L1787"><span class="lineNum">    1787</span>              : {</span>
<span id="L1788"><span class="lineNum">    1788</span>              :     { 0x91, 0x7c, 0xf6, 0x9e, 0xbd, 0x68, 0xb2, 0xec,</span>
<span id="L1789"><span class="lineNum">    1789</span>              :       0x9b, 0x9f, 0xe9, 0xa3, 0xea, 0xdd, 0xa6, 0x92,</span>
<span id="L1790"><span class="lineNum">    1790</span>              :       0xcd, 0x43, 0xd2, 0xf5, 0x95, 0x98, 0xed, 0x85,</span>
<span id="L1791"><span class="lineNum">    1791</span>              :       0x8c, 0x02, 0xc2, 0x65, 0x2f, 0xbf, 0x92, 0x2e },</span>
<span id="L1792"><span class="lineNum">    1792</span>              :     { 0xc4, 0x54, 0x18, 0x5e, 0x6a, 0x16, 0x93, 0x6e,</span>
<span id="L1793"><span class="lineNum">    1793</span>              :       0x39, 0x33, 0x40, 0x38, 0xac, 0xef, 0x83, 0x8b,</span>
<span id="L1794"><span class="lineNum">    1794</span>              :       0xfb, 0x18, 0x6f, 0xff, 0x74, 0x80, 0xad, 0xc4,</span>
<span id="L1795"><span class="lineNum">    1795</span>              :       0x28, 0x93, 0x82, 0xec, 0xd6, 0xd3, 0x94, 0xf0 },</span>
<span id="L1796"><span class="lineNum">    1796</span>              :     { 0xaf, 0x85, 0x33, 0x6b, 0x59, 0x7a, 0xfc, 0x1a,</span>
<span id="L1797"><span class="lineNum">    1797</span>              :       0x90, 0x0b, 0x2e, 0xb2, 0x1e, 0xc9, 0x49, 0xd2,</span>
<span id="L1798"><span class="lineNum">    1798</span>              :       0x92, 0xdf, 0x4c, 0x04, 0x7e, 0x0b, 0x21, 0x53,</span>
<span id="L1799"><span class="lineNum">    1799</span>              :       0x21, 0x86, 0xa5, 0x97, 0x1a, 0x22, 0x7a, 0x89 },</span>
<span id="L1800"><span class="lineNum">    1800</span>              : };</span>
<span id="L1801"><span class="lineNum">    1801</span>              : </span>
<span id="L1802"><span class="lineNum">    1802</span>              : static const unsigned char aes_test_xts_data_unit[][16] =</span>
<span id="L1803"><span class="lineNum">    1803</span>              : {</span>
<span id="L1804"><span class="lineNum">    1804</span>              :     { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,</span>
<span id="L1805"><span class="lineNum">    1805</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },</span>
<span id="L1806"><span class="lineNum">    1806</span>              :     { 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00,</span>
<span id="L1807"><span class="lineNum">    1807</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },</span>
<span id="L1808"><span class="lineNum">    1808</span>              :     { 0x33, 0x33, 0x33, 0x33, 0x33, 0x00, 0x00, 0x00,</span>
<span id="L1809"><span class="lineNum">    1809</span>              :       0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },</span>
<span id="L1810"><span class="lineNum">    1810</span>              : };</span>
<span id="L1811"><span class="lineNum">    1811</span>              : </span>
<span id="L1812"><span class="lineNum">    1812</span>              : #endif /* MBEDTLS_CIPHER_MODE_XTS */</span>
<span id="L1813"><span class="lineNum">    1813</span>              : </span>
<span id="L1814"><span class="lineNum">    1814</span>              : /*</span>
<span id="L1815"><span class="lineNum">    1815</span>              :  * Checkup routine</span>
<span id="L1816"><span class="lineNum">    1816</span>              :  */</span>
<span id="L1817"><span class="lineNum">    1817</span> <span class="tlaUNC">           0 : int mbedtls_aes_self_test(int verbose)</span></span>
<span id="L1818"><span class="lineNum">    1818</span>              : {</span>
<span id="L1819"><span class="lineNum">    1819</span> <span class="tlaUNC">           0 :     int ret = 0, i, j, u, mode;</span></span>
<span id="L1820"><span class="lineNum">    1820</span>              :     unsigned int keybits;</span>
<span id="L1821"><span class="lineNum">    1821</span>              :     unsigned char key[32];</span>
<span id="L1822"><span class="lineNum">    1822</span>              :     unsigned char buf[64];</span>
<span id="L1823"><span class="lineNum">    1823</span>              :     const unsigned char *aes_tests;</span>
<span id="L1824"><span class="lineNum">    1824</span>              : #if defined(MBEDTLS_CIPHER_MODE_CBC) || defined(MBEDTLS_CIPHER_MODE_CFB) || \</span>
<span id="L1825"><span class="lineNum">    1825</span>              :     defined(MBEDTLS_CIPHER_MODE_OFB)</span>
<span id="L1826"><span class="lineNum">    1826</span>              :     unsigned char iv[16];</span>
<span id="L1827"><span class="lineNum">    1827</span>              : #endif</span>
<span id="L1828"><span class="lineNum">    1828</span>              : #if defined(MBEDTLS_CIPHER_MODE_CBC)</span>
<span id="L1829"><span class="lineNum">    1829</span>              :     unsigned char prv[16];</span>
<span id="L1830"><span class="lineNum">    1830</span>              : #endif</span>
<span id="L1831"><span class="lineNum">    1831</span>              : #if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_CFB) || \</span>
<span id="L1832"><span class="lineNum">    1832</span>              :     defined(MBEDTLS_CIPHER_MODE_OFB)</span>
<span id="L1833"><span class="lineNum">    1833</span>              :     size_t offset;</span>
<span id="L1834"><span class="lineNum">    1834</span>              : #endif</span>
<span id="L1835"><span class="lineNum">    1835</span>              : #if defined(MBEDTLS_CIPHER_MODE_CTR) || defined(MBEDTLS_CIPHER_MODE_XTS)</span>
<span id="L1836"><span class="lineNum">    1836</span>              :     int len;</span>
<span id="L1837"><span class="lineNum">    1837</span>              : #endif</span>
<span id="L1838"><span class="lineNum">    1838</span>              : #if defined(MBEDTLS_CIPHER_MODE_CTR)</span>
<span id="L1839"><span class="lineNum">    1839</span>              :     unsigned char nonce_counter[16];</span>
<span id="L1840"><span class="lineNum">    1840</span>              :     unsigned char stream_block[16];</span>
<span id="L1841"><span class="lineNum">    1841</span>              : #endif</span>
<span id="L1842"><span class="lineNum">    1842</span>              :     mbedtls_aes_context ctx;</span>
<span id="L1843"><span class="lineNum">    1843</span>              : </span>
<span id="L1844"><span class="lineNum">    1844</span> <span class="tlaUNC">           0 :     memset(key, 0, 32);</span></span>
<span id="L1845"><span class="lineNum">    1845</span> <span class="tlaUNC">           0 :     mbedtls_aes_init(&amp;ctx);</span></span>
<span id="L1846"><span class="lineNum">    1846</span>              : </span>
<span id="L1847"><span class="lineNum">    1847</span> <span class="tlaUNC">           0 :     if (verbose != 0) {</span></span>
<span id="L1848"><span class="lineNum">    1848</span>              : #if defined(MBEDTLS_AES_ALT)</span>
<span id="L1849"><span class="lineNum">    1849</span>              :         mbedtls_printf(&quot;  AES note: alternative implementation.\n&quot;);</span>
<span id="L1850"><span class="lineNum">    1850</span>              : #else /* MBEDTLS_AES_ALT */</span>
<span id="L1851"><span class="lineNum">    1851</span>              : #if defined(MBEDTLS_AESNI_HAVE_CODE)</span>
<span id="L1852"><span class="lineNum">    1852</span>              : #if MBEDTLS_AESNI_HAVE_CODE == 1</span>
<span id="L1853"><span class="lineNum">    1853</span> <span class="tlaUNC">           0 :         mbedtls_printf(&quot;  AES note: AESNI code present (assembly implementation).\n&quot;);</span></span>
<span id="L1854"><span class="lineNum">    1854</span>              : #elif MBEDTLS_AESNI_HAVE_CODE == 2</span>
<span id="L1855"><span class="lineNum">    1855</span>              :         mbedtls_printf(&quot;  AES note: AESNI code present (intrinsics implementation).\n&quot;);</span>
<span id="L1856"><span class="lineNum">    1856</span>              : #else</span>
<span id="L1857"><span class="lineNum">    1857</span>              : #error &quot;Unrecognised value for MBEDTLS_AESNI_HAVE_CODE&quot;</span>
<span id="L1858"><span class="lineNum">    1858</span>              : #endif</span>
<span id="L1859"><span class="lineNum">    1859</span> <span class="tlaUNC">           0 :         if (mbedtls_aesni_has_support(MBEDTLS_AESNI_AES)) {</span></span>
<span id="L1860"><span class="lineNum">    1860</span> <span class="tlaUNC">           0 :             mbedtls_printf(&quot;  AES note: using AESNI.\n&quot;);</span></span>
<span id="L1861"><span class="lineNum">    1861</span>              :         } else</span>
<span id="L1862"><span class="lineNum">    1862</span>              : #endif</span>
<span id="L1863"><span class="lineNum">    1863</span>              : #if defined(MBEDTLS_VIA_PADLOCK_HAVE_CODE)</span>
<span id="L1864"><span class="lineNum">    1864</span>              :         if (mbedtls_padlock_has_support(MBEDTLS_PADLOCK_ACE)) {</span>
<span id="L1865"><span class="lineNum">    1865</span>              :             mbedtls_printf(&quot;  AES note: using VIA Padlock.\n&quot;);</span>
<span id="L1866"><span class="lineNum">    1866</span>              :         } else</span>
<span id="L1867"><span class="lineNum">    1867</span>              : #endif</span>
<span id="L1868"><span class="lineNum">    1868</span>              : #if defined(MBEDTLS_AESCE_HAVE_CODE)</span>
<span id="L1869"><span class="lineNum">    1869</span>              :         if (MBEDTLS_AESCE_HAS_SUPPORT()) {</span>
<span id="L1870"><span class="lineNum">    1870</span>              :             mbedtls_printf(&quot;  AES note: using AESCE.\n&quot;);</span>
<span id="L1871"><span class="lineNum">    1871</span>              :         } else</span>
<span id="L1872"><span class="lineNum">    1872</span>              : #endif</span>
<span id="L1873"><span class="lineNum">    1873</span>              :         {</span>
<span id="L1874"><span class="lineNum">    1874</span>              : #if !defined(MBEDTLS_AES_USE_HARDWARE_ONLY)</span>
<span id="L1875"><span class="lineNum">    1875</span> <span class="tlaUNC">           0 :             mbedtls_printf(&quot;  AES note: built-in implementation.\n&quot;);</span></span>
<span id="L1876"><span class="lineNum">    1876</span>              : #endif</span>
<span id="L1877"><span class="lineNum">    1877</span>              :         }</span>
<span id="L1878"><span class="lineNum">    1878</span>              : #endif /* MBEDTLS_AES_ALT */</span>
<span id="L1879"><span class="lineNum">    1879</span>              :     }</span>
<span id="L1880"><span class="lineNum">    1880</span>              : </span>
<span id="L1881"><span class="lineNum">    1881</span>              :     /*</span>
<span id="L1882"><span class="lineNum">    1882</span>              :      * ECB mode</span>
<span id="L1883"><span class="lineNum">    1883</span>              :      */</span>
<span id="L1884"><span class="lineNum">    1884</span>              :     {</span>
<span id="L1885"><span class="lineNum">    1885</span>              :         static const int num_tests =</span>
<span id="L1886"><span class="lineNum">    1886</span>              :             sizeof(aes_test_ecb_enc) / sizeof(*aes_test_ecb_enc);</span>
<span id="L1887"><span class="lineNum">    1887</span>              : </span>
<span id="L1888"><span class="lineNum">    1888</span> <span class="tlaUNC">           0 :         for (i = 0; i &lt; num_tests &lt;&lt; 1; i++) {</span></span>
<span id="L1889"><span class="lineNum">    1889</span> <span class="tlaUNC">           0 :             u = i &gt;&gt; 1;</span></span>
<span id="L1890"><span class="lineNum">    1890</span> <span class="tlaUNC">           0 :             keybits = 128 + u * 64;</span></span>
<span id="L1891"><span class="lineNum">    1891</span> <span class="tlaUNC">           0 :             mode = i &amp; 1;</span></span>
<span id="L1892"><span class="lineNum">    1892</span>              : </span>
<span id="L1893"><span class="lineNum">    1893</span> <span class="tlaUNC">           0 :             if (verbose != 0) {</span></span>
<span id="L1894"><span class="lineNum">    1894</span> <span class="tlaUNC">           0 :                 mbedtls_printf(&quot;  AES-ECB-%3u (%s): &quot;, keybits,</span></span>
<span id="L1895"><span class="lineNum">    1895</span>              :                                (mode == MBEDTLS_AES_DECRYPT) ? &quot;dec&quot; : &quot;enc&quot;);</span>
<span id="L1896"><span class="lineNum">    1896</span>              :             }</span>
<span id="L1897"><span class="lineNum">    1897</span>              : #if defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L1898"><span class="lineNum">    1898</span>              :             if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L1899"><span class="lineNum">    1899</span>              :                 if (verbose != 0) {</span>
<span id="L1900"><span class="lineNum">    1900</span>              :                     mbedtls_printf(&quot;skipped\n&quot;);</span>
<span id="L1901"><span class="lineNum">    1901</span>              :                 }</span>
<span id="L1902"><span class="lineNum">    1902</span>              :                 continue;</span>
<span id="L1903"><span class="lineNum">    1903</span>              :             }</span>
<span id="L1904"><span class="lineNum">    1904</span>              : #endif</span>
<span id="L1905"><span class="lineNum">    1905</span>              : </span>
<span id="L1906"><span class="lineNum">    1906</span> <span class="tlaUNC">           0 :             memset(buf, 0, 16);</span></span>
<span id="L1907"><span class="lineNum">    1907</span>              : </span>
<span id="L1908"><span class="lineNum">    1908</span>              : #if !defined(MBEDTLS_BLOCK_CIPHER_NO_DECRYPT)</span>
<span id="L1909"><span class="lineNum">    1909</span> <span class="tlaUNC">           0 :             if (mode == MBEDTLS_AES_DECRYPT) {</span></span>
<span id="L1910"><span class="lineNum">    1910</span> <span class="tlaUNC">           0 :                 ret = mbedtls_aes_setkey_dec(&amp;ctx, key, keybits);</span></span>
<span id="L1911"><span class="lineNum">    1911</span> <span class="tlaUNC">           0 :                 aes_tests = aes_test_ecb_dec[u];</span></span>
<span id="L1912"><span class="lineNum">    1912</span>              :             } else</span>
<span id="L1913"><span class="lineNum">    1913</span>              : #endif</span>
<span id="L1914"><span class="lineNum">    1914</span>              :             {</span>
<span id="L1915"><span class="lineNum">    1915</span> <span class="tlaUNC">           0 :                 ret = mbedtls_aes_setkey_enc(&amp;ctx, key, keybits);</span></span>
<span id="L1916"><span class="lineNum">    1916</span> <span class="tlaUNC">           0 :                 aes_tests = aes_test_ecb_enc[u];</span></span>
<span id="L1917"><span class="lineNum">    1917</span>              :             }</span>
<span id="L1918"><span class="lineNum">    1918</span>              : </span>
<span id="L1919"><span class="lineNum">    1919</span>              :             /*</span>
<span id="L1920"><span class="lineNum">    1920</span>              :              * AES-192 is an optional feature that may be unavailable when</span>
<span id="L1921"><span class="lineNum">    1921</span>              :              * there is an alternative underlying implementation i.e. when</span>
<span id="L1922"><span class="lineNum">    1922</span>              :              * MBEDTLS_AES_ALT is defined.</span>
<span id="L1923"><span class="lineNum">    1923</span>              :              */</span>
<span id="L1924"><span class="lineNum">    1924</span> <span class="tlaUNC">           0 :             if (ret == MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED &amp;&amp; keybits == 192) {</span></span>
<span id="L1925"><span class="lineNum">    1925</span> <span class="tlaUNC">           0 :                 mbedtls_printf(&quot;skipped\n&quot;);</span></span>
<span id="L1926"><span class="lineNum">    1926</span> <span class="tlaUNC">           0 :                 continue;</span></span>
<span id="L1927"><span class="lineNum">    1927</span> <span class="tlaUNC">           0 :             } else if (ret != 0) {</span></span>
<span id="L1928"><span class="lineNum">    1928</span> <span class="tlaUNC">           0 :                 goto exit;</span></span>
<span id="L1929"><span class="lineNum">    1929</span>              :             }</span>
<span id="L1930"><span class="lineNum">    1930</span>              : </span>
<span id="L1931"><span class="lineNum">    1931</span> <span class="tlaUNC">           0 :             for (j = 0; j &lt; 10000; j++) {</span></span>
<span id="L1932"><span class="lineNum">    1932</span> <span class="tlaUNC">           0 :                 ret = mbedtls_aes_crypt_ecb(&amp;ctx, mode, buf, buf);</span></span>
<span id="L1933"><span class="lineNum">    1933</span> <span class="tlaUNC">           0 :                 if (ret != 0) {</span></span>
<span id="L1934"><span class="lineNum">    1934</span> <span class="tlaUNC">           0 :                     goto exit;</span></span>
<span id="L1935"><span class="lineNum">    1935</span>              :                 }</span>
<span id="L1936"><span class="lineNum">    1936</span>              :             }</span>
<span id="L1937"><span class="lineNum">    1937</span>              : </span>
<span id="L1938"><span class="lineNum">    1938</span> <span class="tlaUNC">           0 :             if (memcmp(buf, aes_tests, 16) != 0) {</span></span>
<span id="L1939"><span class="lineNum">    1939</span> <span class="tlaUNC">           0 :                 ret = 1;</span></span>
<span id="L1940"><span class="lineNum">    1940</span> <span class="tlaUNC">           0 :                 goto exit;</span></span>
<span id="L1941"><span class="lineNum">    1941</span>              :             }</span>
<span id="L1942"><span class="lineNum">    1942</span>              : </span>
<span id="L1943"><span class="lineNum">    1943</span> <span class="tlaUNC">           0 :             if (verbose != 0) {</span></span>
<span id="L1944"><span class="lineNum">    1944</span> <span class="tlaUNC">           0 :                 mbedtls_printf(&quot;passed\n&quot;);</span></span>
<span id="L1945"><span class="lineNum">    1945</span>              :             }</span>
<span id="L1946"><span class="lineNum">    1946</span>              :         }</span>
<span id="L1947"><span class="lineNum">    1947</span>              : </span>
<span id="L1948"><span class="lineNum">    1948</span> <span class="tlaUNC">           0 :         if (verbose != 0) {</span></span>
<span id="L1949"><span class="lineNum">    1949</span> <span class="tlaUNC">           0 :             mbedtls_printf(&quot;\n&quot;);</span></span>
<span id="L1950"><span class="lineNum">    1950</span>              :         }</span>
<span id="L1951"><span class="lineNum">    1951</span>              :     }</span>
<span id="L1952"><span class="lineNum">    1952</span>              : </span>
<span id="L1953"><span class="lineNum">    1953</span>              : #if defined(MBEDTLS_CIPHER_MODE_CBC)</span>
<span id="L1954"><span class="lineNum">    1954</span>              :     /*</span>
<span id="L1955"><span class="lineNum">    1955</span>              :      * CBC mode</span>
<span id="L1956"><span class="lineNum">    1956</span>              :      */</span>
<span id="L1957"><span class="lineNum">    1957</span>              :     {</span>
<span id="L1958"><span class="lineNum">    1958</span>              :         static const int num_tests =</span>
<span id="L1959"><span class="lineNum">    1959</span>              :             sizeof(aes_test_cbc_dec) / sizeof(*aes_test_cbc_dec);</span>
<span id="L1960"><span class="lineNum">    1960</span>              : </span>
<span id="L1961"><span class="lineNum">    1961</span>              :         for (i = 0; i &lt; num_tests &lt;&lt; 1; i++) {</span>
<span id="L1962"><span class="lineNum">    1962</span>              :             u = i &gt;&gt; 1;</span>
<span id="L1963"><span class="lineNum">    1963</span>              :             keybits = 128 + u * 64;</span>
<span id="L1964"><span class="lineNum">    1964</span>              :             mode = i &amp; 1;</span>
<span id="L1965"><span class="lineNum">    1965</span>              : </span>
<span id="L1966"><span class="lineNum">    1966</span>              :             if (verbose != 0) {</span>
<span id="L1967"><span class="lineNum">    1967</span>              :                 mbedtls_printf(&quot;  AES-CBC-%3u (%s): &quot;, keybits,</span>
<span id="L1968"><span class="lineNum">    1968</span>              :                                (mode == MBEDTLS_AES_DECRYPT) ? &quot;dec&quot; : &quot;enc&quot;);</span>
<span id="L1969"><span class="lineNum">    1969</span>              :             }</span>
<span id="L1970"><span class="lineNum">    1970</span>              : </span>
<span id="L1971"><span class="lineNum">    1971</span>              :             memset(iv, 0, 16);</span>
<span id="L1972"><span class="lineNum">    1972</span>              :             memset(prv, 0, 16);</span>
<span id="L1973"><span class="lineNum">    1973</span>              :             memset(buf, 0, 16);</span>
<span id="L1974"><span class="lineNum">    1974</span>              : </span>
<span id="L1975"><span class="lineNum">    1975</span>              :             if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L1976"><span class="lineNum">    1976</span>              :                 ret = mbedtls_aes_setkey_dec(&amp;ctx, key, keybits);</span>
<span id="L1977"><span class="lineNum">    1977</span>              :                 aes_tests = aes_test_cbc_dec[u];</span>
<span id="L1978"><span class="lineNum">    1978</span>              :             } else {</span>
<span id="L1979"><span class="lineNum">    1979</span>              :                 ret = mbedtls_aes_setkey_enc(&amp;ctx, key, keybits);</span>
<span id="L1980"><span class="lineNum">    1980</span>              :                 aes_tests = aes_test_cbc_enc[u];</span>
<span id="L1981"><span class="lineNum">    1981</span>              :             }</span>
<span id="L1982"><span class="lineNum">    1982</span>              : </span>
<span id="L1983"><span class="lineNum">    1983</span>              :             /*</span>
<span id="L1984"><span class="lineNum">    1984</span>              :              * AES-192 is an optional feature that may be unavailable when</span>
<span id="L1985"><span class="lineNum">    1985</span>              :              * there is an alternative underlying implementation i.e. when</span>
<span id="L1986"><span class="lineNum">    1986</span>              :              * MBEDTLS_AES_ALT is defined.</span>
<span id="L1987"><span class="lineNum">    1987</span>              :              */</span>
<span id="L1988"><span class="lineNum">    1988</span>              :             if (ret == MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED &amp;&amp; keybits == 192) {</span>
<span id="L1989"><span class="lineNum">    1989</span>              :                 mbedtls_printf(&quot;skipped\n&quot;);</span>
<span id="L1990"><span class="lineNum">    1990</span>              :                 continue;</span>
<span id="L1991"><span class="lineNum">    1991</span>              :             } else if (ret != 0) {</span>
<span id="L1992"><span class="lineNum">    1992</span>              :                 goto exit;</span>
<span id="L1993"><span class="lineNum">    1993</span>              :             }</span>
<span id="L1994"><span class="lineNum">    1994</span>              : </span>
<span id="L1995"><span class="lineNum">    1995</span>              :             for (j = 0; j &lt; 10000; j++) {</span>
<span id="L1996"><span class="lineNum">    1996</span>              :                 if (mode == MBEDTLS_AES_ENCRYPT) {</span>
<span id="L1997"><span class="lineNum">    1997</span>              :                     unsigned char tmp[16];</span>
<span id="L1998"><span class="lineNum">    1998</span>              : </span>
<span id="L1999"><span class="lineNum">    1999</span>              :                     memcpy(tmp, prv, 16);</span>
<span id="L2000"><span class="lineNum">    2000</span>              :                     memcpy(prv, buf, 16);</span>
<span id="L2001"><span class="lineNum">    2001</span>              :                     memcpy(buf, tmp, 16);</span>
<span id="L2002"><span class="lineNum">    2002</span>              :                 }</span>
<span id="L2003"><span class="lineNum">    2003</span>              : </span>
<span id="L2004"><span class="lineNum">    2004</span>              :                 ret = mbedtls_aes_crypt_cbc(&amp;ctx, mode, 16, iv, buf, buf);</span>
<span id="L2005"><span class="lineNum">    2005</span>              :                 if (ret != 0) {</span>
<span id="L2006"><span class="lineNum">    2006</span>              :                     goto exit;</span>
<span id="L2007"><span class="lineNum">    2007</span>              :                 }</span>
<span id="L2008"><span class="lineNum">    2008</span>              : </span>
<span id="L2009"><span class="lineNum">    2009</span>              :             }</span>
<span id="L2010"><span class="lineNum">    2010</span>              : </span>
<span id="L2011"><span class="lineNum">    2011</span>              :             if (memcmp(buf, aes_tests, 16) != 0) {</span>
<span id="L2012"><span class="lineNum">    2012</span>              :                 ret = 1;</span>
<span id="L2013"><span class="lineNum">    2013</span>              :                 goto exit;</span>
<span id="L2014"><span class="lineNum">    2014</span>              :             }</span>
<span id="L2015"><span class="lineNum">    2015</span>              : </span>
<span id="L2016"><span class="lineNum">    2016</span>              :             if (verbose != 0) {</span>
<span id="L2017"><span class="lineNum">    2017</span>              :                 mbedtls_printf(&quot;passed\n&quot;);</span>
<span id="L2018"><span class="lineNum">    2018</span>              :             }</span>
<span id="L2019"><span class="lineNum">    2019</span>              :         }</span>
<span id="L2020"><span class="lineNum">    2020</span>              : </span>
<span id="L2021"><span class="lineNum">    2021</span>              :         if (verbose != 0) {</span>
<span id="L2022"><span class="lineNum">    2022</span>              :             mbedtls_printf(&quot;\n&quot;);</span>
<span id="L2023"><span class="lineNum">    2023</span>              :         }</span>
<span id="L2024"><span class="lineNum">    2024</span>              :     }</span>
<span id="L2025"><span class="lineNum">    2025</span>              : #endif /* MBEDTLS_CIPHER_MODE_CBC */</span>
<span id="L2026"><span class="lineNum">    2026</span>              : </span>
<span id="L2027"><span class="lineNum">    2027</span>              : #if defined(MBEDTLS_CIPHER_MODE_CFB)</span>
<span id="L2028"><span class="lineNum">    2028</span>              :     /*</span>
<span id="L2029"><span class="lineNum">    2029</span>              :      * CFB128 mode</span>
<span id="L2030"><span class="lineNum">    2030</span>              :      */</span>
<span id="L2031"><span class="lineNum">    2031</span>              :     {</span>
<span id="L2032"><span class="lineNum">    2032</span>              :         static const int num_tests =</span>
<span id="L2033"><span class="lineNum">    2033</span>              :             sizeof(aes_test_cfb128_key) / sizeof(*aes_test_cfb128_key);</span>
<span id="L2034"><span class="lineNum">    2034</span>              : </span>
<span id="L2035"><span class="lineNum">    2035</span>              :         for (i = 0; i &lt; num_tests &lt;&lt; 1; i++) {</span>
<span id="L2036"><span class="lineNum">    2036</span>              :             u = i &gt;&gt; 1;</span>
<span id="L2037"><span class="lineNum">    2037</span>              :             keybits = 128 + u * 64;</span>
<span id="L2038"><span class="lineNum">    2038</span>              :             mode = i &amp; 1;</span>
<span id="L2039"><span class="lineNum">    2039</span>              : </span>
<span id="L2040"><span class="lineNum">    2040</span>              :             if (verbose != 0) {</span>
<span id="L2041"><span class="lineNum">    2041</span>              :                 mbedtls_printf(&quot;  AES-CFB128-%3u (%s): &quot;, keybits,</span>
<span id="L2042"><span class="lineNum">    2042</span>              :                                (mode == MBEDTLS_AES_DECRYPT) ? &quot;dec&quot; : &quot;enc&quot;);</span>
<span id="L2043"><span class="lineNum">    2043</span>              :             }</span>
<span id="L2044"><span class="lineNum">    2044</span>              : </span>
<span id="L2045"><span class="lineNum">    2045</span>              :             memcpy(iv,  aes_test_cfb128_iv, 16);</span>
<span id="L2046"><span class="lineNum">    2046</span>              :             memcpy(key, aes_test_cfb128_key[u], keybits / 8);</span>
<span id="L2047"><span class="lineNum">    2047</span>              : </span>
<span id="L2048"><span class="lineNum">    2048</span>              :             offset = 0;</span>
<span id="L2049"><span class="lineNum">    2049</span>              :             ret = mbedtls_aes_setkey_enc(&amp;ctx, key, keybits);</span>
<span id="L2050"><span class="lineNum">    2050</span>              :             /*</span>
<span id="L2051"><span class="lineNum">    2051</span>              :              * AES-192 is an optional feature that may be unavailable when</span>
<span id="L2052"><span class="lineNum">    2052</span>              :              * there is an alternative underlying implementation i.e. when</span>
<span id="L2053"><span class="lineNum">    2053</span>              :              * MBEDTLS_AES_ALT is defined.</span>
<span id="L2054"><span class="lineNum">    2054</span>              :              */</span>
<span id="L2055"><span class="lineNum">    2055</span>              :             if (ret == MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED &amp;&amp; keybits == 192) {</span>
<span id="L2056"><span class="lineNum">    2056</span>              :                 mbedtls_printf(&quot;skipped\n&quot;);</span>
<span id="L2057"><span class="lineNum">    2057</span>              :                 continue;</span>
<span id="L2058"><span class="lineNum">    2058</span>              :             } else if (ret != 0) {</span>
<span id="L2059"><span class="lineNum">    2059</span>              :                 goto exit;</span>
<span id="L2060"><span class="lineNum">    2060</span>              :             }</span>
<span id="L2061"><span class="lineNum">    2061</span>              : </span>
<span id="L2062"><span class="lineNum">    2062</span>              :             if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L2063"><span class="lineNum">    2063</span>              :                 memcpy(buf, aes_test_cfb128_ct[u], 64);</span>
<span id="L2064"><span class="lineNum">    2064</span>              :                 aes_tests = aes_test_cfb128_pt;</span>
<span id="L2065"><span class="lineNum">    2065</span>              :             } else {</span>
<span id="L2066"><span class="lineNum">    2066</span>              :                 memcpy(buf, aes_test_cfb128_pt, 64);</span>
<span id="L2067"><span class="lineNum">    2067</span>              :                 aes_tests = aes_test_cfb128_ct[u];</span>
<span id="L2068"><span class="lineNum">    2068</span>              :             }</span>
<span id="L2069"><span class="lineNum">    2069</span>              : </span>
<span id="L2070"><span class="lineNum">    2070</span>              :             ret = mbedtls_aes_crypt_cfb128(&amp;ctx, mode, 64, &amp;offset, iv, buf, buf);</span>
<span id="L2071"><span class="lineNum">    2071</span>              :             if (ret != 0) {</span>
<span id="L2072"><span class="lineNum">    2072</span>              :                 goto exit;</span>
<span id="L2073"><span class="lineNum">    2073</span>              :             }</span>
<span id="L2074"><span class="lineNum">    2074</span>              : </span>
<span id="L2075"><span class="lineNum">    2075</span>              :             if (memcmp(buf, aes_tests, 64) != 0) {</span>
<span id="L2076"><span class="lineNum">    2076</span>              :                 ret = 1;</span>
<span id="L2077"><span class="lineNum">    2077</span>              :                 goto exit;</span>
<span id="L2078"><span class="lineNum">    2078</span>              :             }</span>
<span id="L2079"><span class="lineNum">    2079</span>              : </span>
<span id="L2080"><span class="lineNum">    2080</span>              :             if (verbose != 0) {</span>
<span id="L2081"><span class="lineNum">    2081</span>              :                 mbedtls_printf(&quot;passed\n&quot;);</span>
<span id="L2082"><span class="lineNum">    2082</span>              :             }</span>
<span id="L2083"><span class="lineNum">    2083</span>              :         }</span>
<span id="L2084"><span class="lineNum">    2084</span>              : </span>
<span id="L2085"><span class="lineNum">    2085</span>              :         if (verbose != 0) {</span>
<span id="L2086"><span class="lineNum">    2086</span>              :             mbedtls_printf(&quot;\n&quot;);</span>
<span id="L2087"><span class="lineNum">    2087</span>              :         }</span>
<span id="L2088"><span class="lineNum">    2088</span>              :     }</span>
<span id="L2089"><span class="lineNum">    2089</span>              : #endif /* MBEDTLS_CIPHER_MODE_CFB */</span>
<span id="L2090"><span class="lineNum">    2090</span>              : </span>
<span id="L2091"><span class="lineNum">    2091</span>              : #if defined(MBEDTLS_CIPHER_MODE_OFB)</span>
<span id="L2092"><span class="lineNum">    2092</span>              :     /*</span>
<span id="L2093"><span class="lineNum">    2093</span>              :      * OFB mode</span>
<span id="L2094"><span class="lineNum">    2094</span>              :      */</span>
<span id="L2095"><span class="lineNum">    2095</span>              :     {</span>
<span id="L2096"><span class="lineNum">    2096</span>              :         static const int num_tests =</span>
<span id="L2097"><span class="lineNum">    2097</span>              :             sizeof(aes_test_ofb_key) / sizeof(*aes_test_ofb_key);</span>
<span id="L2098"><span class="lineNum">    2098</span>              : </span>
<span id="L2099"><span class="lineNum">    2099</span>              :         for (i = 0; i &lt; num_tests &lt;&lt; 1; i++) {</span>
<span id="L2100"><span class="lineNum">    2100</span>              :             u = i &gt;&gt; 1;</span>
<span id="L2101"><span class="lineNum">    2101</span>              :             keybits = 128 + u * 64;</span>
<span id="L2102"><span class="lineNum">    2102</span>              :             mode = i &amp; 1;</span>
<span id="L2103"><span class="lineNum">    2103</span>              : </span>
<span id="L2104"><span class="lineNum">    2104</span>              :             if (verbose != 0) {</span>
<span id="L2105"><span class="lineNum">    2105</span>              :                 mbedtls_printf(&quot;  AES-OFB-%3u (%s): &quot;, keybits,</span>
<span id="L2106"><span class="lineNum">    2106</span>              :                                (mode == MBEDTLS_AES_DECRYPT) ? &quot;dec&quot; : &quot;enc&quot;);</span>
<span id="L2107"><span class="lineNum">    2107</span>              :             }</span>
<span id="L2108"><span class="lineNum">    2108</span>              : </span>
<span id="L2109"><span class="lineNum">    2109</span>              :             memcpy(iv,  aes_test_ofb_iv, 16);</span>
<span id="L2110"><span class="lineNum">    2110</span>              :             memcpy(key, aes_test_ofb_key[u], keybits / 8);</span>
<span id="L2111"><span class="lineNum">    2111</span>              : </span>
<span id="L2112"><span class="lineNum">    2112</span>              :             offset = 0;</span>
<span id="L2113"><span class="lineNum">    2113</span>              :             ret = mbedtls_aes_setkey_enc(&amp;ctx, key, keybits);</span>
<span id="L2114"><span class="lineNum">    2114</span>              :             /*</span>
<span id="L2115"><span class="lineNum">    2115</span>              :              * AES-192 is an optional feature that may be unavailable when</span>
<span id="L2116"><span class="lineNum">    2116</span>              :              * there is an alternative underlying implementation i.e. when</span>
<span id="L2117"><span class="lineNum">    2117</span>              :              * MBEDTLS_AES_ALT is defined.</span>
<span id="L2118"><span class="lineNum">    2118</span>              :              */</span>
<span id="L2119"><span class="lineNum">    2119</span>              :             if (ret == MBEDTLS_ERR_PLATFORM_FEATURE_UNSUPPORTED &amp;&amp; keybits == 192) {</span>
<span id="L2120"><span class="lineNum">    2120</span>              :                 mbedtls_printf(&quot;skipped\n&quot;);</span>
<span id="L2121"><span class="lineNum">    2121</span>              :                 continue;</span>
<span id="L2122"><span class="lineNum">    2122</span>              :             } else if (ret != 0) {</span>
<span id="L2123"><span class="lineNum">    2123</span>              :                 goto exit;</span>
<span id="L2124"><span class="lineNum">    2124</span>              :             }</span>
<span id="L2125"><span class="lineNum">    2125</span>              : </span>
<span id="L2126"><span class="lineNum">    2126</span>              :             if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L2127"><span class="lineNum">    2127</span>              :                 memcpy(buf, aes_test_ofb_ct[u], 64);</span>
<span id="L2128"><span class="lineNum">    2128</span>              :                 aes_tests = aes_test_ofb_pt;</span>
<span id="L2129"><span class="lineNum">    2129</span>              :             } else {</span>
<span id="L2130"><span class="lineNum">    2130</span>              :                 memcpy(buf, aes_test_ofb_pt, 64);</span>
<span id="L2131"><span class="lineNum">    2131</span>              :                 aes_tests = aes_test_ofb_ct[u];</span>
<span id="L2132"><span class="lineNum">    2132</span>              :             }</span>
<span id="L2133"><span class="lineNum">    2133</span>              : </span>
<span id="L2134"><span class="lineNum">    2134</span>              :             ret = mbedtls_aes_crypt_ofb(&amp;ctx, 64, &amp;offset, iv, buf, buf);</span>
<span id="L2135"><span class="lineNum">    2135</span>              :             if (ret != 0) {</span>
<span id="L2136"><span class="lineNum">    2136</span>              :                 goto exit;</span>
<span id="L2137"><span class="lineNum">    2137</span>              :             }</span>
<span id="L2138"><span class="lineNum">    2138</span>              : </span>
<span id="L2139"><span class="lineNum">    2139</span>              :             if (memcmp(buf, aes_tests, 64) != 0) {</span>
<span id="L2140"><span class="lineNum">    2140</span>              :                 ret = 1;</span>
<span id="L2141"><span class="lineNum">    2141</span>              :                 goto exit;</span>
<span id="L2142"><span class="lineNum">    2142</span>              :             }</span>
<span id="L2143"><span class="lineNum">    2143</span>              : </span>
<span id="L2144"><span class="lineNum">    2144</span>              :             if (verbose != 0) {</span>
<span id="L2145"><span class="lineNum">    2145</span>              :                 mbedtls_printf(&quot;passed\n&quot;);</span>
<span id="L2146"><span class="lineNum">    2146</span>              :             }</span>
<span id="L2147"><span class="lineNum">    2147</span>              :         }</span>
<span id="L2148"><span class="lineNum">    2148</span>              : </span>
<span id="L2149"><span class="lineNum">    2149</span>              :         if (verbose != 0) {</span>
<span id="L2150"><span class="lineNum">    2150</span>              :             mbedtls_printf(&quot;\n&quot;);</span>
<span id="L2151"><span class="lineNum">    2151</span>              :         }</span>
<span id="L2152"><span class="lineNum">    2152</span>              :     }</span>
<span id="L2153"><span class="lineNum">    2153</span>              : #endif /* MBEDTLS_CIPHER_MODE_OFB */</span>
<span id="L2154"><span class="lineNum">    2154</span>              : </span>
<span id="L2155"><span class="lineNum">    2155</span>              : #if defined(MBEDTLS_CIPHER_MODE_CTR)</span>
<span id="L2156"><span class="lineNum">    2156</span>              :     /*</span>
<span id="L2157"><span class="lineNum">    2157</span>              :      * CTR mode</span>
<span id="L2158"><span class="lineNum">    2158</span>              :      */</span>
<span id="L2159"><span class="lineNum">    2159</span>              :     {</span>
<span id="L2160"><span class="lineNum">    2160</span>              :         static const int num_tests =</span>
<span id="L2161"><span class="lineNum">    2161</span>              :             sizeof(aes_test_ctr_key) / sizeof(*aes_test_ctr_key);</span>
<span id="L2162"><span class="lineNum">    2162</span>              : </span>
<span id="L2163"><span class="lineNum">    2163</span>              :         for (i = 0; i &lt; num_tests &lt;&lt; 1; i++) {</span>
<span id="L2164"><span class="lineNum">    2164</span>              :             u = i &gt;&gt; 1;</span>
<span id="L2165"><span class="lineNum">    2165</span>              :             mode = i &amp; 1;</span>
<span id="L2166"><span class="lineNum">    2166</span>              : </span>
<span id="L2167"><span class="lineNum">    2167</span>              :             if (verbose != 0) {</span>
<span id="L2168"><span class="lineNum">    2168</span>              :                 mbedtls_printf(&quot;  AES-CTR-128 (%s): &quot;,</span>
<span id="L2169"><span class="lineNum">    2169</span>              :                                (mode == MBEDTLS_AES_DECRYPT) ? &quot;dec&quot; : &quot;enc&quot;);</span>
<span id="L2170"><span class="lineNum">    2170</span>              :             }</span>
<span id="L2171"><span class="lineNum">    2171</span>              : </span>
<span id="L2172"><span class="lineNum">    2172</span>              :             memcpy(nonce_counter, aes_test_ctr_nonce_counter[u], 16);</span>
<span id="L2173"><span class="lineNum">    2173</span>              :             memcpy(key, aes_test_ctr_key[u], 16);</span>
<span id="L2174"><span class="lineNum">    2174</span>              : </span>
<span id="L2175"><span class="lineNum">    2175</span>              :             offset = 0;</span>
<span id="L2176"><span class="lineNum">    2176</span>              :             if ((ret = mbedtls_aes_setkey_enc(&amp;ctx, key, 128)) != 0) {</span>
<span id="L2177"><span class="lineNum">    2177</span>              :                 goto exit;</span>
<span id="L2178"><span class="lineNum">    2178</span>              :             }</span>
<span id="L2179"><span class="lineNum">    2179</span>              : </span>
<span id="L2180"><span class="lineNum">    2180</span>              :             len = aes_test_ctr_len[u];</span>
<span id="L2181"><span class="lineNum">    2181</span>              : </span>
<span id="L2182"><span class="lineNum">    2182</span>              :             if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L2183"><span class="lineNum">    2183</span>              :                 memcpy(buf, aes_test_ctr_ct[u], len);</span>
<span id="L2184"><span class="lineNum">    2184</span>              :                 aes_tests = aes_test_ctr_pt[u];</span>
<span id="L2185"><span class="lineNum">    2185</span>              :             } else {</span>
<span id="L2186"><span class="lineNum">    2186</span>              :                 memcpy(buf, aes_test_ctr_pt[u], len);</span>
<span id="L2187"><span class="lineNum">    2187</span>              :                 aes_tests = aes_test_ctr_ct[u];</span>
<span id="L2188"><span class="lineNum">    2188</span>              :             }</span>
<span id="L2189"><span class="lineNum">    2189</span>              : </span>
<span id="L2190"><span class="lineNum">    2190</span>              :             ret = mbedtls_aes_crypt_ctr(&amp;ctx, len, &amp;offset, nonce_counter,</span>
<span id="L2191"><span class="lineNum">    2191</span>              :                                         stream_block, buf, buf);</span>
<span id="L2192"><span class="lineNum">    2192</span>              :             if (ret != 0) {</span>
<span id="L2193"><span class="lineNum">    2193</span>              :                 goto exit;</span>
<span id="L2194"><span class="lineNum">    2194</span>              :             }</span>
<span id="L2195"><span class="lineNum">    2195</span>              : </span>
<span id="L2196"><span class="lineNum">    2196</span>              :             if (memcmp(buf, aes_tests, len) != 0) {</span>
<span id="L2197"><span class="lineNum">    2197</span>              :                 ret = 1;</span>
<span id="L2198"><span class="lineNum">    2198</span>              :                 goto exit;</span>
<span id="L2199"><span class="lineNum">    2199</span>              :             }</span>
<span id="L2200"><span class="lineNum">    2200</span>              : </span>
<span id="L2201"><span class="lineNum">    2201</span>              :             if (verbose != 0) {</span>
<span id="L2202"><span class="lineNum">    2202</span>              :                 mbedtls_printf(&quot;passed\n&quot;);</span>
<span id="L2203"><span class="lineNum">    2203</span>              :             }</span>
<span id="L2204"><span class="lineNum">    2204</span>              :         }</span>
<span id="L2205"><span class="lineNum">    2205</span>              :     }</span>
<span id="L2206"><span class="lineNum">    2206</span>              : </span>
<span id="L2207"><span class="lineNum">    2207</span>              :     if (verbose != 0) {</span>
<span id="L2208"><span class="lineNum">    2208</span>              :         mbedtls_printf(&quot;\n&quot;);</span>
<span id="L2209"><span class="lineNum">    2209</span>              :     }</span>
<span id="L2210"><span class="lineNum">    2210</span>              : #endif /* MBEDTLS_CIPHER_MODE_CTR */</span>
<span id="L2211"><span class="lineNum">    2211</span>              : </span>
<span id="L2212"><span class="lineNum">    2212</span>              : #if defined(MBEDTLS_CIPHER_MODE_XTS)</span>
<span id="L2213"><span class="lineNum">    2213</span>              :     /*</span>
<span id="L2214"><span class="lineNum">    2214</span>              :      * XTS mode</span>
<span id="L2215"><span class="lineNum">    2215</span>              :      */</span>
<span id="L2216"><span class="lineNum">    2216</span>              :     {</span>
<span id="L2217"><span class="lineNum">    2217</span>              :         static const int num_tests =</span>
<span id="L2218"><span class="lineNum">    2218</span>              :             sizeof(aes_test_xts_key) / sizeof(*aes_test_xts_key);</span>
<span id="L2219"><span class="lineNum">    2219</span>              :         mbedtls_aes_xts_context ctx_xts;</span>
<span id="L2220"><span class="lineNum">    2220</span>              : </span>
<span id="L2221"><span class="lineNum">    2221</span>              :         mbedtls_aes_xts_init(&amp;ctx_xts);</span>
<span id="L2222"><span class="lineNum">    2222</span>              : </span>
<span id="L2223"><span class="lineNum">    2223</span>              :         for (i = 0; i &lt; num_tests &lt;&lt; 1; i++) {</span>
<span id="L2224"><span class="lineNum">    2224</span>              :             const unsigned char *data_unit;</span>
<span id="L2225"><span class="lineNum">    2225</span>              :             u = i &gt;&gt; 1;</span>
<span id="L2226"><span class="lineNum">    2226</span>              :             mode = i &amp; 1;</span>
<span id="L2227"><span class="lineNum">    2227</span>              : </span>
<span id="L2228"><span class="lineNum">    2228</span>              :             if (verbose != 0) {</span>
<span id="L2229"><span class="lineNum">    2229</span>              :                 mbedtls_printf(&quot;  AES-XTS-128 (%s): &quot;,</span>
<span id="L2230"><span class="lineNum">    2230</span>              :                                (mode == MBEDTLS_AES_DECRYPT) ? &quot;dec&quot; : &quot;enc&quot;);</span>
<span id="L2231"><span class="lineNum">    2231</span>              :             }</span>
<span id="L2232"><span class="lineNum">    2232</span>              : </span>
<span id="L2233"><span class="lineNum">    2233</span>              :             memset(key, 0, sizeof(key));</span>
<span id="L2234"><span class="lineNum">    2234</span>              :             memcpy(key, aes_test_xts_key[u], 32);</span>
<span id="L2235"><span class="lineNum">    2235</span>              :             data_unit = aes_test_xts_data_unit[u];</span>
<span id="L2236"><span class="lineNum">    2236</span>              : </span>
<span id="L2237"><span class="lineNum">    2237</span>              :             len = sizeof(*aes_test_xts_ct32);</span>
<span id="L2238"><span class="lineNum">    2238</span>              : </span>
<span id="L2239"><span class="lineNum">    2239</span>              :             if (mode == MBEDTLS_AES_DECRYPT) {</span>
<span id="L2240"><span class="lineNum">    2240</span>              :                 ret = mbedtls_aes_xts_setkey_dec(&amp;ctx_xts, key, 256);</span>
<span id="L2241"><span class="lineNum">    2241</span>              :                 if (ret != 0) {</span>
<span id="L2242"><span class="lineNum">    2242</span>              :                     goto exit;</span>
<span id="L2243"><span class="lineNum">    2243</span>              :                 }</span>
<span id="L2244"><span class="lineNum">    2244</span>              :                 memcpy(buf, aes_test_xts_ct32[u], len);</span>
<span id="L2245"><span class="lineNum">    2245</span>              :                 aes_tests = aes_test_xts_pt32[u];</span>
<span id="L2246"><span class="lineNum">    2246</span>              :             } else {</span>
<span id="L2247"><span class="lineNum">    2247</span>              :                 ret = mbedtls_aes_xts_setkey_enc(&amp;ctx_xts, key, 256);</span>
<span id="L2248"><span class="lineNum">    2248</span>              :                 if (ret != 0) {</span>
<span id="L2249"><span class="lineNum">    2249</span>              :                     goto exit;</span>
<span id="L2250"><span class="lineNum">    2250</span>              :                 }</span>
<span id="L2251"><span class="lineNum">    2251</span>              :                 memcpy(buf, aes_test_xts_pt32[u], len);</span>
<span id="L2252"><span class="lineNum">    2252</span>              :                 aes_tests = aes_test_xts_ct32[u];</span>
<span id="L2253"><span class="lineNum">    2253</span>              :             }</span>
<span id="L2254"><span class="lineNum">    2254</span>              : </span>
<span id="L2255"><span class="lineNum">    2255</span>              : </span>
<span id="L2256"><span class="lineNum">    2256</span>              :             ret = mbedtls_aes_crypt_xts(&amp;ctx_xts, mode, len, data_unit,</span>
<span id="L2257"><span class="lineNum">    2257</span>              :                                         buf, buf);</span>
<span id="L2258"><span class="lineNum">    2258</span>              :             if (ret != 0) {</span>
<span id="L2259"><span class="lineNum">    2259</span>              :                 goto exit;</span>
<span id="L2260"><span class="lineNum">    2260</span>              :             }</span>
<span id="L2261"><span class="lineNum">    2261</span>              : </span>
<span id="L2262"><span class="lineNum">    2262</span>              :             if (memcmp(buf, aes_tests, len) != 0) {</span>
<span id="L2263"><span class="lineNum">    2263</span>              :                 ret = 1;</span>
<span id="L2264"><span class="lineNum">    2264</span>              :                 goto exit;</span>
<span id="L2265"><span class="lineNum">    2265</span>              :             }</span>
<span id="L2266"><span class="lineNum">    2266</span>              : </span>
<span id="L2267"><span class="lineNum">    2267</span>              :             if (verbose != 0) {</span>
<span id="L2268"><span class="lineNum">    2268</span>              :                 mbedtls_printf(&quot;passed\n&quot;);</span>
<span id="L2269"><span class="lineNum">    2269</span>              :             }</span>
<span id="L2270"><span class="lineNum">    2270</span>              :         }</span>
<span id="L2271"><span class="lineNum">    2271</span>              : </span>
<span id="L2272"><span class="lineNum">    2272</span>              :         if (verbose != 0) {</span>
<span id="L2273"><span class="lineNum">    2273</span>              :             mbedtls_printf(&quot;\n&quot;);</span>
<span id="L2274"><span class="lineNum">    2274</span>              :         }</span>
<span id="L2275"><span class="lineNum">    2275</span>              : </span>
<span id="L2276"><span class="lineNum">    2276</span>              :         mbedtls_aes_xts_free(&amp;ctx_xts);</span>
<span id="L2277"><span class="lineNum">    2277</span>              :     }</span>
<span id="L2278"><span class="lineNum">    2278</span>              : #endif /* MBEDTLS_CIPHER_MODE_XTS */</span>
<span id="L2279"><span class="lineNum">    2279</span>              : </span>
<span id="L2280"><span class="lineNum">    2280</span> <span class="tlaUNC">           0 :     ret = 0;</span></span>
<span id="L2281"><span class="lineNum">    2281</span>              : </span>
<span id="L2282"><span class="lineNum">    2282</span> <span class="tlaUNC">           0 : exit:</span></span>
<span id="L2283"><span class="lineNum">    2283</span> <span class="tlaUNC">           0 :     if (ret != 0 &amp;&amp; verbose != 0) {</span></span>
<span id="L2284"><span class="lineNum">    2284</span> <span class="tlaUNC">           0 :         mbedtls_printf(&quot;failed\n&quot;);</span></span>
<span id="L2285"><span class="lineNum">    2285</span>              :     }</span>
<span id="L2286"><span class="lineNum">    2286</span>              : </span>
<span id="L2287"><span class="lineNum">    2287</span> <span class="tlaUNC">           0 :     mbedtls_aes_free(&amp;ctx);</span></span>
<span id="L2288"><span class="lineNum">    2288</span>              : </span>
<span id="L2289"><span class="lineNum">    2289</span> <span class="tlaUNC">           0 :     return ret;</span></span>
<span id="L2290"><span class="lineNum">    2290</span>              : }</span>
<span id="L2291"><span class="lineNum">    2291</span>              : </span>
<span id="L2292"><span class="lineNum">    2292</span>              : #endif /* MBEDTLS_SELF_TEST */</span>
<span id="L2293"><span class="lineNum">    2293</span>              : </span>
<span id="L2294"><span class="lineNum">    2294</span>              : #endif /* MBEDTLS_AES_C */</span>
        </pre>
              </td>
            </tr>
          </table>
          <br>

          <table width="100%" border=0 cellspacing=0 cellpadding=0>
            <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
            <tr><td class="versionInfo">Generated by: <a href="https://github.com//linux-test-project/lcov" target="_parent">LCOV version 2.0-1</a></td></tr>
          </table>
          <br>

</body>
</html>
